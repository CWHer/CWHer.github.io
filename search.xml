<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一个Splay模板]]></title>
    <url>%2F2018%2F06%2F11%2Fsplay%2F</url>
    <content type="text"><![CDATA[优化了一下之前Splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;const int INF=1&lt;&lt;30,N=100050;int rt=0,cnt=0,n;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;struct node &#123;int ch[2],fa,rec,val,sz;&#125;t[N];namespace Splay&#123; void calc(int o) &#123;t[o].sz=t[t[o].ch[0]].sz+t[t[o].ch[1]].sz+t[o].rec;&#125; void rotate(int x) &#123; int y=t[x].fa,z=t[y].fa,k=t[y].ch[1]==x; t[z].ch[t[z].ch[1]==y]=x,t[x].fa=z; t[y].ch[k]=t[x].ch[k^1],t[t[x].ch[k^1]].fa=y; t[x].ch[k^1]=y,t[y].fa=x; calc(y),calc(x); &#125; void splay(int x,int to) &#123; while (t[x].fa!=to) &#123; int y=t[x].fa,z=t[y].fa; if (z!=to) (t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; if (!to) rt=x; &#125; void ins(int &amp;o,int fa,int x) &#123; if (!o) &#123; o=++cnt; t[o].val=x,t[o].fa=fa; t[o].sz=t[o].rec=1; splay(o,0); return; &#125; t[o].sz++; if (x==t[o].val) &#123;t[o].rec++;return;&#125; ins(t[o].ch[x&gt;t[o].val],o,x); &#125; void find(int x) &#123; int o=rt; while (t[o].ch[x&gt;t[o].val]&amp;&amp;x!=t[o].val) o=t[o].ch[x&gt;t[o].val]; splay(o,0); &#125; int next(int x,int opt) &#123; find(x); if ((t[rt].val&gt;x&amp;&amp;opt)||(t[rt].val&lt;x&amp;&amp;!opt)) return rt; int o=t[rt].ch[opt]; while (t[o].ch[opt^1]) o=t[o].ch[opt^1]; return o; &#125; void del(int x) &#123; int pre=next(x,0),nxt=next(x,1); splay(pre,0),splay(nxt,pre); int o=t[nxt].ch[0]; if (t[o].rec&gt;1) &#123; t[o].rec--; splay(o,0); &#125; else t[nxt].ch[0]=0; &#125; int K_th(int o,int k) &#123; if (!o) return 0; if (k&lt;=t[t[o].ch[0]].sz) return K_th(t[o].ch[0],k); else if (k&gt;t[t[o].ch[0]].sz+t[o].rec) return K_th(t[o].ch[1],k-t[t[o].ch[0]].sz-t[o].rec); splay(o,0); return t[o].val; &#125;&#125;;using namespace Splay;int main()&#123; n=read(); ins(rt,0,INF),ins(rt,0,-INF); for(int i=1;i&lt;=n;i++) &#123; int opt=read(),x=read(); if (opt==1) ins(rt,0,x); if (opt==2) del(x); if (opt==3) find(x),printf("%d\n",t[t[rt].ch[0]].sz); if (opt==4) printf("%d\n",K_th(rt,x+1)); if (opt==5) printf("%d\n",t[next(x,0)].val); if (opt==6) printf("%d\n",t[next(x,1)].val); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
