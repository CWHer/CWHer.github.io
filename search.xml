<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[HNOI2009]梦幻布丁]]></title>
    <url>%2F2018%2F06%2F20%2FHNOI2009-%E6%A2%A6%E5%B9%BB%E5%B8%83%E4%B8%81%2F</url>
    <content type="text"><![CDATA[用玄学复杂度并查集维护在代表元素中保存当前段的颜色（w[]），和左右端点（s[]，t[]）再用一个桶维护每种颜色的所有段当且仅当要合并两段颜色相同时进行合并，并更新左右端点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=100050;int fa[N],w[N],cnt,s[N],t[N],n,m;vector&lt;int&gt; f[N*10];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;int find(int x) &#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void unite(int u,int v)&#123; if (!u||!v) return; u=find(u),v=find(v); if (w[u]!=w[v]) return;else cnt--; fa[v]=u,s[u]=min(s[u],s[v]),t[u]=max(t[u],t[v]);&#125;void update()&#123; int u=read(),v=read(); if (u==v) return; while (!f[u].empty()) &#123; int x=f[u].back();f[u].pop_back(); if (find(x)!=x) continue;else w[x]=v; int st=s[x],ed=t[x]; if (st&gt;1) unite(st-1,st); if (ed&lt;n) unite(ed,ed+1); if (find(x)==x) f[v].push_back(x); &#125; &#125;int main()&#123; n=cnt=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),fa[i]=i; for(int i=1;i&lt;=n;i++) s[i]=t[i]=i; for(int i=1;i&lt;n;i++) unite(i,i+1); for(int i=1;i&lt;=n;i++) if (i==find(i)) f[w[i]].push_back(i); for(int i=1;i&lt;=m;i++) &#123; int opt=read(); if (opt==1) update(); if (opt==2) printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1471 方差]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%B4%9B%E8%B0%B7P1471-%E6%96%B9%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[区间修改，区间查询，基本可以用线段树维护，主要是方差比较难维护将方差的计算展开 \frac{\sum_{i=1}^{n} \left ( a_{i}-\bar{a} \right )^{2}}{n}= \frac{\sum_{i=1}^{n} a_{i}^{2}-2\bar{a}\sum_{i=1}^{n}a_{i}+n\bar{a}^{2}}{n}= -\bar{a}^{2}+\frac{\sum_{i=1}^{n}a_{i}^{2}}{n}对于区间加法 \sum_{i=l}^{r}\left ( a_{i}+x \right )^{2}= \sum_{i=l}^{r}a_{i}^{2}+2x\sum_{i=l}^{r}a_{i}+\left ( r-l+1 \right )*x^{2}12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N=100050;const double eps=1e-8;int n,m,ql,qr;struct node &#123;double val,sum,c;&#125; t[N&lt;&lt;2]; double sqr(double x) &#123;return x*x;&#125;void build(int o,int l,int r)&#123; if (l==r) &#123; scanf("%lf",&amp;t[o].val); t[o].sum=sqr(t[o].val); return; &#125; int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); t[o].val=t[o&lt;&lt;1].val+t[o&lt;&lt;1|1].val; t[o].sum=t[o&lt;&lt;1].sum+t[o&lt;&lt;1|1].sum;&#125;void pushdown(int o,int l,int r)&#123; double x=t[o].c;t[o].c=0; int mid=(l+r)&gt;&gt;1; t[o&lt;&lt;1].sum+=(mid-l+1)*sqr(x)+2*x*t[o&lt;&lt;1].val; t[o&lt;&lt;1|1].sum+=(r-mid)*sqr(x)+2*x*t[o&lt;&lt;1|1].val; t[o&lt;&lt;1].val+=(mid-l+1)*x; t[o&lt;&lt;1|1].val+=(r-mid)*x; t[o&lt;&lt;1].c+=x,t[o&lt;&lt;1|1].c+=x; &#125;void update(int o,int l,int r,double x)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123; t[o].sum+=sqr(x)*(r-l+1)+2*x*t[o].val; t[o].val+=(r-l+1)*x;t[o].c+=x; return; &#125; int mid=(l+r)&gt;&gt;1; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) update(o&lt;&lt;1,l,mid,x); if (qr&gt;mid) update(o&lt;&lt;1|1,mid+1,r,x); t[o].val=t[o&lt;&lt;1].val+t[o&lt;&lt;1|1].val; t[o].sum=t[o&lt;&lt;1].sum+t[o&lt;&lt;1|1].sum;&#125;double ask(int o,int l,int r)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return t[o].val; int mid=(l+r)&gt;&gt;1;double ret=0; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) ret+=ask(o&lt;&lt;1,l,mid); if (qr&gt;mid) ret+=ask(o&lt;&lt;1|1,mid+1,r); return ret;&#125;double query(int o,int l,int r)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return t[o].sum; int mid=(l+r)&gt;&gt;1;double ret=0; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) ret+=query(o&lt;&lt;1,l,mid); if (qr&gt;mid) ret+=query(o&lt;&lt;1|1,mid+1,r); return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; int opt; scanf("%d%d%d",&amp;opt,&amp;ql,&amp;qr); if (opt==1) &#123; double x;scanf("%lf",&amp;x); update(1,1,n,x); &#125; if (opt==2) printf("%.4lf\n",ask(1,1,n)/(qr-ql+1)); if (opt==3) &#123; double x=ask(1,1,n)/(qr-ql+1); printf("%.4lf\n",-sqr(x)+query(1,1,n)/(qr-ql+1)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]书架]]></title>
    <url>%2F2018%2F06%2F13%2FZJOI2006-%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一看题目就有一种平衡树的气息。给每本书一个val来维护相对位置再用一个pos[]数组记录下编号为x的位置pos[x]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=1&lt;&lt;30,N=200050;int rt=0,cnt=0,n,m,pos[N],w[N],L,R;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;struct node &#123;int ch[2],fa,rec,val,sz;&#125;t[N];namespace Splay&#123; void calc(int o) &#123;t[o].sz=t[t[o].ch[0]].sz+t[t[o].ch[1]].sz+1;&#125; void maintain(int o) &#123;pos[t[o].rec]=o;&#125; void rotate(int x) &#123; int y=t[x].fa,z=t[y].fa,k=t[y].ch[1]==x; t[z].ch[t[z].ch[1]==y]=x,t[x].fa=z; t[y].ch[k]=t[x].ch[k^1],t[t[x].ch[k^1]].fa=y; t[x].ch[k^1]=y,t[y].fa=x; calc(y),calc(x); &#125; void splay(int x,int to) &#123; while (t[x].fa!=to) &#123; int y=t[x].fa,z=t[y].fa; if (z!=to) (t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; if (!to) rt=x; &#125; void ins(int &amp;o,int fa,int x,int idx) &#123; if (!o) &#123; o=++cnt; t[o].val=x,t[o].fa=fa; t[o].sz=1; t[o].rec=idx; pos[idx]=o; splay(o,0); return; &#125; t[o].sz++; ins(t[o].ch[x&gt;t[o].val],o,x,idx); &#125; void find(int x) &#123; int o=rt; while (t[o].ch[x&gt;t[o].val]&amp;&amp;x!=t[o].val) o=t[o].ch[x&gt;t[o].val]; splay(o,0); &#125; int next(int x,int opt) &#123; find(x); if ((t[rt].val&gt;x&amp;&amp;opt)||(t[rt].val&lt;x&amp;&amp;!opt)) return rt; int o=t[rt].ch[opt]; while (t[o].ch[opt^1]) o=t[o].ch[opt^1]; return o; &#125; void del(int x) &#123; int pre=next(x,0),nxt=next(x,1); splay(pre,0),splay(nxt,pre); int o=t[nxt].ch[0]; t[nxt].ch[0]=0; calc(nxt);calc(pre); &#125; int K_th(int o,int k) &#123; if (!o) return 0; if (k&lt;=t[t[o].ch[0]].sz) return K_th(t[o].ch[0],k); else if (k&gt;t[t[o].ch[0]].sz+1) return K_th(t[o].ch[1],k-t[t[o].ch[0]].sz-1); splay(o,0); return t[o].rec; &#125;&#125;;using namespace Splay;void insert(int x,int f)&#123; if (!f) return; if (f&lt;0) f++; int nxt=next(t[pos[x]].val,f); swap(t[nxt].rec,t[pos[x]].rec); maintain(pos[x]),maintain(nxt);&#125;int main()&#123; L=1,R=n=read(),m=read(); ins(rt,0,INF,0),ins(rt,0,-INF,0); for(int i=1;i&lt;=n;i++) ins(rt,0,i,read()); for(int i=1;i&lt;=m;i++) &#123; char str[20]; scanf("%s",str); int x=read(); if (str[0]=='T') del(t[pos[x]].val),ins(rt,0,--L,x); if (str[0]=='B') del(t[pos[x]].val),ins(rt,0,++R,x); if (str[0]=='I') insert(x,read()); if (str[0]=='A') find(t[pos[x]].val),printf("%d\n",t[t[rt].ch[0]].sz-1); if (str[0]=='Q') printf("%d\n",K_th(rt,x+1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2011]ROT-Tree Rotations]]></title>
    <url>%2F2018%2F06%2F13%2FPOI2011-ROT-Tree-Rotations%2F</url>
    <content type="text"><![CDATA[对于每个节点分别求左-右，右-左的逆序对，将较小的加入答案原来思路：枚举个数较少的节点的每个数，二分求答案看完题解发现可以用线段树合并。新技能get123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=400050;int cnt,st,ch[N][2],w[N],rt[N],n;int idx,ls[N*20],rs[N*20],sum[N*20];LL ans,f,g;void dfs(int &amp;o)&#123; o=++cnt; scanf("%d",&amp;w[o]); if (!w[o]) dfs(ch[o][0]),dfs(ch[o][1]);&#125;void build(int &amp;o,int l,int r,int k)&#123; o=++idx; if (l==r) &#123;sum[o]=1;return;&#125; int mid=(l+r)&gt;&gt;1; k&lt;=mid?build(ls[o],l,mid,k):build(rs[o],mid+1,r,k); sum[o]=sum[ls[o]]+sum[rs[o]];&#125;int merge(int u,int v)&#123; if (!u||!v) return v+u; f+=(LL)sum[rs[u]]*sum[ls[v]]; g+=(LL)sum[ls[u]]*sum[rs[v]]; int o=++idx; ls[o]=merge(ls[u],ls[v]); rs[o]=merge(rs[u],rs[v]); sum[o]=sum[ls[o]]+sum[rs[o]]; return o;&#125;void calc(int o)&#123; if (!o) return; calc(ch[o][0]),calc(ch[o][1]); if (!w[o]) &#123; f=g=0; rt[o]=merge(rt[ch[o][0]],rt[ch[o][1]]); ans+=min(f,g); &#125;&#125;int main()&#123; scanf("%d",&amp;n); dfs(st); for(int i=1;i&lt;=cnt;i++) if (w[i]) build(rt[i],1,n,w[i]); calc(st); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]皇帝的烦恼]]></title>
    <url>%2F2018%2F06%2F13%2FZJOI2006-%E7%9A%87%E5%B8%9D%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[二分+dpdp不是很好想f记录与第一个位置相同个数的最大值g记录与第一个位置相同个数的最小值12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=20050;int n,maxs,sum=0,w[N],f[N],g[N];//f&gt;&gt;max g&gt;&gt;minbool check(int k)&#123; f[1]=g[1]=w[1]; for(int i=2;i&lt;=n;i++) &#123; f[i]=min(w[1]-g[i-1],w[i]); g[i]=max(0,w[i]-(k-w[i-1]-w[1]+f[i-1])); &#125; return !g[n];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]),sum+=w[i]; maxs=w[1]+w[n]; for(int i=1;i&lt;n;i++) maxs=max(maxs,w[i]+w[i+1]); if (!(n&amp;1)) &#123;printf("%d",maxs);return 0;&#125; int L=maxs,R=sum; while (L&lt;R) &#123; int mid=(L+R)&gt;&gt;1; if (check(mid)) R=mid; else L=mid+1; &#125; printf("%d",L); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay模板]]></title>
    <url>%2F2018%2F06%2F11%2FSplay%2F</url>
    <content type="text"><![CDATA[优化了一下之前Splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;const int INF=1&lt;&lt;30,N=100050;int rt=0,cnt=0,n;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;struct node &#123;int ch[2],fa,rec,val,sz;&#125;t[N];namespace Splay&#123; void calc(int o) &#123;t[o].sz=t[t[o].ch[0]].sz+t[t[o].ch[1]].sz+t[o].rec;&#125; void rotate(int x) &#123; int y=t[x].fa,z=t[y].fa,k=t[y].ch[1]==x; t[z].ch[t[z].ch[1]==y]=x,t[x].fa=z; t[y].ch[k]=t[x].ch[k^1],t[t[x].ch[k^1]].fa=y; t[x].ch[k^1]=y,t[y].fa=x; calc(y),calc(x); &#125; void splay(int x,int to) &#123; while (t[x].fa!=to) &#123; int y=t[x].fa,z=t[y].fa; if (z!=to) (t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; if (!to) rt=x; &#125; void ins(int &amp;o,int fa,int x) &#123; if (!o) &#123; o=++cnt; t[o].val=x,t[o].fa=fa; t[o].sz=t[o].rec=1; splay(o,0); return; &#125; t[o].sz++; if (x==t[o].val) &#123;t[o].rec++;return;&#125; ins(t[o].ch[x&gt;t[o].val],o,x); &#125; void find(int x) &#123; int o=rt; while (t[o].ch[x&gt;t[o].val]&amp;&amp;x!=t[o].val) o=t[o].ch[x&gt;t[o].val]; splay(o,0); &#125; int next(int x,int opt) &#123; find(x); if ((t[rt].val&gt;x&amp;&amp;opt)||(t[rt].val&lt;x&amp;&amp;!opt)) return rt; int o=t[rt].ch[opt]; while (t[o].ch[opt^1]) o=t[o].ch[opt^1]; return o; &#125; void del(int x) &#123; int pre=next(x,0),nxt=next(x,1); splay(pre,0),splay(nxt,pre); int o=t[nxt].ch[0]; if (t[o].rec&gt;1) &#123; t[o].rec--; splay(o,0); &#125; else t[nxt].ch[0]=0; &#125; int K_th(int o,int k) &#123; if (!o) return 0; if (k&lt;=t[t[o].ch[0]].sz) return K_th(t[o].ch[0],k); else if (k&gt;t[t[o].ch[0]].sz+t[o].rec) return K_th(t[o].ch[1],k-t[t[o].ch[0]].sz-t[o].rec); splay(o,0); return t[o].val; &#125;&#125;;using namespace Splay;int main()&#123; n=read(); ins(rt,0,INF),ins(rt,0,-INF); for(int i=1;i&lt;=n;i++) &#123; int opt=read(),x=read(); if (opt==1) ins(rt,0,x); if (opt==2) del(x); if (opt==3) find(x),printf("%d\n",t[t[rt].ch[0]].sz); if (opt==4) printf("%d\n",K_th(rt,x+1)); if (opt==5) printf("%d\n",t[next(x,0)].val); if (opt==6) printf("%d\n",t[next(x,1)].val); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
