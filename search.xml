<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CodeChef Blocked websites]]></title>
    <url>%2F2018%2F08%2F14%2FCodeChef-Blocked-websites%2F</url>
    <content type="text"><![CDATA[题目大意：现有一种过滤器，可以屏蔽以该过滤器为前缀的网站给出一些需要被屏蔽和不能被屏蔽的网站无法满足条件输出$-1$在满足条件的情况下，最小化过滤器的串长之和按字典序输出所有过滤器 以所有不能被屏蔽网站的名字建立一棵$Trie$考虑插入每个需要被屏蔽网站的名字的过程 若经过的所有节点均是不能被屏蔽的，则无解 否则，将开头到第一个未在$Trie$中出现的字符作为一个过滤器，标记该过滤器并退出插入过程 若发现当前名字以一个过滤器为前缀，则不需要新增过滤器，可直接退出插入过程 该贪心的正确性显然1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int N=2e5+50,rt=0;int n,cnt=0,ch[N][26],col[N],idx=0;char str[N];string s[N];vector&lt;string&gt; ans;inline char get()&#123; register char ch=getchar(); while (ch!='+'&amp;&amp;ch!='-') ch=getchar(); return ch;&#125;void insert(string s)&#123; int o=rt; for(int i=0;i&lt;s.size();i++) &#123; if (!ch[o][s[i]-'a']) ch[o][s[i]-'a']=++cnt; o=ch[o][s[i]-'a']; col[o]=1; &#125;&#125;void find(string s)&#123; int o=rt; string w=""; for(int i=0;i&lt;s.size();i++) &#123; if (!ch[o][s[i]-'a']) &#123; w.append(1,s[i]); ch[o][s[i]-'a']=++cnt; ans.push_back(w); return; &#125; w.append(1,s[i]); o=ch[o][s[i]-'a']; if (!col[o]) return; &#125; puts("-1"),exit(0);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; char opt=get(); scanf("%s",str); if (opt=='+') insert(str); else s[++idx]=str; &#125; for(int i=1;i&lt;=idx;i++) find(s[i]); sort(ans.begin(),ans.end()); printf("%d\n",ans.size()); for(int i=0;i&lt;ans.size();i++) printf("%s\n",ans[i].c_str()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeChef Sereja and Commands]]></title>
    <url>%2F2018%2F08%2F14%2FCodeChef-Sereja-and-Commands%2F</url>
    <content type="text"><![CDATA[题目大意：给出一个n 个元素的序列，初始值均为0有两种操作 将$\left [ l,r \right ]$的元素+1 执行$\left [ l,r \right ]$的所有操作，保证$r$小于当前操作编号 问执行完所有操作后序列中每个元素的值 直接按照操作给出顺序执行会产生递归，无法有效处理考虑倒着执行操作，这样就没有递归问题了用一个支持单点查询，区间修改的数据结构维护每个操作执行次数就好了由于只在操作完询问一次序列中的值因此序列中的操作用差分即可 本来换行写的是$puts$，不知道为什么$RE$掉了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=1e5+50,mod=1e9+7;struct node&#123;int opt,l,r;&#125;q[N];int T,n,m,ql,qr;LL c[N&lt;&lt;2],t[N&lt;&lt;2],w[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int o,int l,int r,LL x)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123; c[o]=(c[o]+x*(r-l+1))%mod; t[o]=(t[o]+x)%mod; return; &#125; int mid=(l+r)&gt;&gt;1; if (ql&lt;=mid) add(o&lt;&lt;1,l,mid,x); if (qr&gt;mid) add(o&lt;&lt;1|1,mid+1,r,x); c[o]=(c[o]+(min(r,qr)-max(l,ql)+1)*x)%mod;&#125;LL ask(int o,int l,int r)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return c[o]; int mid=(l+r)&gt;&gt;1;LL ret=0; if (ql&lt;=mid) ret=(ret+ask(o&lt;&lt;1,l,mid))%mod; if (qr&gt;mid) ret=(ret+ask(o&lt;&lt;1|1,mid+1,r))%mod; return (ret+(min(r,qr)-max(l,ql)+1)*t[o])%mod;&#125;int main()&#123; int T=read(); while (T--) &#123; n=read(),m=read(); memset(c,0,sizeof(c)); memset(t,0,sizeof(t)); memset(w,0,sizeof(w)); for(int i=1;i&lt;=m;i++) &#123; q[i].opt=read(); q[i].l=read(); q[i].r=read(); &#125; for(int i=m;i&gt;0;i--) &#123; ql=qr=i; LL x=(ask(1,1,m)+1)%mod; if (q[i].opt==1) &#123; w[q[i].l]=(w[q[i].l]+x)%mod; w[q[i].r+1]=(w[q[i].r+1]-x)%mod; &#125; else &#123; ql=q[i].l,qr=q[i].r; add(1,1,m,x); &#125; &#125; for(int i=1;i&lt;=n;i++) w[i]=(w[i]+w[i-1])%mod; for(int i=1;i&lt;=n;i++) printf("%lld ",(w[i]+mod)%mod); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]数颜色]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[带修改的莫队复杂度$O\left ( \sqrt[3]{n^{4}t} \right )$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N=1000050;struct query&#123; int ql,qr,t,id;&#125; q[N];struct update&#123; int pos,val;&#125; c[N];int cnt[N],w[N],ans[N],sum=0,num,n,m;int cntq,cntc;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (!(('a'&lt;=ch&amp;&amp;ch&lt;='z')||('A'&lt;=ch&amp;&amp;ch&lt;='Z'))) ch=getchar(); return ch;&#125;void add(int k)&#123; if(++cnt[w[k]]==1) sum++;&#125;void del(int k)&#123; if(--cnt[w[k]]==0) sum--;&#125;void work(int o,int k)&#123; if(c[o].pos&gt;=q[k].ql&amp;&amp;c[o].pos&lt;=q[k].qr) &#123; if (--cnt[w[c[o].pos]]==0) sum--; if (++cnt[c[o].val]==1) sum++; &#125; swap(c[o].val,w[c[o].pos]);&#125;bool cmp(query a,query b)&#123; if (a.ql/num!=b.ql/num) return a.ql/num&lt;b.ql/num; if (a.qr/num!=b.qr/num) return a.qr/num&lt;b.qr/num; return a.t&lt;b.t; &#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;=m;i++) &#123; char opt=get(); if (opt=='Q') &#123; q[++cntq].t=cntc; q[cntq].ql=read(); q[cntq].qr=read(); q[cntq].id=cntq; &#125; else &#123; c[++cntc].pos=read(); c[cntc].val=read(); &#125; &#125; num=ceil(exp((log(n)+log(cntq))/3));; sort(q+1,q+cntq+1,cmp); int L=0,R=0,now=0; for(int i=1;i&lt;=m;i++) &#123; int ql=q[i].ql,qr=q[i].qr; while (L&lt;ql) del(L++); while (R&gt;qr) del(R--); while (L&gt;ql) add(--L); while (R&lt;qr) add(++R); while (now&lt;q[i].t) work(++now,i); while (now&gt;q[i].t) work(now--,i); ans[q[i].id]=sum; &#125; for(int i=1;i&lt;=cntq;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2004]树的计数]]></title>
    <url>%2F2018%2F08%2F14%2FHNOI2004-%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这题是一道结论题 首先引入$Prufer$序列定义$Prufer$序列是一种无根树的编码表示，对于一棵$n$个节点带编号的无根树，对应唯一长度为$n-2$的$Prufer$编码。 转化过程 树转$Prufer$序列 每次找到最小的叶子节点并删除，然后在序列中添加其相邻节点的编号，直至剩下两个节点如下图其$Prufer$序列为$3,5,1,3$转化过程用优先队列维护可以做到$O\left ( NlogN \right )$ $Prufer$序列转树 设点集$V=\left \{x\mid x\notin Prufer \right \}$每次取出$Prufer$序列的$front$，将其与$V$中最小元素连边，并删除这两个元素若$front$在之后序列中没有出现，则将其加入$V$遍历完整个序列后，将$V$中剩下的两个元素连边同样可以用优先队列做到$O\left ( NlogN \right )$ 性质与结论 观察上述过程，不难得出$Prufer$序列与树一一对应因此可以快速得出一张$n$个点的完全图有$n^{n-2}$棵生成树，即Cayley公式 另外，不难发现$Prufer$序列中$x$的出现次数等于$d_{x}-1$，其中$d_{x}$为$x$的度数因此当$n$个点的度数分别为$d_{1},d_{2}\dots d_{n}$时，共有$\frac{\left(n-2\right)!}{\prod \left ( d_{i}-1 \right )!}$种生成树 更一般的，当其中$x$个点度数已知，$y$个点度数未知时记 sum=\sum_{i=1}^{x}\left ( d_{i} -1\right )首先考虑$x$个已知节点的方案不难得出 C_{n-2}^{sum}*\frac{sum!}{\prod_{i=1}^{x}\left ( d_{i}-1 \right )!}然后是$y​$个未知节点考虑到每个未填位置均有$y$种可能，共有y^{n-2-sum}种方案根据乘法原理，总方案数为 C_{n-2}^{sum}*\frac{sum!}{\prod_{i=1}^{x}\left ( d_{i}-1 \right )!}*y^{n-2-sum} 代码就不放了]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeChef Flooring]]></title>
    <url>%2F2018%2F08%2F13%2FCodeChef-Flooring%2F</url>
    <content type="text"><![CDATA[题目大意：求 \left ( \sum_{i=1}^{n}i^{4}\left \lfloor \frac{n}{i} \right \rfloor \right )\% M套路是很常见的分块求解难点主要是i^{4}求和，$M$不一定为质数 首先有如下几个恒等式 \sum_{i=1}^{n}i^{2}=\frac{n\left ( n+1 \right )\left ( 2n+1 \right )}{6} \sum_{i=1}^{n}i^{3}=\left ( \frac{n\left ( n+1 \right )}{2} \right )^{2} \sum_{i=1}^{n}i^{4}=\frac{n\left ( n+1 \right )\left ( 2n+1 \right )\left ( 3n^{2} +3n-1\right )}{30}其中平方和公式推导如下$\left ( n+1 \right )^{3}-n^{3}=3n^{2}+3n+1$$n^{3}-\left ( n-1 \right )^{3}=3\left ( n-1 \right )^{2}+3\left ( n-1 \right )+1$$\cdots$累加得 \left ( n+1 \right )^{3}-1^{3}=3*\sum_{i=1}^{n}i^{2}+3*\sum_{i=1}^{n}+n化简可得 \sum_{i=1}^{n}i^{2}=\frac{n\left ( n+1 \right )\left ( 2n+1 \right )}{6}立方和，四次方和同理可得 然后是$M$不为质数的问题有如下公式 \frac{a}{b}\%c=\frac{a\%\left (bc \right )}{b}然而我以前一直都不知道1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;LL n,mod;LL sqr(LL x)&#123;return x*x%mod;&#125;LL gcd(LL a,LL b)&#123;return b?gcd(b,a%b):a;&#125;LL calc(LL k)&#123; k%=mod*30; LL ret=k*(k+1)%(mod*30); ret=ret*(2LL*k+1)%(mod*30); ret=ret*(3LL*k*k%(mod*30)+3LL*k%(mod*30)-1); return ret%(mod*30)/30;&#125;int main()&#123; LL T; scanf("%lld",&amp;T); while (T--) &#123; scanf("%lld%lld",&amp;n,&amp;mod); LL sz=sqrt(n),ans=0; for(LL i=1;n/i&gt;sz;i++) ans=(ans+sqr(sqr(i))*(n/i)%mod)%mod; for(LL i=sz;i&gt;0;i--) &#123; LL L=n/(i+1)+1,R=n/i; LL val=(calc(R)-calc(L-1)+mod)%mod; ans=(ans+val*i%mod)%mod; &#125; printf("%lld\n",(ans%mod+mod)%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4822 Tri-war]]></title>
    <url>%2F2018%2F08%2F13%2FHDU4822-Tri-war%2F</url>
    <content type="text"><![CDATA[三色** 首先考虑两种颜色，分别在u，v由于路径唯一，两种颜色还是比较好求的只要取$\left ( u,v \right )$路径中点，将树分为两半即可，每个点分别控制一半如图 现在有三种颜色，也就是求交集求交集可以用线段树，先把树转化为dfs 序，然后第一次区间加，第二次区间询问 不知道为什么写挂了，于是写了个分类讨论记录一个二元组$\left ( opt,x \right )$，$x$为子树根节点，$opt=1$表示可选，0 则表示不可选观察到两棵子树之间只有两种关系，要么不相交，要么一棵树是另一棵树的子树判断是否相交用$LCA$即可然后分类讨论，设两棵子树分别以$A$，$B$为根，且$A_{sz}\leq B_{sz}$ 均可选，若两棵子树不相交则为0 ，否则为$A_{sz}$ 均不可选，若两棵子树不相交则为$n-A_{sz}-B_{sz}$，否则为$B_{sz}$ 一个可选，一个不可选 设$A_{opt}=1$，$B_{opt}=0$，这里对$sz$没有要求 $LCA\left ( A,B \right )=A$，答案为$A_{sz}-B_{sz}$ $LCA\left ( A,B \right )=B$，答案为0 ，但事实上并不会出现这种情况 否则为$A_{sz}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e5+50,rt=1;struct node&#123;int opt,x;&#125;;int fa[N][25],log[N],sz[N],dep[N],n,m;vector&lt;int&gt; e[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void dfs(int o)&#123; sz[o]=1; for(int i=1;i&lt;=log[dep[o]];i++) fa[o][i]=fa[fa[o][i-1]][i-1]; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dep[to]) &#123; dep[to]=dep[o]+1; fa[to][0]=o; dfs(to); sz[o]+=sz[to]; &#125; &#125;&#125;int update(int x,int k)&#123; for(int i=0;i&lt;=log[k];i++) if ((k&gt;&gt;i)&amp;1) x=fa[x][i]; return x;&#125;int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); u=update(u,dep[u]-dep[v]); if (u==v) return u; for(int i=log[dep[u]];i&gt;=0;i--) if (fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];&#125;node find(int u,int v,int pre)&#123; int len=dep[u]+dep[v]-dep[pre]*2; if (dep[u]&gt;=dep[v]) return (node)&#123;1,update(u,(len-1)/2)&#125;; else return (node)&#123;0,update(v,len/2)&#125;;&#125;int calc(int x,int u,int v)&#123; node A=find(x,u,LCA(x,u)); node B=find(x,v,LCA(x,v)); if (A.opt&amp;&amp;B.opt) &#123; if (dep[A.x]&lt;dep[B.x]) swap(A,B); if (LCA(A.x,B.x)!=B.x) return 0; return sz[A.x]; &#125; else if (!A.opt&amp;&amp;!B.opt) &#123; if (dep[A.x]&lt;dep[B.x]) swap(A,B); if (LCA(A.x,B.x)!=B.x) return n-sz[A.x]-sz[B.x]; else return n-sz[B.x]; &#125; else &#123; if (!A.opt) swap(A,B); int pre=LCA(A.x,B.x); if (pre==A.x) return sz[A.x]-sz[B.x]; return sz[A.x]; &#125;&#125;int main()&#123; int T=read(); for(int i=1;i&lt;N;i++) log[i]=log[i-1]+(1&lt;&lt;log[i-1]==i); while (T--) &#123; n=read(); for(int i=1;i&lt;=n;i++) e[i].clear(); memset(dep,0,sizeof(dep)); memset(fa,0,sizeof(fa)); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; dep[rt]=1,dfs(rt); m=read(); for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(),c=read(); printf("%d ",calc(a,b,c)); printf("%d ",calc(b,a,c)); printf("%d\n",calc(c,a,b)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ3649 Social Net]]></title>
    <url>%2F2018%2F08%2F13%2FZOJ3649-Social-Net%2F</url>
    <content type="text"><![CDATA[乍一看以为裸的树剖后来发现事情没那么简单，$c_{k}-c_{j}$是有顺序的，$j\leq k$ 第一问很简单第二问维护一大堆倍增数组 首先$fa$不用说，然后是$mx$，$mn$记录往上走的最大（最小）值还需要$f$记录上面节点-下面节点的最大值，$g$记录下面节点-上面节点的最大值 预处理 mx\left [ x \right ]\left [ i \right ]=max\left ( mx\left [ x \right ]\left [ i-1 \right ] ,mx\left [fa\left [ x\right ] \left [ i-1 \right ]\right ]\left [ i-1 \right ]\right ) mn\left [ x \right ]\left [ i \right ]=min\left ( mn\left [ x \right ]\left [ i-1 \right ] ,mn\left [fa\left [ x\right ] \left [ i-1 \right ]\right ]\left [ i-1 \right ]\right ) f\left [ x \right ]\left [ i \right ]=max\left ( f\left [ x \right ]\left [ i-1 \right ] ,f\left [fa\left [ x\right ] \left [ i-1 \right ]\right ]\left [ i-1 \right ],mx\left [ fa\left [ x\right ] \left [ i-1 \right ] \right ]\left [ i-1 \right ]-mn\left [ x \right ]\left [ i-1 \right ]\right ) g\left [ x \right ]\left [ i \right ]=max\left ( g\left [ x \right ]\left [ i-1 \right ] ,g\left [fa\left [ x\right ] \left [ i-1 \right ]\right ]\left [ i-1 \right ],mx\left [ x \right ]\left [ i-1 \right ]-mn\left [ fa\left [ x\right ] \left [ i-1 \right ] \right ]\left [ i-1 \right ]\right )有了这些倍增数组之后就好求解了记$LCA\left ( u,v \right )$为$pre$，将$\left ( u,v \right )$拆为$\left ( u,pre \right )$，$\left ( pre,v \right )$两条链首先$max\left ( pre,v \right )-min\left ( u,pre\right )$肯定合法 然后考虑怎么求$\left ( u,pre \right )$的答案设在倍增时已跳到$x$，用一个$num$记录\left ( u,x \right )的最小值则下一次跳跃时 ans=max\left \{ f\left [ x \right ] \left [ i \right ],mx\left [ x \right ]\left [ i \right ]-num\right \}之后更新$num$ num=min\left \{ mn\left [ x \right ]\left [ i \right ] \right \}同理可求$\left ( pre,v \right )$的答案，用$num$记录最大值即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=50050,rt=1,INF=1&lt;&lt;30;struct edge&#123;int u,v,val;&#125;t[N];int n,m,w[N],f[N],sum;int fa[N][25],dep[N],log[N];int mx[N][25],mn[N][25],dp[2][N][25]; //max&#123;pre-son&#125; max&#123;son-pre&#125;vector&lt;int&gt; e[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;bool cmp(edge a,edge b)&#123;return a.val&gt;b.val;&#125;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;void unite(int u,int v)&#123;f[find(u)]=find(v);&#125;void dfs(int o)&#123; for(int i=1;i&lt;log[dep[o]];i++) &#123; fa[o][i]=fa[fa[o][i-1]][i-1]; mx[o][i]=max(mx[o][i-1],mx[fa[o][i-1]][i-1]); mn[o][i]=min(mn[o][i-1],mn[fa[o][i-1]][i-1]); dp[0][o][i]=max(dp[0][o][i-1],mx[fa[o][i-1]][i-1]-mn[o][i-1]); dp[0][o][i]=max(dp[0][o][i],dp[0][fa[o][i-1]][i-1]); dp[1][o][i]=max(dp[1][o][i-1],mx[o][i-1]-mn[fa[o][i-1]][i-1]); dp[1][o][i]=max(dp[1][o][i],dp[1][fa[o][i-1]][i-1]); &#125; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dep[to]) &#123; dep[to]=dep[o]+1; fa[to][0]=o; mx[to][0]=max(w[o],w[to]); mn[to][0]=min(w[o],w[to]); dp[0][to][0]=w[o]-w[to]; dp[1][to][0]=w[to]-w[o]; dfs(to); &#125; &#125;&#125;int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for(int i=0;i&lt;=log[dep[u]-dep[v]];i++) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) u=fa[u][i]; if (u==v) return u; for(int i=log[dep[u]];i&gt;=0;i--) if (fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];&#125;int MAX(int u,int v)&#123; int ret=0; if (dep[u]&lt;dep[v]) swap(u,v); for(int i=0;i&lt;=log[dep[u]-dep[v]];i++) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) ret=max(ret,mx[u][i]),u=fa[u][i]; return ret;&#125;int MIN(int u,int v)&#123; int ret=INF; if (dep[u]&lt;dep[v]) swap(u,v); for(int i=0;i&lt;=log[dep[u]-dep[v]];i++) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) ret=min(ret,mn[u][i]),u=fa[u][i]; return ret;&#125;int pre(int u,int v)&#123; int ret=0,num=INF; for(int i=log[dep[u]];i&gt;=0;i--) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) &#123; ret=max(ret,dp[0][u][i]); ret=max(ret,mx[u][i]-num); num=min(num,mn[u][i]); u=fa[u][i]; &#125; return ret;&#125;int nxt(int u,int v)&#123; int ret=0,num=0; for(int i=log[dep[u]];i&gt;=0;i--) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) &#123; ret=max(ret,dp[1][u][i]); ret=max(ret,num-mn[u][i]); num=max(num,mx[u][i]); u=fa[u][i]; &#125; return ret;&#125;int calc(int u,int v)&#123; int top=LCA(u,v); int ret=MAX(v,top)-MIN(u,top); ret=max(ret,pre(u,top)); ret=max(ret,nxt(v,top)); return ret;&#125;int main()&#123; for(int i=1;i&lt;N;i++) log[i]=log[i-1]+(1&lt;&lt;log[i-1]==i); while (~scanf("%d",&amp;n)) &#123; for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) e[i].clear(); m=read(),sum=0; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); t[i]=(edge)&#123;u,v,read()&#125;; &#125; sort(t+1,t+m+1,cmp); for(int i=1;i&lt;=m;i++) &#123; int u=t[i].u,v=t[i].v; if (find(u)!=find(v)) &#123; sum+=t[i].val; e[u].push_back(v); e[v].push_back(u); unite(u,v); &#125; &#125; printf("%d\n",sum); memset(dep,0,sizeof(dep)); memset(fa,0,sizeof(fa)); memset(mx,0,sizeof(mx)); memset(mn,63,sizeof(mn)); memset(dp,0,sizeof(dp)); dep[rt]=1,dfs(rt); int T=read(); while (T--) &#123; int u=read(),v=read(); printf("%d\n",calc(u,v)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4582 DFS spanning tree]]></title>
    <url>%2F2018%2F08%2F13%2FHDU4582-DFS-spanning-tree%2F</url>
    <content type="text"><![CDATA[如果问题是在一个区间上的，那就成了一个经典的贪心问题将所有区间按照右端点升序排序之后，每个未满足的区间尽可能向右染即可 在树上也可以贪心将所有链按父节点深度降序排序之后，每条未满足的链尽可能往高处染 因为是按照父节点深度降序，如下图，在处理红链时不可能出现未处理的蓝链 对于每条未满足的链，显然染的越高能覆盖的就越多 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=20050,rt=1;struct edge&#123;int u,v;&#125;t[N];int n,m,dep[N],fa[N],used[N];vector&lt;int&gt; e[N];void dfs(int o)&#123; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dep[to]) &#123; dep[to]=dep[o]+1; fa[to]=o; dfs(to); &#125; &#125;&#125;bool cmp(edge a,edge b)&#123; if (dep[a.u]==dep[b.u]) return dep[a.v]&gt;dep[b.v]; return dep[a.u]&gt;dep[b.u];&#125;int check(int k)&#123; int x=t[k].v; for(;fa[x]!=t[k].u;x=fa[x]) if (used[x]) return 0; if (used[x]) return 0; return used[x]=1; &#125;int main()&#123; while (~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; for(int i=1;i&lt;=n;i++) e[i].clear(); memset(dep,0,sizeof(dep)); memset(used,0,sizeof(used)); memset(fa,0,sizeof(fa)); for(int i=1;i&lt;n;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); e[u].push_back(v); e[v].push_back(u); &#125; dep[rt]=1,dfs(rt); for(int i=n;i&lt;=m;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if (dep[u]&gt;dep[v]) swap(u,v); t[i-n+1].u=u; t[i-n+1].v=v; &#125; sort(t+1,t+m-n+2,cmp); int ans=0; for(int i=n;i&lt;=m;i++) if (check(i-n+1)) ans++; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-813C The Tag Game]]></title>
    <url>%2F2018%2F08%2F13%2FCodeForces-813C%2F</url>
    <content type="text"><![CDATA[题目大意：给出一棵以1 为根的树Alice在1，Bob在x两人轮流操作，Bob先走当两人相遇时游戏结束Bob希望相遇越晚越好，Alice希望相遇越早越好问游戏最多能进行几轮 观察到Bob一定在Alice的子树内因此Alice不停向Bob移动即可 Bob则有两种选择 在当前点往深度最深的点走 先往上走几步，再往深度最深的点走 考虑枚举终点y，记pre 为$LCA\left ( x,y \right )$当且仅当$dep\left [ pre \right ]-dep\left [ rt \right ]&gt;dep\left [ x \right ]-dep\left [ pre \right ]$，Bob可以走到y且终点在y 时，最多能进行$2*\left ( dep\left [ y \right ]-dep\left [ rt \right ] \right )$轮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=200050,rt=1;int log[N],fa[N][25],dep[N],n,x,ans;vector&lt;int&gt; e[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void dfs(int o)&#123; for(int i=1;i&lt;=log[dep[o]];i++) fa[o][i]=fa[fa[o][i-1]][i-1]; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dep[to]) &#123; dep[to]=dep[o]+1; fa[to][0]=o; dfs(to); &#125; &#125;&#125;int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for(int i=0;i&lt;=log[dep[u]-dep[v]];i++) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) u=fa[u][i]; if (u==v) return u; for(int i=log[dep[u]];i&gt;=0;i--) if (fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];&#125;int main()&#123; n=read(),x=read(); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; for(int i=1;i&lt;=n;i++) log[i]=log[i-1]+(1&lt;&lt;log[i-1]==i); dep[rt]=1,dfs(rt); for(int i=1;i&lt;=n;i++) &#123; int pre=LCA(i,x); if (dep[pre]-dep[rt]&gt;dep[x]-dep[pre]) ans=max(ans,dep[i]-dep[rt]); &#125; printf("%d\n",ans*2); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-294E Shaass the Great]]></title>
    <url>%2F2018%2F08%2F12%2FCodeForces-294E%2F</url>
    <content type="text"><![CDATA[题目大意：给出一棵n 个节点树去掉其中一条边，再重新加入一条长度相同的边问新树中任意两点之间距离的总和最小是多少 原树去掉一条边之后变为两棵树，分别记为A，B，它们的节点个数分别为$A_{sz}$，$B_{sz}$设去掉边长度为d，新连接的两点分别为u，v记A 中所有点到u 距离之和为$S_{u}$，同理$S_{v}$记A 中任意两点的距离之和为$C_{A}$，同理$C_{B}$ 新树中任意两点的距离和分两部分考虑 在A，B 树内，即$C_{A}+C_{B}$ 在两棵树之间 例如$x-u-v-y$，其中x 为A 中的节点，y 为B 中的节点将这样的路径分三部分考虑 首先是$u-v$，不难发现共经过$A_{sz}*B_{sz}$次 然后是$x-u$，每个$x-u$都会经过$B_{sz}$次 同理$v-y$ 全部加起来就是 C_{A}+C_{B}+d*A_{sz}*B_{sz}+S_{u}*B_{sz}+S_{v}*A_{sz}观察到$C_{A},C_{B},d,A_{sz},B_{sz}$与$u,v$无关因此只需找$S_{u},S_{v}$最小的$u,v$ 关于$S$的计算分为两个部分，以A 树为例 第一遍dfs 求出每个节点x 的子树大小和子树中节点到x 的距离和 S_{x}+=S_{x_{son}}+val_{x-x_{son}}*sz_{x_{son}} 第二遍dfs S_{x_{son}}=S_{x}+val_{x-x_{son}}*\left (A_{sz}-sz_{x_{son}} \right )-val_{x-x_{son}}*sz_{x_{son}}​ 就是把中心点从x 移到$x_{son}$，$\left (A_{sz}-sz_{x_{son}} \right )$多经过一条边，$sz_{x_{son}}$少经过一条边 有了$S$，$C$就好计算了 C_{A}=\frac{\sum _{x \in A} S_{x}}{2}每条边$x-y$，会在x，y 各计算一次123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=5050;const LL INF=1LL&lt;&lt;60;struct edge&#123;int u,v,val;&#125;t[N];LL sz[N],c[N],ans=INF;//c[x] 所有点到x的sumLL s1,s2,r1,r2,n,size;//sum&#123;Any 2&#125; min&#123;Any c[x]&#125;vector&lt;int&gt; e[N],g[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int val)&#123; e[u].push_back(v); g[u].push_back(val);&#125;void dfs(int o,int fa)&#123; sz[o]=1,c[o]=0; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (to!=fa) &#123; dfs(to,o); sz[o]+=sz[to]; c[o]+=c[to]+sz[to]*g[o][i]; &#125; &#125;&#125;void calc(int o,int fa,LL &amp;sum,LL &amp;x)&#123; sum+=c[o],x=min(x,c[o]); for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (to!=fa) &#123; c[to]=c[o]+(size-sz[to]*2)*g[o][i]; calc(to,o,sum,x); &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); int val=read(); t[i]=(edge)&#123;u,v,val&#125;; add(u,v,val); add(v,u,val); &#125; for(int i=1;i&lt;n;i++) &#123; r1=r2=INF,s1=s2=0; int u=t[i].u,v=t[i].v; dfs(u,v),size=sz[u]; calc(u,v,s1,r1),s1/=2; dfs(v,u),size=sz[v]; calc(v,u,s2,r2),s2/=2; ans=min(ans,sz[u]*sz[v]*t[i].val+s1+s2+r1*sz[v]+r2*sz[u]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-379F New Year Tree]]></title>
    <url>%2F2018%2F08%2F12%2FCodeForces-379F%2F</url>
    <content type="text"><![CDATA[题目大意：初始时有一棵4个节点的三叉树每次操作在一个叶子节点下面加入两个节点问每次操作完树的直径 设当前树的直径为S-T每次加入节点后，树的直径至多只会改变一个端点，另一个节点仍是S 或T 证明如下 考虑加入节点x 的父节点$x_{fa}$，在x 未加入时，根据直径的求法，离$x_{fa}$最远的点一定是S 或T 再加入x 后，易得离$x_{fa}$最远的点还是S 或T，因此离x 最远的点也是S 或T 因此每次求一遍x 到S，T 的距离，若大于S-T 就更新 代码就不放了]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>直径</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-734E Anton and Tree]]></title>
    <url>%2F2018%2F08%2F12%2FCodeForces-734E%2F</url>
    <content type="text"><![CDATA[题目大意： 给出一棵黑白两色的树每次操作可以改变一个同色联通块的颜色问最少需要几次操作 首先缩个点，显然每次操作改变整个同色联通块更优然后求直径，答案为\left \lceil \frac{len}{2} \right \rceil因为在缩直径时，其它枝叶也会缩掉，这个感性理解即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=200050;int col[N],n,idx[N],d[N],st,ed,cnt=0;vector&lt;int&gt; e[N],f[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void dfs(int o)&#123; idx[o]=cnt; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!idx[to]&amp;&amp;col[o]==col[to]) dfs(to); &#125;&#125;void find(int o,int pre,int &amp;x)&#123; if (o==pre) d[o]=0; if (!x||d[o]&gt;d[x]) x=o; for(int i=0;i&lt;f[o].size();i++) &#123; int to=f[o][i]; if (to!=pre) &#123; d[to]=d[o]+1; find(to,o,x); &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) col[i]=read(); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; for(int i=1;i&lt;=n;i++) if (!idx[i]) cnt++,dfs(i); for(int u=1;u&lt;=n;u++) for(int i=0;i&lt;e[u].size();i++) &#123; int v=e[u][i]; if (idx[u]!=idx[v]) f[idx[u]].push_back(idx[v]); &#125; find(cnt,cnt,ed); find(ed,ed,st); printf("%d\n",(d[st]+1)/2); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3625 Examining the Rooms]]></title>
    <url>%2F2018%2F08%2F12%2FHDU3625-Examining-the-Rooms%2F</url>
    <content type="text"><![CDATA[若某些门之间成环，则破开环中任意一扇门可以打开环中所有门于是问题等价于n 扇门形成1-k 个环有几种方案，再除总方案数总方案显然是n!第一类斯特林数参考组合数学入门题目还限制一号门不能单独成环，需减去一号单独成环的方案数因此方案数为 \sum _{i=1}^{k}S_{n}^{i}-S_{n-1}^{i-1}代码就不放了]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2643 Rank]]></title>
    <url>%2F2018%2F08%2F12%2FHDU2643-Rank%2F</url>
    <content type="text"><![CDATA[首先将排名相同的选手放入同一个集合这样的集合个数可以为1-n集合之间相对顺序并不清楚，因此是一个全排列第二类斯特林数参考组合数学入门设S\left ( n,k \right )为n个元素放入k个非空集合的方案数不难得出总方案数为 \sum_{i=1}^{n}S\left ( n,i \right )*i!代码就不放了]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学入门]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[写在前面感觉组合数学是OI （高中数学）中比较难啃的一部分还是得写点什么来总结一下组合数C,A的有关性质这里就不赘述了，高中数学里有水平不高，只能写一点个人的理解 小球与盒子n 个球放入m 个盒子这个应该是组合数学最经典的题目了 球相同，盒不相同 不允许空盒 C_{n-1}^{m-1}经典的插板法，n 个小球有n-1 个空隙，插入m-1 块板，分成m 个集合 允许空盒 C_{n+m-1}^{m-1}增加m 个球分给每个盒子，分好后从每个盒子中取出一个 球不相同，盒相同 不允许空盒 S_{n}^{m}S 为第二类斯特林数 递推公式 S_{n}^{k}=k*S_{n-1}^{k}+S_{n-1}^{k-1}对于第n 个球它可以放入前面k 个盒子中，由于球不相同，可以产生k 种方案也可以自己放入一个新的盒子中易证其正确性 边界条件 S_{n}^{0}=0,S_{n}^{n}=1 允许空盒 \sum _{i=0}^{n}S_{n}^{i}可以有1-n个空盒 球不相同，盒不相同 允许空盒 m^{n}放入每个球时均有m 种方案 不允许空盒 S_{n}^{m}*m!盒子不同，需要考虑顺序 球相同，盒相同 不允许空盒不会生成函数，只能用DP设dp\left [ i \right ]\left [ j \right ]为前i 个球，放入j 个盒子的方案数 dp\left [ i \right ]\left [ j \right ]=dp\left [ i -1\right ]\left [ j-1 \right ]+dp\left [ i -j\right ]\left [ j \right ] 若方案中有若干个盒子只有一个球，挑出其中一个盒子继续求解，方案数为dp\left [ i -1\right ]\left [ j-1 \right ] 若方案中不存在某个盒子只有一个球，将每个盒子均取出一个球之后继续求解，方案数为dp\left [ i -j\right ]\left [ j \right ] 答案为dp\left [n \right ]\left [m \right ] 初始化dp\left [0 \right ]\left [0 \right ]=1 允许空盒 dp\left [n+m \right ]\left [m \right ]相似的套路，增加m 个球分给每个盒子，分好后从每个盒子中取出一个 第一类斯特林数补充一下第一类斯特林数 定义用n 个不同元素构成m 个圆排列的方案数 递推公式 S_{n}^{k}=\left ( n-1 \right )*S_{n-1}^{k}+S_{n-1}^{k-1}对于第n 个球它可以放入前面k 个圆排列中，共有n-1 个不同的位置，也可以自己放入一个新的盒子中 错位排列定义每个数都不在自己位置上的方案数 由于通项公式计算计算比较烦琐，且不易取模，这里仅讨论递推公式递推公式 D_{i}=\left ( i-1 \right )\left ( D_{i-1}+D_{i-2} \right )将新加入的元素与每个D_{i-1}中的每个元素交换，可生成\left ( i-1 \right )*D_{i-1}个合法排列这样少考虑了一种情况例如，元素1 在自己位置，元素2-（i-1） 均不在自己位置，这时1 与i 进行交换也可生成合法排列每个元素均有可能在自己的位置，因此共有\left ( i-1 \right )*D_{i-2}种方案我是在一节语文课上才想通的 重复排列有k 个元素，每个元素出现c_{i}次，n=\sum c_{i}易得方案数 \frac{n!}{\prod_{i=1}^{k} c_{i}!}重复组合有k 个不同的元素，每种元素选择的个数没有限制，选出n 个问题等价于选n 次，每次可以选k 种球，且不分先后等价于将n 次选择机会分给k 种球，机会相同，球不同等价于将n 个相同的球放入k 个不同的盒子，且可以为空方案数为 C_{n+k-1}^{k-1}Catlan数定义有多种，这里讲其中一种借用一下神犇wuyiqi 的图 从左下角到右上角，且不穿过对角线的方案数就是Catlan数 任何一种非法方案均与绿线有交点，例如红线将其按绿线做对称，例如红线与蓝线 可以发现 终点均为\left ( n-1,n+1 \right ) 每一种非法方案对应一种\left ( 0,0 \right )到\left ( n-1,n+1 \right )的方案 所以总方案数为 C_{2n}^{n}-C_{2n}^{n-1}=\frac{C_{2n}^{n}}{n+1}再补充两个Catlan数的递推公式 T_{n+1}=\frac{4n+2}{n+2}T_{n} T_{n+1}=\sum _{i=0}^{n}T_{i}T_{n-i}另外，在上述模型中比较容易求出一个合法前缀\left ( x,y \right )的方案数 C_{2n-x-y}^{n-x}-C_{2n-x-y}^{n-1-x}先写这一些，其它的等熟练了再补充(･ω´･ )]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-739B Alyona and a tree]]></title>
    <url>%2F2018%2F08%2F12%2FCodeForces-739B%2F</url>
    <content type="text"><![CDATA[题目大意： 给出一棵n 个节点的树，每条边有一个权值若v 在u 的子树内，且d_{u-v}\leq a_{v}，则称u 能控制v问每个点能控制多少点 因为v 在u 的子树内，所以d_{u-v}=dep_{v}-dep_{u}化简得dep_{v}-a_{v}\leq dep_{u}观察到dep_{v}-a_{v}为定值，且dep_{u}单调递增找到第一个点u，满足dep_{v}-a_{v}\leq dep_{u}，则u-v_{fa}路径上所有点均可控制点v由于只有一次询问，可用树上差分至于怎么找第一个满足的点u，可以用二分或倍增 感觉倍增实现起来会简单一点，代码用的是二分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=200050,rt=1;int n,w[N],cnt[N],fa[N];LL dep[N];vector&lt;int&gt; e[N],g[N],Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int val)&#123; e[u].push_back(v); g[u].push_back(val);&#125;int find(LL key)&#123; if (Q.empty()) return 0; if (dep[Q.back()]&lt;key) return Q.back(); int L=0,R=Q.size()-1; while (L&lt;R) &#123; int mid=(L+R)&gt;&gt;1; if (dep[Q[mid]]&lt;key) L=mid+1; else R=mid; &#125; return Q[R];&#125;void dfs(int o,int pre)&#123; if (!Q.empty()&amp;&amp;dep[o]-w[o]&lt;=dep[Q.back()]) &#123; cnt[fa[find(dep[o]-w[o])]]--; cnt[fa[o]]++; &#125; Q.push_back(o); for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (to!=pre) &#123; dep[to]=dep[o]+g[o][i]; fa[to]=o; dfs(to,o); &#125; &#125; Q.pop_back();&#125;void calc(int o)&#123; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (dep[to]&gt;dep[o]) &#123; calc(to); cnt[o]+=cnt[to]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int u=2;u&lt;=n;u++) &#123; int v=read(),val=read(); add(u,v,val); add(v,u,val); &#125; dfs(rt,0),calc(rt); for(int i=1;i&lt;=n;i++) printf("%d ",cnt[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-337D Book of Evil]]></title>
    <url>%2F2018%2F08%2F12%2FCodeForces-337D%2F</url>
    <content type="text"><![CDATA[问题大意：给出一棵n 个节点的树，每条边距离为1其中有m 个节点受到了（来自东方的）神秘力量的影响如果点x 有神秘力量来源，则距离x 小于等于d 的点均会被影响神秘力量来源只有一个，问有几个点可能有神秘力量来源 一个节点可能有神秘力量来源，当且仅当它与所有受影响点距离均小于等于d 首先考虑求子树内的最大距离设f\left [ x \right ]为点x 到子树中节点的最远距离，不难得出 f\left [ x \right ]=max\left \{ f\left [ x_{son} \right ]+1 \right \}要保证x_{son}中有被神秘力量影响的节点 设g\left [ x \right ]为x 到非子树中节点的最远距离对于非子树中的节点，有两种可能 来自兄弟节点 g\left [ x \right ]=max\left \{ f\left [ x_{brother} \right ]+2\right \} 来自父节点 g\left [ x \right ]=max\left \{ g\left [ x_{fa} \right ]+1\right \}对于来自兄弟节点的转移，暴力枚举会超时考虑用son\left [ x \right ]记录x 子节点中距离最大值仅在x=son\left [ x_{fa} \right ]遍历所有兄弟节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int N=100050;int fa[N],son[N],f[N],g[N]; // subtree/notint n,d,m,w[N],ans=0;vector&lt;int&gt; e[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void calc(int o,int pre)&#123; if (w[o]) f[o]=0; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (to!=pre) &#123; fa[to]=o; calc(to,o); if (f[to]!=-1) &#123; f[o]=max(f[to]+1,f[o]); if (!son[o]||f[to]&gt;f[son[o]]) son[o]=to; &#125; &#125; &#125;&#125;void dfs(int o,int pre)&#123; if (w[o]) g[o]=0; if (o!=pre) &#123; if (g[pre]!=-1) g[o]=max(g[o],g[pre]+1); if (o!=son[pre]) g[o]=max(g[o],f[son[pre]]+2); for(int i=0;o==son[pre]&amp;&amp;i&lt;e[pre].size();i++) &#123; int to=e[pre][i]; if (to!=o&amp;&amp;to!=fa[pre]&amp;&amp;f[to]!=-1) g[o]=max(g[o],f[to]+2); &#125; &#125; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (to!=pre) dfs(to,o); &#125;&#125;int main()&#123; n=read(),m=read(),d=read(); for(int i=1;i&lt;=m;i++) w[read()]=1; for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; memset(f,-1,sizeof(f)); memset(g,-1,sizeof(g)); calc(1,1); dfs(1,1); for(int i=1;i&lt;=n;i++) if (f[i]&lt;=d&amp;&amp;g[i]&lt;=d) ans++; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2016]天天爱跑步]]></title>
    <url>%2F2018%2F08%2F12%2FNOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[刚学OI 两个月上考场碰到这题表示一脸懵逼 每条路径\left ( u,v \right )​分成两条链，一条\left ( u,LCA \right )​，一条\left ( LCA,v \right )​ 首先考虑\left ( u,LCA \right )不难得出，当dep_{u}-dep_{x}=w_{x}会被观察到观察到dep_{x}+w_{x}为定值，用桶统计即可在点u，cnt\left [ dep_{u} \right ]+1在LCA，cnt\left [ dep_{u} \right ]-1 然后是\left ( LCA,v \right )同理可得，当t_{i}-\left ( dep_{v}-dep_{x} \right )=w_{x}会被观察到其中t_{i}为\left ( u,v \right )的结束时间t_{i}=dep_{u}+dep_{v}-2dep_{LCA}化简得dep_{u}-2dep_{LCA}=w_{x}-dep_{x}，仍然用桶统计需要注意的是可能会有负值 还有，当dep_{u}-dep_{LCA}=w_{LCA}时，LCA会重复计算，记得减掉1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=300050,rt=1;struct node&#123;int u,v,top;&#125;t[N];int n,m,w[N],cnt[N&lt;&lt;1],ans[N];int dep[N],fa[N][25],log[N];vector&lt;int&gt; e[N],S[N],T[N],top[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;void dfs(int o)&#123; for(int i=1;i&lt;=log[dep[o]];i++) fa[o][i]=fa[fa[o][i-1]][i-1]; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dep[to]) &#123; fa[to][0]=o; dep[to]=dep[o]+1; dfs(to); &#125; &#125;&#125;int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for(int i=0;i&lt;=log[dep[u]-dep[v]];i++) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) u=fa[u][i]; if (u==v) return u; for(int i=log[dep[u]];i&gt;=0;i--) if (fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];&#125;void dfs_S(int o)&#123; int pre=cnt[dep[o]+w[o]]; for(int i=0;i&lt;e[o].size();i++) if (dep[e[o][i]]&gt;dep[o]) dfs_S(e[o][i]); cnt[dep[o]]+=S[o].size(); ans[o]+=cnt[dep[o]+w[o]]-pre; for(int i=0;i&lt;top[o].size();i++) cnt[dep[t[top[o][i]].u]]--; &#125;void dfs_T(int o)&#123; int pre=cnt[w[o]-dep[o]+N]; for(int i=0;i&lt;e[o].size();i++) if (dep[e[o][i]]&gt;dep[o]) dfs_T(e[o][i]); for(int i=0;i&lt;T[o].size();i++) cnt[dep[t[T[o][i]].u]-2*dep[t[T[o][i]].top]+N]++; ans[o]+=cnt[w[o]-dep[o]+N]-pre; for(int i=0;i&lt;top[o].size();i++) cnt[dep[t[top[o][i]].u]-2*dep[t[top[o][i]].top]+N]--;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) log[i]=log[i-1]+(1&lt;&lt;log[i-1]==i); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; dep[rt]=1,dfs(rt); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;=m;i++) &#123; t[i].u=read(); t[i].v=read(); t[i].top=LCA(t[i].u,t[i].v); &#125; for(int i=1;i&lt;=m;i++) &#123; S[t[i].u].push_back(i); T[t[i].v].push_back(i); top[t[i].top].push_back(i); &#125; dfs_S(rt),dfs_T(rt); for(int i=1;i&lt;=m;i++) if (w[t[i].top]+dep[t[i].top]==dep[t[i].u]) ans[t[i].top]--; for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>桶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1891 疯狂LCM]]></title>
    <url>%2F2018%2F08%2F12%2F%E6%B4%9B%E8%B0%B7P1891-%E7%96%AF%E7%8B%82LCM%2F</url>
    <content type="text"><![CDATA[lcm 过大无法枚举，考虑枚举gcd对于一组gcd\left ( x,n \right )=k，有gcd\left ( \frac{x}{k},\frac{n}{k} \right )=1，且lcm\left(x,n\right)=\frac{xn}{k}记 f\left [ k \right ]=\sum_{i=1}^{k}i\left [ gcd\left ( i,k \right )=1 \right ]根据定义，若gcd\left ( x,n \right )=1，则gcd\left ( n-x,n \right )=1因此 f\left [ k \right ]= \frac{k*\varphi\left [ k \right ]}{2}枚举所有的k则 \sum lcm\left ( x,n \right )=k*\frac{n}{k}*f\left [ \frac{n}{k} \right ]\left ( k|n,gcd\left ( x,n \right )=k \right )复杂度O\left ( T\sqrt{N} \right ) 直到有一天我被卡了，才发现有复杂度更低的做法继续化简上式 \sum lcm\left ( x,n \right )=n*f\left [ \frac{n}{k} \right ]\left ( k|n,gcd\left ( x,n \right )=k \right )好吧没啥区别 \sum_{i=1}^{n}lcm(i,n)=\sum _{d\mid n}f\left [ d \right ]*n可以O\left ( NlogN \right )，O\left (1 \right )回答123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#define LL long longconst int N=1000050;int phi[N],prime[N],cnt=0;LL f[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;void init()&#123; for(int i=2;i&lt;N;i++) &#123; if (!phi[i]) prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt;j++) &#123; if ((LL)i*prime[j]&gt;N) break; if (i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125; for(int i=2;i&lt;N;i++) for(int j=i;j&lt;N;j+=i) f[j]+=(LL)phi[i]*i/2*j; for(int i=1;i&lt;N;i++) f[i]+=i;&#125;int main()&#123; init(); int T=read(); while (T--) printf("%lld\n",f[read()]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4626 一道水题 II]]></title>
    <url>%2F2018%2F08%2F12%2F%E6%B4%9B%E8%B0%B7P4626-%E4%B8%80%E9%81%93%E6%B0%B4%E9%A2%98-II%2F</url>
    <content type="text"><![CDATA[根据定义，不难得出 LCM\left ( 1,n \right )=\prod _{p_{i}\in \mathbb{P},p_{i}\leq n}p_{i}^{\left \lfloor log_{p_{i}}n \right \rfloor}筛一遍素数之后暴力统计即可 空间不够就压位筛 对于多次询问，观察到p_{i}> \sqrt{n}的指数均为1可以求一遍乘积前缀和，将复杂度降为O\left ( T\sqrt{N} \right ) 最重要的是，这题模数是1e8+7，不是1e9+7！1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#define LL long longusing namespace std;const int N=100000050,M=60;const int mod=100000007;struct node &#123;int sz,id;&#125;;LL used[N/M];int prime[N&gt;&gt;3];LL cnt=0,n,ans;LL pow(LL a,LL b)&#123; LL ret=1; while (b) &#123; if (b&amp;1) ret=ret*a%mod; a=a*a%mod,b&gt;&gt;=1; &#125; return ret;&#125;node F(int k) &#123;return (node)&#123;k/M,k%M?k%M:M&#125;;&#125;int main()&#123; scanf("%lld",&amp;n),ans=1; for(int i=2;i&lt;=n;i++) &#123; node x=F(i); if ((used[x.sz]&gt;&gt;x.id)&amp;1^1) prime[++cnt]=i; for(int j=1;j&lt;=cnt;j++) &#123; if ((LL)i*prime[j]&gt;n) break; node w=F(i*prime[j]); used[w.sz]|=1LL&lt;&lt;w.id; if (i%prime[j]==0) break; &#125; &#125; for(int i=cnt,k=1;i&gt;0;i--) &#123; LL x=pow(prime[i],k); while ((LL)x*prime[i]&lt;=n) k++,x*=prime[i]; ans=ans*x%mod; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO5.1]圈奶牛]]></title>
    <url>%2F2018%2F08%2F12%2FUSACO5-1-%E5%9C%88%E5%A5%B6%E7%89%9B%2F</url>
    <content type="text"><![CDATA[先上图传统的Graham 扫描法先排序，从左到右，从下到上做两边，分别做上半部分和下半部分用栈维护点，发现是凹的就退栈，但起点不能弹掉（WA了好久）三点方向可用叉积判断每一遍做完后栈中剩下的元素就是凸包的顶点12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=10050;const double eps=1e-8;struct dot&#123;double x,y;&#125;;dot w[N];int n;double ans=0;vector&lt;dot&gt; S;bool cmp(dot a,dot b) &#123;return fabs(a.x-b.x)&lt;eps?a.y&lt;a.y:a.x&lt;b.x;&#125;double sqr(double x)&#123;return x*x;&#125;double dist(dot a,dot b) &#123;return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));&#125;double cross(dot a,dot b,dot c) &#123;return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;w[i].x,&amp;w[i].y); sort(w+1,w+n+1,cmp); S.push_back(w[1]),S.push_back(w[2]); for(int i=3;i&lt;=n;i++) &#123; while (S.size()!=1&amp;&amp;cross(S[S.size()-2],S.back(),w[i])&lt;0) S.pop_back(); S.push_back(w[i]); &#125; for(int i=1;i&lt;S.size();i++) ans+=dist(S[i],S[i-1]); S.clear(); S.push_back(w[1]),S.push_back(w[2]); for(int i=3;i&lt;=n;i++) &#123; while (S.size()!=1&amp;&amp;cross(S[S.size()-2],S.back(),w[i])&gt;0) S.pop_back(); S.push_back(w[i]); &#125; for(int i=1;i&lt;S.size();i++) ans+=dist(S[i],S[i-1]); printf("%.2lf",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017]逛公园]]></title>
    <url>%2F2018%2F08%2F12%2FNOIP2017-%E9%80%9B%E5%85%AC%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[当年天真的我以为最短路图是有环的，然后翻了车 首先跑一遍S的最短路，记为d用dp\left [ x \right ][i]记录点x，距离\leq d_{x}+i的方案数转移方程如下 dp\left [ x \right ]\left [ i \right ]+=dp\left [ to \right ]\left [ i+d_{x}-d_{to}-val_{x-to} \right ]这里的x-to是反图上的边答案就是dp\left [ T \right ]\left [ K \right ]，初始化所有dp\left [ S \right ]为1 对于0 环，比较好的一种处理方式是记忆优化搜索当处理\left ( x,i \right )时，再次搜到\left ( x,i \right )，则说明图中存在0 环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N=100050,rt=1;const int INF=1&lt;&lt;30;int n,m,mod,K,d[N];int w[N&lt;&lt;2],vis[N];int dp[N][55],used[N][55];queue&lt;int&gt; Q;vector&lt;int&gt; e[N],g[N],r[N],f[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void init()&#123; memset(vis,0,sizeof(vis)); memset(dp,0,sizeof(dp)); memset(used,0,sizeof(used)); for(int i=0;i&lt;=n;i++) d[i]=INF; for(int i=1;i&lt;=n;i++) e[i].clear(); for(int i=1;i&lt;=n;i++) g[i].clear(); for(int i=1;i&lt;=n;i++) r[i].clear(); for(int i=1;i&lt;=n;i++) f[i].clear();&#125;void add(int u,int v,int val)&#123; e[u].push_back(v); g[u].push_back(val); r[v].push_back(u); f[v].push_back(val);&#125;void calc(int o)&#123; int ls=w[o&lt;&lt;1],rs=w[o&lt;&lt;1|1]; w[o]=!vis[ls]*ls+!vis[rs]*rs; if (vis[ls]+vis[rs]) return; w[o]=d[ls]&lt;d[rs]?ls:rs;&#125;void build(int o,int l,int r)&#123; if (l==r) &#123;w[o]=r;return;&#125; int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); calc(o);&#125;void modify(int o,int l,int r,int k)&#123; if (l==r) return; int mid=(l+r)&gt;&gt;1; if (k&lt;=mid) modify(o&lt;&lt;1,l,mid,k); if (k&gt;mid) modify(o&lt;&lt;1|1,mid+1,r,k); calc(o);&#125;void Dijkstra(int s)&#123; build(1,1,n); d[s]=0,modify(1,1,n,s); while (d[w[rt]]!=INF) &#123; int x=w[rt]; for(int i=0;i&lt;e[x].size();i++) &#123; int to=e[x][i],val=g[x][i]; if (d[x]+val&lt;d[to]) &#123; d[to]=d[x]+val; modify(1,1,n,to); &#125; &#125; vis[x]=1,modify(1,1,n,x); &#125;&#125;int dfs(int o,int k)&#123; if (used[o][k]) return -1; if (dp[o][k]) return dp[o][k]; if (o==1) dp[o][k]=1; used[o][k]=1; for(int i=0;i&lt;r[o].size();i++) &#123; int to=r[o][i]; int val=d[to]+f[o][i]-d[o]; if (val&lt;=k) &#123; if (dfs(to,k-val)==-1) return -1; dp[o][k]=(dp[o][k]+dp[to][k-val])%mod; &#125; &#125; used[o][k]=0; return dp[o][k];&#125;int main()&#123; int T=read(); while (T--) &#123; n=read(),m=read(); K=read(),mod=read(); init(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); add(u,v,read()); &#125; Dijkstra(1); printf("%d\n",dfs(n,K)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2662 牛场围栏]]></title>
    <url>%2F2018%2F08%2F12%2F%E6%B4%9B%E8%B0%B7P2662-%E7%89%9B%E5%9C%BA%E5%9B%B4%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[首先随便找一种长度的围栏，比如p设d\left [ r \right ]\equiv r\left ( mod \ p \right )，且为最小的不能修建的长度根据定义，d\left [ r \right ]+t*p\left ( t \in \mathbb{N} \right )均能修建，d\left [ r \right ]+t*p\left ( t < 0\right )均不能修建 求d的过程就是求最短路首先d\left [ 0 \right ]=0，其次可用d\left [ x \right ]+a_{i}更新d\left [ \left ( x+a_{i} \right ) mod \ p\right ]显然p越小，复杂度越低1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N=3050,INF=1&lt;&lt;30;int n,m,d[N],inq[N],mod,ans;vector&lt;int&gt; w;queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void SPFA()&#123; for(int i=0;i&lt;mod;i++) d[i]=INF; d[0]=0,inq[0]=1,Q.push(0); while (!Q.empty()) &#123; int x=Q.front(); Q.pop(),inq[x]=0; for(int i=0;i&lt;w.size();i++) if (d[x]+w[i]&lt;d[(x+w[i])%mod]) &#123; d[(x+w[i])%mod]=d[x]+w[i]; if (!inq[(x+w[i])%mod]) &#123; inq[(x+w[i])%mod]=1; Q.push((x+w[i])%mod); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) &#123; int x=read(); for(int k=x;k&gt;=max(1,x-m);k--) w.push_back(k); &#125; sort(w.begin(),w.end()); w.resize(unique(w.begin(),w.end())-w.begin()); if ((mod=w[0])==1) &#123; puts("-1"); return 0; &#125; SPFA(); for(int i=0;i&lt;mod;i++) if (d[i]==INF) &#123; puts("-1"); return 0; &#125; for(int i=0;i&lt;mod;i++) ans=max(ans,d[i]); printf("%d\n",ans-mod); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[割点]]></title>
    <url>%2F2018%2F08%2F12%2F%E5%89%B2%E7%82%B9%2F</url>
    <content type="text"><![CDATA[当且仅当点x，存在一个子节点dfn\left [ x \right ]\leq low\left [ x_{son}\right ]，点x是割点特别地，若x为搜索树的根，只要它有两个或以上子节点，它就是割点因为是小于等于，所以在求割点时，不必考虑父节点和重边问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=100050;int n,m,low[N],dfn[N],num=0,cut[N],cnt=0;vector&lt;int&gt; e[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;void tarjan(int o,int fa)&#123; int son=0; low[o]=dfn[o]=++num; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dfn[to]) &#123; tarjan(to,fa); low[o]=min(low[o],low[to]); if (low[to]&gt;=dfn[o]&amp;&amp;o!=fa) cut[o]=1; son++; &#125; else low[o]=min(low[o],dfn[to]); &#125; if (o==fa&amp;&amp;son&gt;=2) cut[o]=1;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; for(int i=1;i&lt;=n;i++) if (!dfn[i]) tarjan(i,i); for(int i=1;i&lt;=n;i++) if (cut[i]) cnt++; printf("%d\n",cnt); for(int i=1;i&lt;=n;i++) if (cut[i]) printf("%d ",i); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>割点</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[割边]]></title>
    <url>%2F2018%2F08%2F12%2F%E5%89%B2%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[当且仅当edge\left ( u,v \right )，存在dfn\left [ u \right ]]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>割边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2002]银河英雄传说]]></title>
    <url>%2F2018%2F08%2F11%2FNOI2002-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[在记录fa的同时记录与fa的距离d初始化d为0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const int N=30050;int fa[N],d[N],sz[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (ch!='M'&amp;&amp;ch!='C') ch=getchar(); return ch;&#125;int find(int x)&#123; if (fa[x]==x) return x; find(fa[x]); d[x]+=d[fa[x]]; return fa[x]=find(fa[x]);&#125;void unite(int u,int v) //u&gt;&gt;v&#123; u=find(u),v=find(v); fa[u]=v; d[u]=d[v]+sz[v]; sz[v]+=sz[u];&#125;int ask(int u,int v)&#123; if (find(u)!=find(v)) return -1; return abs(d[u]-d[v])-1;&#125;void init()&#123; for(int i=1;i&lt;N;i++) fa[i]=i,d[i]=0,sz[i]=1;&#125;int main()&#123; init(); int T=read(); while (T--) &#123; char opt=get(); int u=read(),v=read(); if (opt=='M') unite(u,v); if (opt=='C') printf("%d\n",ask(u,v)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2001]炮兵阵地]]></title>
    <url>%2F2018%2F08%2F11%2FNOI2001-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[先预处理出一行内所有可行方案，记为s，可以发现可行解并不多再预处理出所有可行方案的炮兵数目，记为w用dp\left [ d\right ]\left [ i\right ]\left [ j \right ]记录前d行，且上一行状态为s_{j}，上两行状态为s_{i}的最大炮兵数目 dp\left [ d \right ]\left [ j \right ]\left [ k \right ]=max\left \{ dp\left [ d-1 \right ]\left [ i \right ]\left [ j \right ]\right \}转移时需要判断状态之间是否合法，炮兵是否均在平原123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=105,M=65;int n,m,dp[N][M][M],f[N];int cnt=0,c[M],w[M],ans=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (ch!='P'&amp;&amp;ch!='H') ch=getchar(); return ch;&#125;int main()&#123; n=read(),m=read(); for(int s=0;s&lt;(1&lt;&lt;m);s++) if (!((s&gt;&gt;1)&amp;s)&amp;&amp;!((s&lt;&lt;1)&amp;s)) if (!((s&gt;&gt;2)&amp;s)&amp;&amp;!((s&lt;&lt;2)&amp;s)) c[++cnt]=s; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) f[i]+=(get()=='H')&lt;&lt;(m-j); for(int i=1;i&lt;=cnt;i++) for(int k=1;k&lt;=m;k++) w[i]+=(c[i]&gt;&gt;(k-1))&amp;1; for(int d=1;d&lt;=n;d++) for(int k=1;k&lt;=cnt;k++) if (!(f[d]&amp;c[k])) for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) if (!(c[i]&amp;c[j])) if (!(c[i]&amp;c[k])&amp;&amp;!(c[j]&amp;c[k])) dp[d][j][k]=max(dp[d][j][k],dp[d-1][i][j]+w[k]); for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) ans=max(ans,dp[n][i][j]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2013]直径]]></title>
    <url>%2F2018%2F08%2F11%2FSDOI2013-%E7%9B%B4%E5%BE%84%2F</url>
    <content type="text"><![CDATA[首先求一遍直径，记起点为S，终点为T所有可行边均在直径上（废话）考虑直径上某个点x，求出它不经过直径的能访问的最远距离，记为d_{x}复杂度显然是O\left(N\right)​的 从S到T，依次遍历直径上所有点 若d_{x}=D\left ( S,x \right )，则S到x之间所有的边均不是必须经过的 若d_{x}=D\left ( x,T \right )，则x到T之间所有的边均不是必须经过的 需要注意的是，有些算法在遇到第二种情况时需要及时退出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=200050;int n,st,ed,fa[N],col[N],ans=0;LL d[N],len;vector&lt;int&gt; e[N],g[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int val)&#123; e[u].push_back(v); g[u].push_back(val);&#125;void find(int o,int pre,int &amp;x)&#123; if (o==pre) d[o]=0,fa[o]=0; if (!x||d[o]&gt;d[x]) x=o; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (to!=pre) &#123; fa[to]=o; d[to]=d[o]+g[o][i]; find(to,o,x); &#125; &#125;&#125;LL dfs(int o)&#123; LL ret=0; col[o]=1; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!col[to]) ret=max(ret,dfs(to)+g[o][i]); &#125; return ret;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); int val=read(); add(u,v,val); add(v,u,val); &#125; find(n,n,ed); find(ed,ed,st); printf("%lld\n",len=d[st]); for(int i=st;i;i=fa[i]) col[i]=1; for(int f=0,i=st;i&amp;&amp;!f;i=fa[i]) for(int j=0;!f&amp;&amp;j&lt;e[i].size();j++) &#123; int to=e[i][j]; if (!col[to]) &#123; LL x=dfs(to)+g[i][j]; if (x==len-d[i]) st=i; if (x==d[i]) ed=i,f=1; &#125; &#125; for(int i=st;i!=ed;i=fa[i]) ans++; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展中国剩余定理]]></title>
    <url>%2F2018%2F08%2F11%2F%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[\left\{\begin{matrix} x\equiv a_{1}\left ( mod \ m_{1} \right ) \\ x\equiv a_{2}\left ( mod \ m_{2} \right )\\ \cdots \\ x\equiv a_{n}\left ( mod \ m_{n} \right )\\ \end{matrix}\right.不保证m两两互质 设已求出前k个方程的解，记为x_{k}记M_{k}=\prod _{i=1}^{k}m_{i}则x_{k}+tM_{k}\left ( k \in\mathbb{Z} \right )为前k个方程的通解 考虑第k+1个方程 x_{k}+tM_{k} \equiv a_{k+1} \left ( mod \ m_{k+1}\right )用exgcd解出t若无解则方程组无解若有解则x_{k+1}=x_{k}+tM_{k}123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#define LL long longconst int N=100050;LL n,x,y,a[N],m[N],M=1;LL mul(LL a,LL b,LL mod)&#123; LL ret=0; for(;b;b&gt;&gt;=1) &#123; if (b&amp;1) ret=(ret+a)%mod; a=(a&lt;&lt;1)%mod; &#125; return ret;&#125;void exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if (!b) &#123;x=1,y=0;return;&#125; exgcd(b,a%b,y,x); y-=a/b*x;&#125;LL gcd(LL a,LL b)&#123;return b?gcd(b,a%b):a;&#125;LL exCRT()&#123; LL M=m[1],ans=a[1]; for(int i=2;i&lt;=n;i++) &#123; LL w=gcd(M,m[i]); LL c=(a[i]-ans)%m[i]+m[i]; exgcd(M/w,m[i]/w,x,y); x=mul(x,c%m[i]/w,m[i]); ans+=x*M,M*=m[i]/w; &#125; return (ans%M+M)%M;&#125;int main()&#123; scanf("%lld",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;m[i],&amp;a[i]); printf("%lld\n",exCRT()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K短路]]></title>
    <url>%2F2018%2F08%2F11%2Fk%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[其实K短路是有有理有据的做法的，但我不会啊 建立一个以d为关键字的优先队列放入\left ( S,0 \right )，然后进行扩展易证，当\left ( x,d \right )被第K次取出时，d为S到x的K短路 考虑用启发式优化来提高效率到T的估计距离f_{x}可以为x到T的最短路对于点x，g_{x}=d_{now}+f_{x}优先队列以g为关键字 还可以继续优化 当取出其中某个点K次后，不需要将其再放入优先队列中 对于有距离要求的K短路，当取出元素的d大于给定值可直接退出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N=5050,INF=1&lt;&lt;30;struct edge&#123;int to;double val;&#125;;struct node&#123;int id;double d;&#125;;int n,m,ans=0,inq[N],cnt[N];double E,f[N];vector&lt;edge&gt; e[N],r[N];queue&lt;int&gt; Q;struct cmp&#123; bool operator()(node a,node b) &#123; return a.d+f[a.id]&gt;b.d+f[b.id]; &#125;&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; S;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;void SPFA(int s)&#123; for(int i=1;i&lt;=n;i++) f[i]=INF; f[s]=0,inq[s]=1,Q.push(s); while (!Q.empty()) &#123; int x=Q.front(); Q.pop(),inq[x]=0; for(int i=0;i&lt;r[x].size();i++) &#123; int to=r[x][i].to; double val=r[x][i].val; if (f[x]+val&lt;f[to]) &#123; f[to]=f[x]+val; if (!inq[to]) inq[to]=1,Q.push(to); &#125; &#125; &#125;&#125;void A_star(int s,int t,int sz)&#123; S.push((node)&#123;s,0&#125;); while (!S.empty()) &#123; node x=S.top(); if (cnt[x.id]&gt;sz) return; S.pop(),cnt[x.id]++; if (x.d&gt;E) return; if (x.id==t) &#123; ans++,E-=x.d; sz=E/x.d; memset(cnt,0,sizeof(cnt)); &#125; for(int i=0;i&lt;e[x.id].size();i++) &#123; int to=e[x.id][i].to; double val=e[x.id][i].val; if (x.d+val&lt;=E) S.push((node)&#123;to,x.d+val&#125;); &#125; &#125;&#125;int main()&#123; n=read(),m=read(); scanf("%lf",&amp;E); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); double val; scanf("%lf",&amp;val); e[u].push_back((edge)&#123;v,val&#125;); r[v].push_back((edge)&#123;u,val&#125;); &#125; SPFA(n); A_star(1,n,E/f[1]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1382 楼房]]></title>
    <url>%2F2018%2F08%2F11%2F%E6%B4%9B%E8%B0%B7P1382-%E6%A5%BC%E6%88%BF%2F</url>
    <content type="text"><![CDATA[线段树实现起来细节有点多，用了multiset参考了一下大佬的题解 排序时需要注意顺序问题 先左后右 先入后出 入边从高到低 出边从低到高 感性理解一下即可 加入边时考虑是否会变高删除边时考虑是否会变低123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int N=200050;struct node&#123;int x,h,opt;&#125;t[N&lt;&lt;2];struct dot&#123;int x,y;&#125;ans[N&lt;&lt;2];int n,cnt=0;multiset&lt;int&gt; S;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;bool cmp(node a,node b)&#123; if (a.x!=b.x) return a.x&lt;b.x; if (a.opt!=b.opt) return a.opt&gt;b.opt; if (a.opt==1) return a.h&gt;b.h; if (a.opt==-1) return a.h&lt;b.h;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; int h=read(),l=read(),r=read(); t[i]=(node)&#123;l,h,1&#125;; t[i+n]=(node)&#123;r,h,-1&#125;; &#125; n&lt;&lt;=1; sort(t+1,t+n+1,cmp); S.insert(0); for(int i=1;i&lt;=n;i++) &#123; int H=*S.rbegin(); if (t[i].opt==1) &#123; if (t[i].h&gt;H) &#123; ans[++cnt]=(dot)&#123;t[i].x,H&#125;; ans[++cnt]=(dot)&#123;t[i].x,t[i].h&#125;; S.insert(t[i].h); &#125; else S.insert(t[i].h); &#125; if (t[i].opt==-1) &#123; if (t[i].h==H&amp;&amp;S.count(H)==1) &#123; S.erase(H); ans[++cnt]=(dot)&#123;t[i].x,H&#125;; ans[++cnt]=(dot)&#123;t[i].x,*S.rbegin()&#125;; &#125; else S.erase(S.find(t[i].h)); &#125; &#125; printf("%d\n",cnt); for(int i=1;i&lt;=cnt;i++) printf("%d %d\n",ans[i].x,ans[i].y); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO5.5]Picture]]></title>
    <url>%2F2018%2F08%2F11%2FUSACO5-5-Picture%2F</url>
    <content type="text"><![CDATA[扫描线参考HDU1542 Atlantis可以横竖各做一遍需要注意的是会重复计算，需要与上一次结果作差 也可以只做一遍用sz数组记录宽度，c数组记录竖线数量还需要L，R记录是否有左右端点竖线需要注意的是端点竖线重合和顺序问题高度相同时先做覆盖再做取消覆盖，否则会重叠线段会多次计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=2e4+50;struct node&#123;int l,r,h,val;&#125;t[N&lt;&lt;2];int n,cnt=0,ans=0,ql,qr;int num[N&lt;&lt;2],sz[N&lt;&lt;2],w[N&lt;&lt;2];int c[N&lt;&lt;2],L[N&lt;&lt;2],R[N&lt;&lt;2];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;bool cmp(node a,node b)&#123; return a.h==b.h?a.val&gt;b.val:a.h&lt;b.h;&#125;;void calc(int o,int l,int r)&#123; if (num[o]) &#123; sz[o]=w[r+1]-w[l]; c[o]=(L[o]=1)+(R[o]=1); &#125; else &#123; L[o]=L[o&lt;&lt;1],R[o]=R[o&lt;&lt;1|1]; c[o]=c[o&lt;&lt;1]+c[o&lt;&lt;1|1]; c[o]-=(R[o&lt;&lt;1]&amp;L[o&lt;&lt;1|1])&lt;&lt;1; sz[o]=sz[o&lt;&lt;1]+sz[o&lt;&lt;1|1]; &#125;&#125;void modify(int o,int l,int r,int x)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123; num[o]+=x; calc(o,l,r); return; &#125; int mid=(l+r)&gt;&gt;1; if (ql&lt;=mid) modify(o&lt;&lt;1,l,mid,x); if (qr&gt;mid) modify(o&lt;&lt;1|1,mid+1,r,x); calc(o,l,r);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; int x1=read(),y1=read(); int x2=read(),y2=read(); w[i]=x1,w[i+n]=x2; t[++cnt]=(node)&#123;x1,x2,y1,1&#125;; t[++cnt]=(node)&#123;x1,x2,y2,-1&#125;; &#125; n&lt;&lt;=1; sort(w+1,w+n+1); int idx=unique(w+1,w+n+1)-w-1; sort(t+1,t+n+1,cmp); for(int pre=0,i=1;i&lt;=n;i++) &#123; ql=lower_bound(w+1,w+idx+1,t[i].l)-w; qr=lower_bound(w+1,w+idx+1,t[i].r)-w-1; if (ql&lt;=qr) modify(1,1,idx,t[i].val); ans+=c[1]*(t[i+1].h-t[i].h); ans+=abs(sz[1]-pre),pre=sz[1]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1255 覆盖的面积]]></title>
    <url>%2F2018%2F08%2F11%2FHDU1255-%E8%A6%86%E7%9B%96%E7%9A%84%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[扫描线参考HDU1542 Atlantis需要修改的只有calc函数用sz数组记录被覆盖到两次或以上的宽度用c数组记录被覆盖到一次的宽度 具体细节看代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=2050;struct node&#123;double l,r,h;int val;&#125;t[N&lt;&lt;2];int num[N&lt;&lt;4],ql,qr;double sz[N&lt;&lt;4],c[N&lt;&lt;4],w[N&lt;&lt;4]; //2 1inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;bool cmp(node a,node b)&#123;return a.h&lt;b.h;&#125;;void calc(int o,int l,int r)&#123; if (num[o]&gt;=2) sz[o]=w[r+1]-w[l]; if (num[o]==1) &#123; c[o]=w[r+1]-w[l]; sz[o]=c[o&lt;&lt;1]+c[o&lt;&lt;1|1]; &#125; if (!num[o]) &#123; c[o]=c[o&lt;&lt;1]+c[o&lt;&lt;1|1]; sz[o]=sz[o&lt;&lt;1]+sz[o&lt;&lt;1|1]; &#125;&#125;void modify(int o,int l,int r,int x)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123; num[o]+=x; calc(o,l,r); return; &#125; int mid=(l+r)&gt;&gt;1; if (ql&lt;=mid) modify(o&lt;&lt;1,l,mid,x); if (qr&gt;mid) modify(o&lt;&lt;1|1,mid+1,r,x); calc(o,l,r);&#125;int main()&#123; int Case=0,T=read(); while (T--) &#123; double ans=0; int cnt=0,n=read(); memset(num,0,sizeof(num)); memset(sz,0,sizeof(sz)); memset(c,0,sizeof(c)); for(int i=1;i&lt;=n;i++) &#123; double x1,y1,x2,y2; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); w[i]=x1,w[i+n]=x2; t[++cnt]=(node)&#123;x1,x2,y1,1&#125;; t[++cnt]=(node)&#123;x1,x2,y2,-1&#125;; &#125; n&lt;&lt;=1; sort(w+1,w+n+1); int idx=unique(w+1,w+n+1)-w-1; sort(t+1,t+cnt+1,cmp); for(int i=1;i&lt;n;i++) &#123; ql=lower_bound(w+1,w+idx+1,t[i].l)-w; qr=lower_bound(w+1,w+idx+1,t[i].r)-w-1; if (ql&lt;=qr) modify(1,1,idx,t[i].val); ans+=sz[1]*(t[i+1].h-t[i].h); &#125; printf("%.2lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO07OPEN]城市的地平线]]></title>
    <url>%2F2018%2F08%2F11%2FUSACO07OPEN-%E5%9F%8E%E5%B8%82%E7%9A%84%E5%9C%B0%E5%B9%B3%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[竖版的扫描线扫描线参考HDU1542 Atlantis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=80050;struct node&#123;int x,h,val;&#125;t[N];int n,cnt=0,ql,qr,w[N];LL ans=0,sz[N&lt;&lt;4],num[N&lt;&lt;4];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;void calc(int o,int l,int r)&#123; if (num[o]) sz[o]=w[r+1]-w[l]; else sz[o]=sz[o&lt;&lt;1]+sz[o&lt;&lt;1|1];&#125;void modify(int o,int l,int r,int x)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123; num[o]+=x; calc(o,l,r); return; &#125; int mid=(l+r)&gt;&gt;1; if (ql&lt;=mid) modify(o&lt;&lt;1,l,mid,x); if (qr&gt;mid) modify(o&lt;&lt;1|1,mid+1,r,x); calc(o,l,r);&#125;bool cmp(node a,node b)&#123;return a.x&lt;b.x;&#125;;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; int l=read(),r=read(),h; w[i]=h=read(); t[++cnt]=(node)&#123;l,h,1&#125;; t[++cnt]=(node)&#123;r,h,-1&#125;; &#125; w[n+1]=0; sort(w+1,w+n+2); int idx=unique(w+1,w+n+2)-w-1; n&lt;&lt;=1; sort(t+1,t+n+1,cmp); for(int i=1;i&lt;n;i++) &#123; ql=1,qr=lower_bound(w+1,w+idx+1,t[i].h)-w-1; if (ql&lt;=qr) modify(1,1,n,t[i].val); ans+=sz[1]*((LL)t[i+1].x-t[i].x); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1542 Atlantis]]></title>
    <url>%2F2018%2F08%2F11%2FHDU1542-Atlantis%2F</url>
    <content type="text"><![CDATA[扫描线入门题 借用一下某位大佬的图 先离散化横坐标每个矩形分成上下两条线，下入上出用sz数组记录当前区间被覆盖宽度具体细节看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=205;struct node&#123;double l,r,h;int val;&#125;t[N&lt;&lt;2];int num[N&lt;&lt;4],ql,qr;double sz[N&lt;&lt;4],w[N&lt;&lt;4];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;bool cmp(node a,node b)&#123;return a.h&lt;b.h;&#125;;void calc(int o,int l,int r)&#123; if (num[o]) //full sz[o]=w[r+1]-w[l]; else //not sz[o]=sz[o&lt;&lt;1]+sz[o&lt;&lt;1|1];&#125;void modify(int o,int l,int r,int x)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123; num[o]+=x; calc(o,l,r); return; &#125; int mid=(l+r)&gt;&gt;1; if (ql&lt;=mid) modify(o&lt;&lt;1,l,mid,x); if (qr&gt;mid) modify(o&lt;&lt;1|1,mid+1,r,x); calc(o,l,r);&#125;int main()&#123; int Case=0,n; while (n=read()) &#123; double ans=0; int cnt=0; memset(num,0,sizeof(num)); memset(sz,0,sizeof(sz)); for(int i=1;i&lt;=n;i++) &#123; double x1,y1,x2,y2; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); w[i]=x1,w[i+n]=x2; t[++cnt]=(node)&#123;x1,x2,y1,1&#125;; t[++cnt]=(node)&#123;x1,x2,y2,-1&#125;; &#125; n&lt;&lt;=1; sort(w+1,w+n+1); int idx=unique(w+1,w+n+1)-w-1; sort(t+1,t+cnt+1,cmp); for(int i=1;i&lt;n;i++) &#123; ql=lower_bound(w+1,w+idx+1,t[i].l)-w; qr=lower_bound(w+1,w+idx+1,t[i].r)-w-1; if (ql&lt;=qr) modify(1,1,idx,t[i].val); ans+=sz[1]*(t[i+1].h-t[i].h); &#125; printf("%.2lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4388 付公主的矩形]]></title>
    <url>%2F2018%2F08%2F11%2F%E6%B4%9B%E8%B0%B7P4388-%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[首先有一个结论对于一个\left ( r,c \right ), \ gcd\left ( r,c \right )=1的矩形，经过格子数目为r+c-1个更一般的，可由上式化简，对于\left ( r,c \right )，经过格子数目为r+c-gcd\left ( r,c \right ) 证明有多种给出一种我当时想出来的 \left ( r,c \right )中对角线只有初末位置在格点上 当对角线穿过某一网格边时，必然会在两边经过各一个格子 对角线穿过的网格边数显然为r+c-2 由于中间无格点，按照上述计算时中间每个格子会被计算到两次 初末位置的格子仅会被计算到一次 化简后可得格子数为r+c-1 暴力统计就能过了，复杂度比较玄学，大概是O\left ( c*ans \right )，c为一个不是很大常数（我猜的） 其实还有更有理有据的做法 \sum _{d\mid n}\sum \left [r+c=d+1,gcd\left ( r,c \right )=1 \right ]= \frac{\sum _{d\mid n}\varphi\left ( d+1 \right )+1}{2}每一对\left ( r,c \right )都会被算到两次，但\left ( n,n \right )只会被算到一次复杂度O\left ( N \right ) 代码为暴力统计12345678910111213141516171819202122#include&lt;cstdio&gt;const int N=1e6+50;int n,ans=0,idx=0,w[N];int gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i*i&lt;=n;i++) if (n%i==0) &#123; w[++idx]=i; if (i*i!=n) w[++idx]=n/i; &#125; for(int i=1;i&lt;=idx;i++) &#123; int sz=w[i]+1; for(int k=1;k&lt;=sz/2;k++) if (gcd(k,sz-k)==1) ans++; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2005]骑士精神]]></title>
    <url>%2F2018%2F08%2F11%2FSCOI2005-%E9%AA%91%E5%A3%AB%E7%B2%BE%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[每次移动空位而不是骑士 设当前搜到第k步，剩下num个骑士未回到位置若k+num>dep_{now}，则返回跑得飞快 其实还可以加点什么小剪枝若当前和\left ( x,y \right )交换，则下次不换回去既然直接搜能过（实现起来有点小烦），就没加这个剪枝12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int n=5,N=6;const int dx[]=&#123;1,-1,1,-1,2,-2,2,-2&#125;;const int dy[]=&#123;2,2,-2,-2,1,1,-1,-1&#125;;const int to[N][N]=&#123;&#123;'0','0','0','0','0','0'&#125;, &#123;'0','1','1','1','1','1'&#125;, &#123;'0','0','1','1','1','1'&#125;, &#123;'0','0','0','*','1','1'&#125;, &#123;'0','0','0','0','0','1'&#125;, &#123;'0','0','0','0','0','0'&#125;&#125;;int dep,w[N][N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (ch!='1'&amp;&amp;ch!='0'&amp;&amp;ch!='*') ch=getchar(); return ch;&#125;bool dfs(int k,int xx,int yy,int num)&#123; if (k+num&gt;dep) return 0; if (!num) return 1; for(int i=0;i&lt;8;i++) &#123; int x=xx+dx[i],y=yy+dy[i]; if (x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=n) &#123; int nxt=num; nxt+=w[x][y]==to[x][y]; nxt-=w[x][y]==to[xx][yy]; swap(w[x][y],w[xx][yy]); if (dfs(k+1,x,y,nxt)) return 1; swap(w[x][y],w[xx][yy]); &#125; &#125; return 0;&#125;int main()&#123; int T=read(); while (T--) &#123; int num=0,f=0,xx,yy; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; w[i][j]=get(); if (to[i][j]!=w[i][j]&amp;&amp;w[i][j]!='*') num++; if (w[i][j]=='*') xx=i,yy=j; &#125; for(dep=num;dep&lt;=15&amp;&amp;!f;dep++) if (dfs(0,xx,yy,num)) f=1,printf("%d\n",dep); if (!f) puts("-1"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>A*</tag>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI1999]生日蛋糕]]></title>
    <url>%2F2018%2F08%2F11%2FNOI1999-%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95%2F</url>
    <content type="text"><![CDATA[很综合的一道搜索题 从下往上搜记v\left [ k \right ]为1-k 层最小体积，s\left [ k \right ]为1-k 层最小面积记V为剩余体积，S为当前面积对于第k层 h_{k}\in \left [ k,min\left ( h_{k+1} -1,\frac{V-v\left [ k-1 \right ]}{k^{2}}\right ) \right ] r_{k}\in \left [ k,min\left ( r_{k+1}-1,\sqrt{\frac{\left ( V-v\left [ k-1 \right ] \right )}{h_{k}} }\right )\right ]可行性剪枝 若V>v\left [ k \right ]，则返回 最优化剪枝 若S+s\left [ k \right ]>ans，则返回 若S+\frac{2V}{r_{k+1}}>ans，则返回 对于最后一种剪枝的证明 \sum_{i=1}^{k}2r_{i}h_{i}>\frac{2}{r_{k+1}}\sum_{i=1}^{k}r_{i}^{2}h_{i}=\frac{2V}{r_{k+1}} 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=1&lt;&lt;30,N=20;int n,m,v[N],s[N],ans=INF;void dfs(int V,int k,int H,int R,int S)&#123; if (k&lt;=0) &#123; if (!V) ans=min(ans,S); return; &#125; if (V&lt;v[k]) return; if (S+s[k]&gt;ans) return; if (S+2*V/R&gt;ans) return; for(int h=min(H-1,(V-v[k-1])/(k*k));h&gt;=k;h--) for(int r=min(R-1,(int)sqrt((V-v[k-1])/h));r&gt;=k;r--) dfs(V-r*r*h,k-1,h,r,S+2*r*h+r*r*(k==m));&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; v[i]=v[i-1]+i*i*i; s[i]=s[i-1]+2*i*i; &#125; dfs(n,m,INF,INF,0); printf("%d\n",ans==INF?0:ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO08DEC]农场的万圣节]]></title>
    <url>%2F2018%2F08%2F11%2FUSACO08DEC-%E5%86%9C%E5%9C%BA%E7%9A%84%E4%B8%87%E5%9C%A3%E8%8A%82%2F</url>
    <content type="text"><![CDATA[缩完点之后，求一遍每个点到终点的路径长即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;const int N=100050;struct node&#123;int sz;&#125;t[N];int n,idx[N],cnt=0,sz[N],used[N];int dfn[N],low[N],num=0,inq[N];vector&lt;int&gt; e[N],f[N];stack&lt;int&gt; S;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void tarjan(int o)&#123; dfn[o]=low[o]=++num; inq[o]=1,S.push(o); for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dfn[to]) &#123; tarjan(to); low[o]=min(low[o],low[to]); &#125; else if (inq[to]) low[o]=min(low[o],dfn[to]); &#125; if (low[o]==dfn[o]) &#123; int x;cnt++; do&#123; x=S.top(); idx[x]=cnt; S.pop(),inq[x]=0; t[cnt].sz++; &#125;while (x!=o); &#125;&#125;void dfs(int o)&#123; if (used[o]) return; used[o]=1; sz[o]=t[o].sz; for(int i=0;i&lt;f[o].size();i++) &#123; int to=f[o][i]; dfs(to); sz[o]+=sz[to]; &#125;&#125;int main()&#123; n=read(); for(int u=1;u&lt;=n;u++) &#123; int v=read(); e[u].push_back(v); &#125; for(int i=1;i&lt;=n;i++) if (!dfn[i]) tarjan(i); for(int u=1;u&lt;=n;u++) for(int i=0;i&lt;e[u].size();i++) &#123; int v=e[u][i]; if (idx[u]!=idx[v]) f[idx[u]].push_back(idx[v]); &#125; for(int i=1;i&lt;=cnt;i++) if (!used[i]) dfs(i); for(int i=1;i&lt;=n;i++) printf("%d\n",sz[idx[i]]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO06NOV]玉米田]]></title>
    <url>%2F2018%2F08%2F11%2FUSACO06NOV-%E7%8E%89%E7%B1%B3%E7%94%B0%2F</url>
    <content type="text"><![CDATA[用一下上次的配图 不为草地直接转移若要种草则需要s_{5},s_{1}不为草地，且当前位置适合种草需要注意的是，若当前位置为行首则不需要考虑s_{1}1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;const int N=15,mod=1e8;int n,m,w[N][N],dp[2][1&lt;&lt;N],ans=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=read(); dp[0][0]=1; for(int i=1,now=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++,now^=1) &#123; int r=(1&lt;&lt;m)-1; for(int s=0;s&lt;(1&lt;&lt;m);s++) dp[now][s]=0; for(int s=0;s&lt;(1&lt;&lt;m);s++) &#123; dp[now][(s&lt;&lt;1)&amp;r]=(dp[now][(s&lt;&lt;1)&amp;r]+dp[now^1][s])%mod; if (w[i][j]&amp;&amp;(s&gt;&gt;(m-1))&amp;1^1) if (s&amp;1^1||j==1) dp[now][(s&lt;&lt;1)|1&amp;r]=(dp[now][(s&lt;&lt;1)|1&amp;r]+dp[now^1][s])%mod; &#125; &#125; for(int s=0;s&lt;(1&lt;&lt;m);s++) ans=(ans+dp[(n*m)&amp;1][s])%mod; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>轮廓线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2006]均分数据]]></title>
    <url>%2F2018%2F08%2F11%2FHAOI2006-%E5%9D%87%E5%88%86%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[如果贪心是一只兔子不断往目标跳去，那模拟退火就是一只喝醉的兔子不停乱跳 SA 算法的基本思想是用马尔可夫链的形式进行随机搜索，它不仅接受改善目标函数的变化，而且还能保留一些不理想的变化。对于改善目标函数的变化直接转移对于不理想的变化，发生转移的概率为P=e^{\frac{\Delta E}{kT_{0}}}其中T_{0}为当前温度，k为玻尔兹曼常数，为了方便计算可设k=1需要设定的参数为初温S，末温T，和降温系数dT 适当的温度至关重要 若T_{0}过大\left ( T\rightarrow \infty \right )，几乎所有转移都会被接受 若T_{0}过小\left ( T\rightarrow0 \right )，几乎所有不理想的转移均无法被接受，算法将会变为贪心，容易陷入局部最优解 此外，优秀的状态产生函数和状态评估函数将会提高SA的效率最好是能面向数据编程 放一张Wiki的动图 有了SA这题就好写了状态生产函数采用随机交换两个元素状态评估函数采用动态规划设dp\left [ i\right ]\left [ j \right ]为前i 个分成j 组的最小j\sigma ^{2} dp\left [ i\right ]\left [ j \right ]=min\left \{ dp\left [ k \right ] \left [ j-1 \right ]+\left ( \sum_{k+1}^{i}x-\bar{x} \right )^{2} \right \}调参调了很久12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int N=25,INF=1&lt;&lt;30;const double st=1e8,ed=1e-5;const double dt=0.998;double ave,ans=INF,dp[N][N],s[N];int n,m,w[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;double pow(double x)&#123;return x*x;&#125;double calc()&#123; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) dp[i][j]=INF; for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+w[i]; for(int i=0;i&lt;=m;i++) dp[0][i]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=min(i,m);j++) for(int k=j-1;k&lt;=i;k++) dp[i][j]=min(dp[i][j],dp[k][j-1]+pow(s[i]-s[k]-ave)); return dp[n][m];&#125;bool check(double u,double v,double t)&#123; return u&gt;v||exp((u-v)/t)*rand()&gt;rand();&#125;void SA(double s,double t)&#123; double now=calc(); ans=min(ans,now); while (s&gt;t) &#123; int u=rand()%n+1; int v=rand()%n+1; if (u==v) continue; swap(w[u],w[v]); double nxt=calc(); ans=min(ans,nxt),s*=dt; if (!check(now,nxt,s)) swap(w[u],w[v]); else now=nxt; &#125;&#125;int main()&#123; srand((unsigned)time(0)); n=read(),m=read(); for(int i=1;i&lt;=n;i++) ave+=w[i]=read(); ave/=m; SA(st,ed); printf("%.2lf\n",sqrt(ans/m)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2004 虫食算]]></title>
    <url>%2F2018%2F08%2F11%2FNOIP2004-%E8%99%AB%E9%A3%9F%E7%AE%97%2F</url>
    <content type="text"><![CDATA[听说正解是高斯消元，但我还是选择搜索 考虑从右往左搜退出条件是搜完所有位置剪枝好像只能可行性剪枝复杂度还是很高 枚举的时候还能再优化一下 三个数均未确定 枚举其中两个计算第三个 两个数未确定 枚举一个计算一个 一个数未确定 直接计算 均确定 可行性剪枝 比较容易忽略的是回溯过程不合法也要先回溯再退出 最慢点1000+ms，吸口氧就能过了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;cstdlib&gt;const int N=500;int n,x[N],y[N],z[N],w[N],used[N],f[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (!('A'&lt;=ch&amp;&amp;ch&lt;='Z')) ch=getchar(); return ch;&#125;void print()&#123; for(int i=0;i&lt;n;i++) printf("%d ",w['A'+i]);&#125;void dfs(int t,int d)&#123; if (t&lt;=0) &#123; print(); exit(0); &#125; if (f[x[t]]&amp;f[y[t]]&amp;f[z[t]]) &#123; if ((w[x[t]]+w[y[t]]+d)%n==w[z[t]]) dfs(t-1,(w[x[t]]+w[y[t]]+d)/n); return; &#125; for(int fx=0,i=n-1;i&gt;=0&amp;&amp;!fx;i--) //1 &#123; if (f[x[t]]) fx=1; //Already if (!fx&amp;&amp;f[y[t]]&amp;f[z[t]]) //2&amp;3 &#123; fx=1; int val=(w[z[t]]+n-d-w[y[t]])%n; if (!used[val]) &#123; f[x[t]]=used[w[x[t]]=val]=1; dfs(t-1,(w[x[t]]+w[y[t]]+d)/n); f[x[t]]=used[val]=0; &#125; &#125; if (!fx&amp;&amp;!used[i]) f[x[t]]=used[w[x[t]]=i]=1; for(int fy=0,j=n-1;j&gt;=0&amp;&amp;!fy;j--) if (f[x[t]]) &#123; if (f[y[t]]) fy=1; //Already if (!fy&amp;&amp;f[z[t]]) //1&amp;3 &#123; fy=1; int val=(w[z[t]]+n-d-w[x[t]])%n; if (!used[val]) &#123; f[y[t]]=used[w[y[t]]=val]=1; dfs(t-1,(w[x[t]]+w[y[t]]+d)/n); f[y[t]]=used[val]=0; &#125; &#125; if (!fy&amp;&amp;!used[j]) f[y[t]]=used[w[y[t]]=j]=1; if (f[y[t]]) &#123; int fz=0,val=(w[x[t]]+w[y[t]]+d)%n; if (f[z[t]]) fz=1; //Already if (!fz&amp;&amp;!used[val]) f[z[t]]=used[w[z[t]]=val]=1; if ((w[x[t]]+w[y[t]]+d)%n==w[z[t]]) if (f[z[t]]) dfs(t-1,(w[x[t]]+w[y[t]]+d)/n); if (!fz&amp;&amp;f[z[t]]) f[z[t]]=used[val]=0; &#125; if (!fy&amp;&amp;f[y[t]]) f[y[t]]=used[j]=0; &#125; if (!fx&amp;&amp;f[x[t]]) f[x[t]]=used[i]=0; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) x[i]=get(); for(int i=1;i&lt;=n;i++) y[i]=get(); for(int i=1;i&lt;=n;i++) z[i]=get(); dfs(n,0); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CQOI2014]数三角形]]></title>
    <url>%2F2018%2F08%2F11%2FCQOI2014-%E6%95%B0%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[正难则反合法答案 = 所有三角形 - 水平（竖直）共线 - 斜共线 所有三角形C_{\left (n+1 \right )\left (m+1 \right )}^{3}水平（竖直）共线C_{n+1}^{3}\left ( m+1 \right )+C_{m+1}^{3}(n+1) 斜共线不好直接求，考虑枚举向量\left ( i,j \right )\ i\leq n+1,j\leq m+1为了保证不重不漏，第一和第二个点分别为\left ( i,j \right )起点与终点，第三个点在\left ( i,j \right )中间对于一组\left ( i,j \right )，共有\left ( n-i+1 \right )\left ( m-j+1 \right )种可能，其中第三个点还有gcd\left ( i,j \right )-1种可能考虑到左右对称，答案还需要*2123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define LL long longint n,m;LL ans=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;LL gcd(LL a,LL b)&#123;return b?gcd(b,a%b):a;&#125;LL C(LL m,LL n)&#123; if (m&lt;n) return 0; LL ret=1; for(LL i=1;i&lt;=n;i++) ret=ret*(m-i+1)/i; return ret;&#125;int main()&#123; n=read()+1,m=read()+1; ans=C(n*m,3); ans-=C(m,3)*n+C(n,3)*m; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) ans-=(n-i)*(m-j)*(gcd(i,j)-1)*2; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2009]靶形数独]]></title>
    <url>%2F2018%2F07%2F27%2FNOIP2009-%E9%9D%B6%E5%BD%A2%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[x，y，z 分别记录行，列和九宫格内已填数的集合每次选可填数最少的格子进行扩展12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int n=9,N=10;const int score[N][N]=&#123;&#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,6,6,6,6,6,6,6,6,6&#125;, &#123;0,6,7,7,7,7,7,7,7,6&#125;, &#123;0,6,7,8,8,8,8,8,7,6&#125;, &#123;0,6,7,8,9,9,9,8,7,6&#125;, &#123;0,6,7,8,9,10,9,8,7,6&#125;, &#123;0,6,7,8,9,9,9,8,7,6&#125;, &#123;0,6,7,8,8,8,8,8,7,6&#125;, &#123;0,6,7,7,7,7,7,7,7,6&#125;, &#123;0,6,6,6,6,6,6,6,6,6&#125;&#125;;int ans=0,cnt=0,w[N][N],x[N],y[N],z[N],idx[1&lt;&lt;N];int F(int u,int v)&#123;return (u-1)/3*3+(v+2)/3;&#125;int calc()&#123; int ret=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) ret=ret+w[i][j]*score[i][j]; return ret;&#125;void dfs()&#123; if (cnt==n*n) &#123; ans=max(ans,calc()); return; &#125; int u,v,sz=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if (!w[i][j]) &#123; int s=x[i]|y[j]|z[F(i,j)]; if (idx[s]&lt;=idx[sz]) u=i,v=j,sz=s; &#125; for(int i=1;i&lt;=n;i++) if ((sz&gt;&gt;(i-1))&amp;1^1) &#123; w[u][v]=i,cnt++; x[u]|=1&lt;&lt;(i-1); y[v]|=1&lt;&lt;(i-1); z[F(u,v)]|=1&lt;&lt;(i-1); dfs(); x[u]^=1&lt;&lt;(i-1); y[v]^=1&lt;&lt;(i-1); z[F(u,v)]^=1&lt;&lt;(i-1); w[u][v]=0,cnt--; &#125;&#125;int main()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;w[i][j]); for(int s=0;s&lt;(1&lt;&lt;n);s++) for(int i=1;i&lt;=n;i++) idx[s]+=(s&gt;&gt;(i-1))&amp;1^1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if (w[i][j]) &#123; int s=1&lt;&lt;(w[i][j]-1); if ((x[i]|y[j]|z[F(i,j)])&amp;s) &#123; puts("0"); return 0; &#125; x[i]|=s,y[j]|=s; z[F(i,j)]|=s,cnt++; &#125; dfs(); printf("%d\n",ans?ans:-1); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2008]硬币购物]]></title>
    <url>%2F2018%2F07%2F27%2FHAOI2008-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9%2F</url>
    <content type="text"><![CDATA[没有限制就是一个完全背包考虑仅有一个c 的硬币限制为d 枚正难则反，易得dp\left [ val \right ]为全部方案数而不合法的方案使用c 的个数肯定为d+1，d+2..假设c 强制选d+1 个，则现在所有的方案均为不合法的，也就是dp\left [ val-\left ( d+1 \right )*c \right ]对于多个硬币，只需容斥即可12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#define LL long longconst int N=100050,n=4;int c[N],w[N],f[N],val;LL dp[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void init()&#123; dp[0]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;N-c[i];j++) dp[j]+=dp[j-c[i]];&#125;int main()&#123; for(int i=1;i&lt;=n;i++) c[i]=read(); int T=read(); init(); while (T--) &#123; for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;=n;i++) f[i]=(w[i]+1)*c[i]; int val=read(); LL ans=0; for(int s=0;s&lt;(1&lt;&lt;n);s++) &#123; int num=0,t=1; for(int i=1;i&lt;=n;i++) if ((s&gt;&gt;(i-1))&amp;1) num+=f[i],t*=-1; if (num&lt;=val) ans+=dp[val-num]*t; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>容斥</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化数组]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[用可持久化线段树实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;const int N=1000050;int n,m,w[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;namespace Persistable_SGT&#123; struct node&#123;int l,r,val;&#125; t[N*25]; int rt[N],cnt=0,pos; void build(int &amp;o,int l,int r) &#123; o=++cnt; if (l==r) &#123;t[o].val=w[r];return;&#125; int mid=(l+r)&gt;&gt;1; build(t[o].l,l,mid); build(t[o].r,mid+1,r); &#125; void insert(int &amp;o,int pre,int l,int r,int x) &#123; t[o=++cnt]=t[pre]; if (l==r) &#123;t[o].val=x;return;&#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) insert(t[o].l,t[pre].l,l,mid,x); if (pos&gt;mid) insert(t[o].r,t[pre].r,mid+1,r,x); &#125; int query(int o,int l,int r) &#123; if (l==r) return t[o].val; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) return query(t[o].l,l,mid); if (pos&gt;mid) return query(t[o].r,mid+1,r); &#125;&#125;;using namespace Persistable_SGT;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(rt[0],1,n); for(int i=1;i&lt;=m;i++) &#123; int pre=read(),opt=read(); pos=read(); if (opt==1) insert(rt[i],rt[pre],1,n,read()); if (opt==2) printf("%d\n",query(rt[i]=rt[pre],1,n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>模板</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gauss消元]]></title>
    <url>%2F2018%2F07%2F27%2FGauss%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[消元形成倒三角12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int N=105;const double eps=1e-8;int n;double f[N][N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void Gauss()&#123; for(int i=1;i&lt;=n;i++) &#123; int t=i; for(int j=i+1;j&lt;=n;j++) if (fabs(f[j][i])&gt;fabs(f[t][i])) t=j; for(int j=i;j&lt;=n+1;j++) swap(f[i][j],f[t][j]); if (fabs(f[i][i])&lt;eps) &#123; puts("No Solution"); exit(0); &#125; for(int j=i+1;j&lt;=n;j++) &#123; double t=f[j][i]/f[i][i]; for(int k=i;k&lt;=n+1;k++) f[j][k]-=f[i][k]*t; &#125; &#125; for(int i=n;i&gt;0;i--) &#123; for(int j=i+1;j&lt;=n;j++) f[i][n+1]-=f[j][n+1]*f[i][j]; f[i][n+1]/=f[i][i]; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n+1;j++) f[i][j]=read(); Gauss(); for(int i=1;i&lt;=n;i++) printf("%.2lf\n",f[i][n+1]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>Gauss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应辛普森法]]></title>
    <url>%2F2018%2F07%2F27%2F%E8%87%AA%E9%80%82%E5%BA%94%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%B3%95%2F</url>
    <content type="text"><![CDATA[证明省略 \int_{a}^{b}f\left ( x \right )dx\approx \frac{b-a}{6}\left [ f\left ( a \right ) +4f\left ( \frac{a+b}{2} \right )+f\left ( b \right )\right ] 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const double eps=1e-10;double a,b,c,d;double F(double x)&#123; return (c*x+d)/(a*x+b);&#125;double simpson(double l,double r)&#123; double mid=(l+r)/2.0; return (F(l)+F(mid)*4.0+F(r))*(r-l)/6.0;&#125;double ASR(double l,double r,double ans)&#123; double mid=(l+r)/2.0; double L=simpson(l,mid); double R=simpson(mid,r); if (fabs(L+R-ans)&lt;eps) return ans; else return ASR(l,mid,L)+ASR(mid,r,R);&#125;int main()&#123; double ql,qr; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d); scanf("%lf%lf",&amp;ql,&amp;qr); printf("%.6lf",ASR(ql,qr,simpson(ql,qr))); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配]]></title>
    <url>%2F2018%2F07%2F27%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Hungary 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;const int N=1050;int n,m,T,cnt=0,used[N],c[N];vector&lt;int&gt; e[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;int find(int o)&#123; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (used[to]) continue; used[to]=1; if (!c[to]||find(c[to])) &#123; c[to]=o; return 1; &#125; &#125; return 0;&#125;int main()&#123; n=read(),m=read(),T=read(); while (T--) &#123; int u=read(),v=read(); if (u&gt;n||v&gt;m) continue; e[u].push_back(v); &#125; for(int i=1;i&lt;=n;i++) &#123; memset(used,0,sizeof(used)); cnt+=find(i); &#125; printf("%d",cnt); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2012]疫情控制]]></title>
    <url>%2F2018%2F07%2F27%2FNOIP2012-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[无法有效（不会）直接计算，考虑二分答案 对于一个二分的k显然尽可能地向上移动军队最优然而问题并没有这么简单因为根节点不能覆盖所以当一棵子树有多支军队，而其他子树没有时简单地贪心就会出错 需要考虑军队在子树之间的转移记录所有能在子树间转移的军队的剩余路程和所有需要封锁的子树在寻找未被封锁的子树时，需要转移的军队并不能参与封锁从大到小贪心地考虑所有要封锁的子树 优先选择已在该子树且剩余距离最小的军队 否则选择当前能够使用的军队 细节很多（调了很久）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=50050,rt=1;const LL INF=1LL&lt;&lt;50;struct node&#123;int id;LL val;&#125; A[N],B[N];int n,f[N],dep[N],v[N],idx,cnt;int m,w[N],pos[N],used[N];int log[N],fa[N][20];LL d[N][20],c[N];vector&lt;int&gt; e[N],g[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;bool cmp(node a,node b)&#123;return a.val&lt;b.val;&#125;void add(int u,int v,int val)&#123; e[u].push_back(v); g[u].push_back(val);&#125;void update(int k,int o,LL val)&#123; for(int i=log[dep[o]];i&gt;=0;i--) if (d[o][i]&lt;=val&amp;&amp;fa[o][i]&gt;rt) val-=d[o][i],o=fa[o][i]; c[k]=val-d[o][0],pos[k]=o; if (!v[o]||c[k]&lt;c[v[o]]) v[o]=k; f[o]=fa[o][0]==rt?0:1;&#125;void calc(int o)&#123; if (f[o]) return; if (e[o].size()==1) return; int flag=1; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (dep[to]&gt;dep[o]) &#123; calc(to); flag&amp;=f[to]; &#125; &#125; f[o]=flag;&#125;bool check(LL val)&#123; for(int i=1;i&lt;=n;i++) f[i]=v[i]=0; for(int i=1;i&lt;=m;i++) used[i]=0; for(int i=1;i&lt;=m;i++) update(i,w[i],val); calc(rt),idx=cnt=0; if (f[rt]) return 1; for(int i=0;i&lt;e[rt].size();i++) &#123; int to=e[rt][i]; if (!f[to]) A[++idx]=(node)&#123;to,d[to][0]&#125;; &#125; for(int i=1;i&lt;=m;i++) if (fa[pos[i]][0]==rt) B[++cnt]=(node)&#123;i,c[i]&#125;; sort(A+1,A+idx+1,cmp); sort(B+1,B+cnt+1,cmp); for(int i=idx,j=cnt;i&gt;0;i--) if (v[A[i].id]&amp;&amp;!used[v[A[i].id]]) used[v[A[i].id]]=1; else &#123; while (used[B[j].id]&amp;&amp;j&gt;0) j--; used[B[j].id]=1; if (A[i].val&lt;=B[j].val) j--;else return 0; &#125; return 1;&#125;void dfs(int o)&#123; for(int i=1;i&lt;=log[dep[o]];i++) &#123; fa[o][i]=fa[fa[o][i-1]][i-1]; d[o][i]=d[o][i-1]+d[fa[o][i-1]][i-1]; &#125; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dep[to]) &#123; fa[to][0]=o; d[to][0]=g[o][i]; dep[to]=dep[o]+1; dfs(to); &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) log[i]=log[i-1]+(1&lt;&lt;log[i-1]==i); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); int val=read(); add(u,v,val); add(v,u,val); &#125; m=read(); for(int i=1;i&lt;=m;i++) w[i]=read(); dep[rt]=1,dfs(rt); LL L=0,R=INF; while (L&lt;R) &#123; LL mid=(L+R)&gt;&gt;1; if (check(mid)) R=mid; else L=mid+1; &#125; printf("%lld\n",R==INF?-1:R); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>倍增</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3943 星空]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%B4%9B%E8%B0%B7P3943-%E6%98%9F%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[看题解系列 首先是异或差分（其实我也不知道叫什么）定义f 为异或数组 f\left [ i \right ]=w\left [ i \right ]\ xor \ w\left [ i+1 \right ]表示w\left [ i \right ]\ 与\ w\left [ i+1 \right ] 是否相同f 数组中至多有 2k 个 1 ，且肯定是偶数个当f 数组全部为0 时，灯全部点亮对于一段连续序列进行翻转，显然只需要修改f\left [ l-1 \right ]，f\left [ r \right ]这个操作等价于对某个元素进行移动当两个1 相遇时会消除于是问题等价于求所有1 消除的代价对于任意两个1 消除的代价，可用完全背包求将长度为len 的操作看成len 和-len 两种最后状压所有1 dp\left [ s' \right ]=min\left \{ dp\left [ s \right ] +cost\left [ i,j \right ]\right \}\left ( i\notin s,j\notin s \right )乍一看枚举i ，j 复杂度O\left ( 2^{N}N^{2} \right )但实际上其中一个并不用枚举，确定任意一个i 之后枚举j 即可因此复杂度O\left ( 2^{N}N \right )12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=18,M=40050,INF=1&lt;&lt;25;int n,k,m,dp[1&lt;&lt;N],d[M],idx[1&lt;&lt;N];int pos[M],cnt=0,w[M],f[M],v[M];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int main()&#123; n=read()+1,k=read(),m=read(); for(int i=1;i&lt;=k;i++) w[read()]=1; for(int i=1;i&lt;=m;i++) v[i]=read(); for(int i=0;i&lt;n;i++) f[i]=w[i]^w[i+1]; for(int i=0;i&lt;n;i++) if (f[i]) pos[++cnt]=i; for(int i=1;i&lt;=n;i++) d[i]=INF; for(int i=1;i&lt;=m;i++) for(int j=v[i];j&lt;=n;j++) d[j]=min(d[j],d[j-v[i]]+1); for(int i=1;i&lt;=m;i++) for(int j=n-v[i];j&gt;=0;j--) d[j]=min(d[j],d[j+v[i]]+1); for(int s=1;s&lt;(1&lt;&lt;cnt);s++) dp[s]=INF; for(int s=0;s&lt;(1&lt;&lt;cnt);s++) for(int i=1;i&lt;=cnt;i++) idx[s]+=(s&gt;&gt;(i-1))&amp;1; for(int x=1,s=0;s&lt;(1&lt;&lt;cnt);s++,x=1) if (idx[s]&amp;1^1) &#123; while ((s&gt;&gt;(x-1))&amp;1) x++; for(int i=x+1;i&lt;=cnt;i++) if ((s&gt;&gt;(i-1))^1) if (i!=x&amp;&amp;d[pos[i]-pos[x]]!=INF) dp[s|(1&lt;&lt;(i-1))|(1&lt;&lt;(x-1))]=min(dp[s|(1&lt;&lt;(i-1))|(1&lt;&lt;(x-1))],dp[s]+d[pos[i]-pos[x]]); &#125; printf("%d\n",dp[(1&lt;&lt;cnt)-1]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>差分</tag>
        <tag>背包</tag>
        <tag>状态压缩</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucas定理]]></title>
    <url>%2F2018%2F07%2F26%2FLucas%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[证明省略 Lucas\left ( m,n,p \right )=C\left ( m\%p,n\%p \right )*Lucas\left ( \left \lfloor \frac{m}{p}\right \rfloor ,\left \lfloor \frac{n}{p} \right \rfloor ,p \right ) Lucas\left ( m,0,p \right )=1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#define LL long longconst int N=200050;LL fact[N];int n,m,mod;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void init()&#123; fact[0]=1; for(int i=1;i&lt;=n+m;i++) fact[i]=fact[i-1]*i%mod;&#125;LL pow(LL a,LL b,LL mod)&#123; LL ret=1; for(;b;b&gt;&gt;=1) &#123; if (b&amp;1) ret=ret*a%mod; a=a*a%mod; &#125; return ret;&#125;LL C(LL m,LL n,LL mod)&#123; if (m&lt;n) return 0; return fact[m]*pow(fact[n]*fact[m-n]%mod,mod-2,mod)%mod;&#125;LL Lucas(LL m,LL n,LL mod)&#123; if (!n) return 1; return Lucas(m/mod,n/mod,mod)*C(m%mod,n%mod,mod)%mod;&#125;int main()&#123; int T=read(); while (T--) &#123; n=read(),m=read(); mod=read(); init(); printf("%lld\n",Lucas(n+m,m,mod)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日插值法]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[$n+1$个点可以唯一确定一个$n$次的多项式当然可以用高斯消元解，但复杂度是$O\left ( n^{3} \right )$的这里引入拉格朗日插值法 拉格朗日插值法对于$x_{i}$，假设有多项式$\ell_{i}$ \ell_{i}\left ( x \right )=\left\{\begin{matrix} 1 \ \left ( x=x_{i} \right ) \\ 0 \ \left ( x\neq x_{i} \right ) \end{matrix}\right.则 y_{i}\ell_{i}\left ( x \right )=\left\{\begin{matrix} y_{i} \ \left ( x=x_{i} \right ) \\ 0 \ \left ( x\neq x_{i} \right ) \end{matrix}\right.不难得出 \forall k\leq n+1 ,\sum_{i=1}^{n+1} y_{i}\ell_{i}\left ( x_{k} \right )=y_{k}即该多项式经过所有$n+1$个点 考虑如何构造$\ell_{i}\left ( x \right )$显然如下构造可行 \ell_{i}\left ( x \right )=\prod _{i\neq j}\frac{\left ( x-x_{j} \right )}{\left ( x_{i}-x_{j} \right )}对于每个$x_{j}\left ( i\neq j \right )$，分子中都会出现$0$而将$x_{i}$带入时，分子分母完全相同 化简可得 f\left (x \right )=\sum_{i=1}^{n+1}y_i\prod_{j\neq i}\frac{\left ( x-x_{j} \right )}{\left (x_{i}-x_{j} \right )}单次求值复杂度$O\left ( n^{2} \right )$ 重心拉格朗日插值法不难发现$\ell_{i}\left ( x \right )$有重复计算部分设 \ell\left ( x \right )=\prod_{i=1}^{n+1} \left ( x-x_{i} \right ) w_{i}=\frac{1}{\prod _{i\neq j}\left ( x_{i}-x_{j} \right )}不难得到 \ell_{i}\left ( x \right )=\ell\left ( x \right )\frac{w_{i}}{x-x_{i}}化简可得 f\left (x \right )=\ell\left ( x \right )\sum _{i=1}^{n+1}y_{i}\frac{w_{i}}{x-x_{i}}单次求值复杂度还是$O\left ( n^{2} \right )$当动态加入点时，一般拉格朗日插值法需要$O\left ( n^{2} \right )$重新计算，而重心拉格朗日插值法只需$O\left ( n \right )$计算一遍$w_{i}$ 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#define LL long longconst int mod=998244353;const int N=2050;LL n,x,a[N],b[N],ans=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;LL pow(LL a,LL b,LL mod)&#123; LL ret=1; for(;b;b&gt;&gt;=1) &#123; if (b&amp;1) ret=ret*a%mod; a=a*a%mod; &#125; return ret;&#125;int main()&#123; n=read(),x=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),b[i]=read(); for(int i=1;i&lt;=n;i++) &#123; LL A=b[i],B=1; for(int j=1;j&lt;=n;j++) if (i!=j) &#123; A=A*(x-a[j])%mod; B=B*(a[i]-a[j])%mod; &#125; ans=(ans+A*pow(B,mod-2,mod))%mod; &#125; printf("%lld\n",(ans%mod+mod)%mod); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4755 Beautiful Pair]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%B4%9B%E8%B0%B7P4755-Beautiful-Pair%2F</url>
    <content type="text"><![CDATA[对于一个\left ( L,R \right )的区间若其中最大值位置为k所有可行解可以分为三类 i，j 在k 的两边 i，k 或者k，j \left ( L,k-1 \right ),\left ( k+1,R \right )区间内 对于最后一种递归计算即可 对于第二种只需统计1 的个数 对于第一种若\left ( L,k-1 \right ),\left ( k+1,R \right )均已升序排序枚举其中一个区间则另一个区间中可以匹配的元素单调递减因此可以在线性时间内完成统计至于怎么对\left ( L,k-1 \right ),\left ( k+1,R \right )进行排序，归并即可 最优复杂度O\left ( NlogN \right )然而只要一组升序的数据就能卡成O\left ( N^{2}\right) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=200050;int n,pos[N][25],log[N];LL ans=0,w[N],t[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int get(int x,int y,int l,int r)&#123; if (w[x]&gt;w[y]) return x; if (w[y]&gt;w[x]) return y; int mid=(l+r)&gt;&gt;1; return abs(mid-x)&lt;abs(mid-y)?x:y;&#125;int find(int l,int r)&#123; int k=log[r-l+1]-1; return get(pos[l][k],pos[r-(1&lt;&lt;k)+1][k],l,r);&#125;void merge(int l,int k,int r)&#123; int cnt=0,i,j; for(i=l,j=k+1;i&lt;k,j&lt;=r;) t[++cnt]=w[i]&lt;w[j]?w[i++]:w[j++]; for(;i&lt;k;) t[++cnt]=w[i++]; for(;j&lt;=r;) t[++cnt]=w[j++]; t[++cnt]=w[k]; for(int i=l;i&lt;=r;i++) w[i]=t[i-l+1];&#125;void calc(int l,int r)&#123; if (l&gt;=r) return; int k=find(l,r); calc(l,k-1); calc(k+1,r); for(int i=l;i&lt;k;i++) ans+=w[i]==1; for(int i=k+1;i&lt;=r;i++) ans+=w[i]==1; for(int i=l,j=r;i&lt;k;i++) &#123; while (j&gt;k&amp;&amp;w[i]*w[j]&gt;w[k]) j--; ans+=j-k; &#125; merge(l,k,r);&#125;void init()&#123; for(int i=1;i&lt;=n;i++) log[i]=log[i-1]+(1&lt;&lt;log[i-1]==i); for(int i=1;i&lt;=n;i++) pos[i][0]=i; for(int j=1;j&lt;=log[n];j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) pos[i][j]=get(pos[i][j-1],pos[i+(1&lt;&lt;(j-1))][j-1],i,i+(1&lt;&lt;j)-1);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;=n;i++) ans+=w[i]==1; init(); calc(1,n); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1613 跑路]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%B4%9B%E8%B0%B7P1613-%E8%B7%91%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[很巧妙的一道题 设f\left [ i \right ]\left [ u \right ]\left [ v \right ]为u 到v 之间是否存在长度为2^{i}的路 f\left [ i \right ]\left [ u \right ]\left [ v \right ]=f\left [ i -1\right ]\left [ u \right ]\left [ k \right ]\ and \ f\left [ i -1\right ]\left [ k \right ]\left [ v \right ]设d\left [ u\right ]\left [v \right ]为u 到v 需要的时间 \exists f\left [ i \right ]\left [ u \right ]\left [ v \right ]=1,d\left [ u\right ]\left [v \right ]=1最后跑一遍Floyd 即可1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=55,INF=1&lt;&lt;25;int n,m,d[N][N],f[N][N][N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void Floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); f[0][u][v]=1; &#125; for(int i=1;i&lt;N;i++) for(int u=1;u&lt;=n;u++) for(int v=1;v&lt;=n;v++) for(int k=1;k&lt;=n;k++) if (f[i-1][u][k]&amp;&amp;f[i-1][k][v]) f[i][u][v]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=INF; for(int i=0;i&lt;N;i++) for(int u=1;u&lt;=n;u++) for(int v=1;v&lt;=n;v++) if (f[i][u][v]) d[u][v]=f[i][u][v]; Floyd(); printf("%d\n",d[1][n]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2012]国王游戏]]></title>
    <url>%2F2018%2F07%2F26%2FNOIP2012-%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[考虑第i 个和第i+1 个位置 max\left \{ \frac{pre}{R_{i}} \frac{pre*L_{i}}{R_{i+1}} \right \}交换之后则为 max\left \{ \frac{pre}{R_{i+1}} , \frac{pre*L_{i+1}}{R_{i}} \right \}其他人的并没有改变提取pre max\left \{ \frac{1}{R_{i}} , \frac{L_{i}}{R_{i+1}} \right \}\quad \quad \quad max\left \{ \frac{1}{R_{i+1}},\frac{L_{i+1}}{R_{i}} \right \}同乘R_{i}*R_{i+1} max\left \{ R_{i+1} , L_{i}R_{i} \right \}\quad \quad \quad max\left \{ R_{i}, L_{i+1}R_{i+1} \right \}L,R 均为正整数 R_{i}< L_{i}R_{i} \quad \quad \quad R_{i+1}< L_{i+1}R_{i+1} L_{i}R_{i} \quad \quad \quad L_{i+1}R_{i+1}因此将L*R较小的放在前面更优 人生苦短，我用Python12345678910111213n = int(input())x, y = map(int, input().split())w = []for i in range(0, n): L, R = map(int, input().split()) w.append(&#123;"L": L, "R": R, "val": L * R&#125;)w.sort(key=lambda node: node["val"])cnt = xans = 0for i in range(0, n): ans = max(ans, cnt // w[i]["R"]) cnt *= w[i]["L"]print("%d" % ans, end="")]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2411 Mondriaan's Dream]]></title>
    <url>%2F2018%2F07%2F22%2FPOJ2411-Mondriaan-s-Dream%2F</url>
    <content type="text"><![CDATA[经典的状压DP题，解法很多这里讲下状压轮廓线的做法s 从大到小保存若s_{5}=0，必须要竖放一个否则可以横放也可以不放12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=18;int n,m;LL dp[2][1&lt;&lt;N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int main()&#123; while (n=read(),m=read()) &#123; if (n&lt;m) swap(n,m); for(int s=0;s&lt;(1&lt;&lt;m);s++) dp[0][s]=0; dp[0][(1&lt;&lt;m)-1]=1; for(int i=1,now=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++,now^=1) &#123; for(int s=0;s&lt;(1&lt;&lt;m);s++) dp[now][s]=0; for(int s=0;s&lt;(1&lt;&lt;m);s++) if (!(s&gt;&gt;(m-1))&amp;1) dp[now][(s&lt;&lt;1)|1]+=dp[now^1][s]; else &#123; dp[now][(s&lt;&lt;1)&amp;((1&lt;&lt;m)-1)]+=dp[now^1][s]; if (j!=1&amp;&amp;!(s&amp;1)) dp[now][((s&lt;&lt;1)|3)&amp;((1&lt;&lt;m)-1)]+=dp[now^1][s]; &#125; &#125; printf("%lld\n",dp[(n*m)&amp;1][(1&lt;&lt;m)-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>轮廓线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2012]灾难]]></title>
    <url>%2F2018%2F07%2F22%2FZJOI2012-%E7%81%BE%E9%9A%BE%2F</url>
    <content type="text"><![CDATA[支配树的证明我意会了一下，并不会证这里稍微理一下DAG中支配树的构造 拓扑排序 对于每个点，求其所有入边的LCA，将其作为LCA的儿子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int N=100050,rt=0;;int n,w[N],d[N],log[N],dep[N],sz[N],fa[N][25];queue&lt;int&gt; Q;vector&lt;int&gt; e[N],f[N],g[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for(int i=log[dep[u]];i&gt;=0;i--) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) u=fa[u][i]; if (u==v) return u; for(int i=log[dep[u]];i&gt;=0;i--) if (fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];&#125;void find(int o)&#123; int pre=f[o][0]; for(int i=1;i&lt;f[o].size();i++) pre=LCA(pre,f[o][i]); g[pre].push_back(o); dep[o]=dep[pre]+1; fa[o][0]=pre; for(int i=1;i&lt;=log[dep[o]];i++) fa[o][i]=fa[fa[o][i-1]][i-1];&#125;void dfs(int o)&#123; sz[o]=1; for(int i=0;i&lt;g[o].size();i++) &#123; int to=g[o][i]; dfs(to); sz[o]+=sz[to]; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) log[i]=log[i-1]+(1&lt;&lt;log[i-1]==i); for(int x,i=1;i&lt;=n;i++) &#123; while (x=read()) &#123; e[x].push_back(i); f[i].push_back(x); d[i]++; &#125; &#125; for(int i=1;i&lt;=n;i++) if (!d[i]) &#123; f[i].push_back(rt); Q.push(i); &#125; for(int i=1;i&lt;=n;i++) &#123; int x=Q.front(); for(int k=0;k&lt;e[x].size();k++) &#123; int to=e[x][k]; if (--d[to]==0) Q.push(to); &#125; find(x),Q.pop(); &#125; dfs(rt); for(int i=1;i&lt;=n;i++) printf("%d\n",sz[i]-1); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>支配树</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2005]聪聪与可可]]></title>
    <url>%2F2018%2F07%2F22%2FNOI2005-%E8%81%AA%E8%81%AA%E4%B8%8E%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[首先预处理出可可在点s ，聪聪在点i 时，聪聪的下一步对每个s 做一遍单源最短路，枚举所有点i 的出边，选择其中距离较短且序号较小的点作为下一步设p\left[u\right]\left[v\right]为聪聪在点u 可可在点v 的期望步数 u=v ，p\left[u\right]\left[v\right]=0 当前回合能抓到，p\left[u\right]\left[v\right]=1 其他情况设x 为聪聪下一步 p\left[u\right]\left[v\right]=\sum\frac{p\left[x\right]\left[to\right]}{k+1}+\frac{p\left[x\right]\left[v\right]}{k+1}+1 记忆优化搜索即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int N=1050,INF=1&lt;&lt;30;int st,ed,n,m,nxt[N][N],f[N][N];int inq[N],d[N];double dp[N][N];vector&lt;int&gt; e[N];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void SPFA(int s)&#123; for(int i=1;i&lt;=n;i++) d[i]=INF; d[s]=0,inq[s]=1,Q.push(s); while (!Q.empty()) &#123; int x=Q.front(); inq[x]=0,Q.pop(); for(int i=0;i&lt;e[x].size();i++) &#123; int to=e[x][i]; if (d[x]+1&lt;d[to]) &#123; d[to]=d[x]+1; if (!inq[to]) Q.push(to),inq[to]=1; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) if (i!=s) for(int j=0;j&lt;e[i].size();j++) &#123; int to=e[i][j]; if (!nxt[i][s]||d[to]&lt;d[nxt[i][s]]) nxt[i][s]=to; if (d[to]==d[nxt[i][s]]&amp;&amp;to&lt;nxt[i][s]) nxt[i][s]=to; &#125;&#125;double dfs(int u,int v)&#123; if (f[u][v]) return dp[u][v]; if (u==v) return 0; if (nxt[u][v]==v) return 1; int x=nxt[nxt[u][v]][v]; if (x==v) return 1; for(int i=0;i&lt;e[v].size();i++) &#123; int to=e[v][i]; dp[u][v]+=dfs(x,to)/(1+e[v].size()); &#125; dp[u][v]+=dfs(x,v)/(1+e[v].size())+1; f[u][v]=1; return dp[u][v];&#125;int main()&#123; n=read(),m=read(); st=read(),ed=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; for(int i=1;i&lt;=n;i++) SPFA(i); printf("%.3lf\n",dfs(st,ed)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2005]最大子矩阵]]></title>
    <url>%2F2018%2F07%2F22%2FSCOI2005-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[观察到m 比较小考虑记录每行所有状态 m=1dp 数组记录第i 行，放了j 个，当前行放1 不放0 dp\left[i\right]\left[j\right]\left[0\right]=max\left( dp\left[i-1\right]\left[j\right]\left[0\right] ,dp\left[i-1\right]\left[j\right]\left[1\right]\right) dp\left[i\right]\left[j\right]\left[1\right]=max\left( dp\left[i-1\right]\left[j\right]\left[1\right] ,dp\left[i-1\right]\left[j-1\right]\left[0\right] ,dp\left[i-1\right]\left[j-1\right]\left[1\right] \right)+w\left[i\right]\left[1\right] m=20 表示两格均不放1 表示放左边2 表示放右边3 表示两格均有，且为两格个矩形4 表示两格均有，且为一个矩形转移方程因为空间问题（懒），请看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=105,INF=1&lt;&lt;25;int n,m,k,w[N][N],dp[N][N][5];// None L R 2 1inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void calc()&#123; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) dp[i][j][0]=dp[i][j][1]=-INF; dp[0][0][0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) &#123; dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]); dp[i][j][1]=dp[i-1][j][1]+w[i][1]; if (j&gt;0) dp[i][j][1]=max(dp[i][j][1],max(dp[i-1][j-1][1],dp[i-1][j-1][0])+w[i][1]); &#125; int ans=-INF; for(int i=0;i&lt;=k;i++) ans=max(ans,max(dp[n][i][0],dp[n][i][1])); printf("%d\n",ans);&#125;void solve()&#123; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) for(int s=0;s&lt;5;s++) dp[i][j][s]=-INF; dp[0][0][0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) &#123; for(int s=0;s&lt;5;s++) dp[i][j][0]=max(dp[i][j][0],dp[i-1][j][s]); dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j][3])+w[i][1]; dp[i][j][2]=max(dp[i-1][j][2],dp[i-1][j][3])+w[i][2]; dp[i][j][3]=dp[i-1][j][3]+w[i][1]+w[i][2]; dp[i][j][4]=dp[i-1][j][4]+w[i][1]+w[i][2]; if (j&gt;0) &#123; for(int s=0;s&lt;5;s++) dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-1][s]+w[i][1]); for(int s=0;s&lt;5;s++) dp[i][j][2]=max(dp[i][j][2],dp[i-1][j-1][s]+w[i][2]); dp[i][j][3]=max(dp[i][j][3],max(dp[i-1][j-1][3],max(dp[i-1][j-1][1],dp[i-1][j-1][2]))+w[i][1]+w[i][2]); for(int s=0;s&lt;5;s++) dp[i][j][4]=max(dp[i][j][4],dp[i-1][j-1][s]+w[i][1]+w[i][2]); &#125; if (j&gt;=2) for(int s=0;s&lt;5;s++) dp[i][j][3]=max(dp[i][j][3],dp[i-1][j-2][s]+w[i][1]+w[i][2]); &#125; int ans=-INF; for(int i=0;i&lt;=k;i++) for(int s=0;s&lt;5;s++) ans=max(ans,dp[n][i][s]); printf("%d\n",ans);&#125;int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=read(); if (m==1) calc();else solve(); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CQOI2017]小Q的棋盘]]></title>
    <url>%2F2018%2F07%2F22%2FCQOI2017-%E5%B0%8FQ%E7%9A%84%E6%A3%8B%E7%9B%98%2F</url>
    <content type="text"><![CDATA[f 记录第i 个点，访问j 条边，且返回i 点，经过的最大格点数量g 则记录不返回的 f\left[i\right]\left[j\right]=max\left\{ f\left[i\right]\left[k\right]+f\left[to\right]\left[j-k-2\right]\right\}\left ( to\in i_{son} \right )不在该子节点一去不回头 g\left[i\right]\left[j\right]=max\left\{ g\left[i\right]\left[k\right]+f\left[to\right]\left[j-k-2\right]\right\}\left ( to\in i_{son} \right )在该子节点一去不回头 g\left[i\right]\left[j\right]=max\left\{ f\left[i\right]\left[k\right]+g\left[to\right]\left[j-k-1\right]\right\}\left ( to\in i_{son} \right ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=200;int n,m,f[N][N],g[N][N]; //f:ret g:novector&lt;int&gt; e[N];void dfs(int o,int fa)&#123; f[o][0]=g[o][0]=1; for(int k=0;k&lt;e[o].size();k++) &#123; int to=e[o][k]; if (to==fa) continue; dfs(to,o); for(int i=m;i&gt;0;i--) for(int j=0;j&lt;i;j++) &#123; if (i-j-2&gt;=0) &#123; f[o][i]=max(f[o][i],f[to][j]+f[o][i-j-2]); g[o][i]=max(g[o][i],f[to][j]+g[o][i-j-2]); &#125; g[o][i]=max(g[o][i],g[to][j]+f[o][i-j-1]); &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; f[o][i]=max(f[o][i],f[o][i-1]), g[o][i]=max(g[o][i],g[o][i-1]); &#125; &#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;n;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); e[u].push_back(v); e[v].push_back(u); &#125; dfs(0,0); printf("%d\n",g[0][m]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形结构</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2001]求正整数]]></title>
    <url>%2F2018%2F07%2F22%2FHNOI2001-%E6%B1%82%E6%AD%A3%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[设N=\prod p_{i}^{a_{i}}则N 的约数个数为\prod \left( a_{i}+1 \right)题目中n 最大值为50000，因此N 的质因子不超过16个为了方便保存状态用了dfs当然搜索不可能用高精度，于是取对数保存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int N=20,INF=1&lt;&lt;30;const int p[]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53&#125;;int w[N],c[N],n;double f=INF;namespace NUM&#123; const int LEN=50000,mod=1e8; struct Num&#123;LL M[LEN],len;&#125;; void init(Num &amp;a) &#123; for(int i=0;i&lt;LEN;i++) a.M[i]=0; a.M[a.len=1]=1; &#125; void mul(Num &amp;a,int x) &#123; int d=0; for(int i=1;i&lt;a.len;i++) &#123; a.M[i]=a.M[i]*x+d; d=a.M[i]/mod; a.M[i]%=mod; &#125; a.M[a.len]=a.M[a.len]*x+d; while (a.M[a.len]&gt;=mod) &#123; a.M[a.len+1]=a.M[a.len]/mod; a.M[a.len++]%=mod; &#125; &#125; void print(Num a) &#123; printf("%lld",a.M[a.len]); for(int i=a.len-1;i&gt;0;i--) printf("%.8lld",a.M[i]); &#125;&#125;;void dfs(int k,int x,double now)&#123; if (k&gt;=16) return; if (now&gt;f) return; if (x==1) &#123; if (now&lt;f) &#123; for(int i=0;i&lt;16;i++) c[i]=w[i]; f=now; &#125; return; &#125; for(int i=1;i*i&lt;=x;i++) if (x%i==0) &#123; if (i*i!=x) &#123; w[k]=x/i-1; dfs(k+1,i,now+(x/i-1)*log(p[k])); w[k]=0; &#125; if (i!=1) &#123; w[k]=i-1; dfs(k+1,x/i,now+(i-1)*log(p[k])); w[k]=0; &#125; &#125;&#125;using namespace NUM;Num ans;int main()&#123; scanf("%d",&amp;n); dfs(0,n,0); init(ans); for(int i=0;i&lt;16;i++) while (c[i]--) mul(ans,p[i]); print(ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>数论</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2007]棋盘制作]]></title>
    <url>%2F2018%2F07%2F20%2FZJOI2007-%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[对于图上所有的棋盘一定属于以下两种类型： 黑格行列奇偶性相同，白格不同 白格行列奇偶性相同，黑格不同 分两类讨论每次翻转一部分棋盘的颜色然后问题就变成了求全1 的最大正方形和最大矩形参考洛谷P1736 创意吃鱼法，洛谷P4147-玉蟾宫 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;const int N=2050;struct node&#123;int val,sz;&#125;;stack&lt;node&gt; S;int n,m,s1,s2,L[N][N],U[N][N],dp[N][N],w[N][N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void calc()&#123; memset(dp,0,sizeof(dp)); memset(L,0,sizeof(L)); memset(U,0,sizeof(U)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) L[i][j]=w[i][j]?L[i][j-1]+1:0; for(int j=1;j&lt;=m;j++) for(int i=1;i&lt;=n;i++) U[i][j]=w[i][j]?U[i-1][j]+1:0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if (w[i][j]) s1=max(s1,dp[i][j]=min(dp[i-1][j-1],min(L[i][j-1],U[i-1][j]))+1);&#125;void solve()&#123; calc(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m/2;j++) swap(w[i][j],w[i][m-j+1]); calc(); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int sz=0; while (!S.empty()&amp;&amp;U[i][j]&lt;=S.top().val) &#123; sz+=S.top().sz; s2=max(s2,sz*S.top().val); S.pop(); &#125; S.push((node)&#123;U[i][j],sz+1&#125;); &#125; int sz=0; while (!S.empty()) &#123; sz+=S.top().sz; s2=max(s2,sz*S.top().val); S.pop(); &#125; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=((i+j)&amp;1)^read(); solve(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]^=1; solve(); printf("%d\n%d",s1*s1,s2); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1736 创意吃鱼法]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%B4%9B%E8%B0%B7P1736-%E5%88%9B%E6%84%8F%E5%90%83%E9%B1%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于每个元素预处理出其左端和上方最近的1 的位置，分别记为L 和U dp\left [i \right ]\left [j \right ]=max\left (dp\left [i-1 \right ]\left [ j-1 \right ],L\left [i \right ]\left [ j-1 \right ],U\left [i-1 \right ]\left [j \right ] \right )+1 \left ( w\left [i \right ]\left [j \right ]=1\right)水平翻转矩阵后再求一次12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=2505;int n,m,ans=0,dp[N][N],L[N][N],U[N][N],w[N][N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) L[i][j]=w[i][j]?0:L[i][j-1]+1; for(int j=1;j&lt;=m;j++) for(int i=1;i&lt;=n;i++) U[i][j]=w[i][j]?0:U[i-1][j]+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if (w[i][j]) ans=max(ans,dp[i][j]=min(dp[i-1][j-1],min(L[i][j-1],U[i-1][j]))+1); memset(dp,0,sizeof(dp)); memset(L,0,sizeof(L)); memset(U,0,sizeof(U)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m/2;j++) swap(w[i][j],w[i][m-j+1]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) L[i][j]=w[i][j]?0:L[i][j-1]+1; for(int j=1;j&lt;=m;j++) for(int i=1;i&lt;=n;i++) U[i][j]=w[i][j]?0:U[i-1][j]+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if (w[i][j]) ans=max(ans,dp[i][j]=min(dp[i-1][j-1],min(L[i][j-1],U[i-1][j]))+1); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4147 玉蟾宫]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%B4%9B%E8%B0%B7P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[首先预处理出f 数组为当前位置向左延伸的最大长度然后枚举每一列做一遍最大子矩形面积12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;const int N=1050;struct node &#123;int val,sz;&#125;;stack&lt;node&gt; S;int f[N][N],w[N][N],n,m,ans=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (ch!='F'&amp;&amp;ch!='R') ch=getchar(); return ch;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if (get()=='F') f[i][j]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=f[i][j]?w[i][j-1]+1:0; for(int k=1;k&lt;=m;k++) &#123; for(int i=1;i&lt;=n;i++) &#123; int sz=0; while (!S.empty()&amp;&amp;w[i][k]&lt;=S.top().val) &#123; sz+=S.top().sz; ans=max(ans,S.top().val*sz); S.pop(); &#125; S.push((node)&#123;w[i][k],sz+1&#125;); &#125; int sz=0; while (!S.empty()) &#123; sz+=S.top().sz; ans=max(ans,S.top().val*sz); S.pop(); &#125; &#125; printf("%d\n",ans*3); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子矩形面积]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[经典题目这里简要的总结一下它的四种做法最大子矩阵有四种做法，你知道吗 单调栈 维护一个单调递增的栈 栈中保存一个二元组\left ( height,sz \right )，分别为高度和能覆盖到的宽度 一个元素只会在超过它能覆盖的最大宽度后退栈 此时更新答案即可 笛卡尔树 笛卡尔树的定义这里就不赘述了 如果有一棵以高度为权值构造好的笛卡尔树 只需一遍dfs 即可得出答案 用单调栈可在O\left ( N\right )时间内建树 维护一个单调递增的栈 对于新加入的元素x ，将最后一个退栈元素作为其左儿子，将其作为栈中top 元素的右儿子 并查集 一种看似暴力的做法 实际上复杂度应该是O\left ( N\right ) 具体看代码实现 其中L 为当前位置向左能延伸的最大位置，R 为向右的 倍增 对于一个区间 找到其最小值所在位置 可将其分为左右两个区间递归处理，且互不影响 倍增数组维护最小值和最小值位置即可 倍增代码就不放了 代码依次给出12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;stack&gt;#define LL long longusing namespace std;struct node &#123;int val,sz;&#125;;int n,x;LL ans=0;stack&lt;node&gt; S;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;x); int sz=0; ans=max(ans,(LL)x*sz); while (!S.empty()&amp;&amp;x&lt;=S.top().val) &#123; sz+=S.top().sz; ans=max(ans,(LL)S.top().val*sz); S.pop(); &#125; S.push((node)&#123;x,sz+1&#125;); &#125; int sz=0; while (!S.empty()) &#123; sz+=S.top().sz; ans=max(ans,(LL)S.top().val*sz); S.pop(); &#125; printf("%lld",ans); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;deque&gt;#define LL long longusing namespace std;const int N=100050;int n,rt,L[N],R[N],sz[N],val[N];LL ans=0;deque&lt;int&gt; S;void build()&#123; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;val[i]); int x=0; while (!S.empty()&amp;&amp;val[i]&lt;val[S.back()]) x=S.back(),S.pop_back(); if (x) L[i]=x; if (!S.empty()) R[S.back()]=i; S.push_back(i); &#125; rt=S.front();&#125;void dfs(int o)&#123; if (!o) return; sz[o]=1; dfs(L[o]),dfs(R[o]); sz[o]+=sz[L[o]]+sz[R[o]]; ans=max(ans,(LL)val[o]*sz[o]);&#125;int main()&#123; scanf("%d",&amp;n); build(); dfs(rt); printf("%lld",ans); return 0;&#125; 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=100050;int L[N],R[N],val[N],n;LL ans=0;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;val[i]); for(int i=1;i&lt;=n;i++) L[i]=i,R[i]=i; for(int i=1;i&lt;=n;i++) while (L[i]-1&gt;=1&amp;&amp;val[L[i]-1]&gt;=val[i]) L[i]=L[L[i]-1]; for(int i=n;i&gt;0;i--) while (R[i]+1&lt;=n&amp;&amp;val[R[i]+1]&gt;=val[i]) R[i]=R[R[i]+1]; for(int i=1;i&lt;=n;i++) ans=max(ans,(LL)val[i]*(R[i]-L[i]+1)); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>并查集</tag>
        <tag>栈</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1357 花园]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%B4%9B%E8%B0%B7P1357-%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[观察到m 比较小，考虑状压m对于当前状态s当s‘ 去掉末尾位和s 去掉开头位相等，且s‘ 中个数&lt;=k dp\left [i \right ]\left [s’ \right ]+=dp\left [i-1 \right ]\left [ s \right ]然而问题没有这么简单，花园是个环设开头m 个状态为s ，则 dp\left [n+m \right ]\left [s\right ]为以s 开头的答案因此枚举开头所有状态即可，这样就有80分了 对于最后20分首先观察转移设当s 可以转移到s’ 时，f\left [s \right ]\left [s’ \right ]=1 dp\left [i \right ]\left [s’ \right ]=\sum dp\left [i-1 \right ]\left [ s \right ]* f\left [s \right ]\left [ s' \right ]与矩阵乘法一致因此 dp\left [ n+m \right ]\left [ s \right ]=dp\left [ m \right ]\left [ s \right ]*F^{n} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=8,mod=1e9+7;LL n,m,k,r,num[1&lt;&lt;N];namespace Matrix&#123; struct mtrx&#123;LL w[1&lt;&lt;N][1&lt;&lt;N];&#125; f; void fill(mtrx &amp;M,LL x) &#123; for(int i=0;i&lt;(1&lt;&lt;m);i++) for(int j=0;j&lt;(1&lt;&lt;m);j++) M.w[i][j]=x; &#125; void init(mtrx &amp;M) &#123; fill(M,0); for(int i=0;i&lt;(1&lt;&lt;m);i++) M.w[i][i]=1; &#125; void cpy(mtrx &amp;M,mtrx &amp;C) &#123; for(int i=0;i&lt;(1&lt;&lt;m);i++) for(int j=0;j&lt;(1&lt;&lt;m);j++) M.w[i][j]=C.w[i][j]; &#125; void mul(mtrx &amp;M,mtrx C,int mod) &#123; mtrx ret; fill(ret,0); for(int i=0;i&lt;(1&lt;&lt;m);i++) for(int j=0;j&lt;(1&lt;&lt;m);j++) for(int k=0;k&lt;(1&lt;&lt;m);k++) ret.w[i][j]=(ret.w[i][j]+M.w[i][k]*C.w[k][j])%mod; cpy(M,ret); &#125; void pow(mtrx &amp;M,LL x,int mod) &#123; mtrx ret; init(ret); for(;x;x&gt;&gt;=1) &#123; if (x&amp;1) mul(ret,M,mod); mul(M,M,mod); &#125; cpy(M,ret); &#125;&#125;;using namespace Matrix;void init()&#123; fill(f,0); for(int i=0;i&lt;(1&lt;&lt;m);i++) if (num[i]&lt;=k) for(int j=0;j&lt;(1&lt;&lt;m);j++) if (num[j]&lt;=k) if ((i&amp;((1&lt;&lt;(m-1))-1))==(j&gt;&gt;1)) f.w[i][j]=1;&#125;int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); for(int s=0;s&lt;(1&lt;&lt;m);s++) for(int i=1;i&lt;=m;i++) num[s]+=(s&gt;&gt;(i-1))&amp;1; init(); pow(f,n,mod); LL ans=0; for(int s=0;s&lt;(1&lt;&lt;m);s++) if (num[s]&lt;=k) ans=(ans+f.w[s][s])%mod; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2012]矿场搭建]]></title>
    <url>%2F2018%2F07%2F20%2FHNOI2012-%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[挺有难度的一道题，参考了一下大佬的题解 对于一个联通块 若无割点，则它与外界完全隔离，需要建两个出口以防一个出口被炸 若只有一个割点，还需要在非割点节点再建一个出口以防割点被炸 若有两个或以上割点，就不用担心了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=505;int n,m,T,dfn[N],low[N],num;int cut[N],idx[N],cnt,sz,col;LL ans,cost;vector&lt;int&gt; e[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void tarjan(int o,int fa)&#123; int son=0; dfn[o]=low[o]=++num; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dfn[to]) &#123; tarjan(to,fa); low[o]=min(low[o],low[to]); if (low[to]&gt;=dfn[o]&amp;&amp;o!=fa) cut[o]=1; son++; &#125; else low[o]=min(low[o],dfn[to]); &#125; if (o==fa&amp;&amp;son&gt;=2) cut[o]=1;&#125;void dfs(int o)&#123; idx[o]=col,sz++; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (idx[to]!=col&amp;&amp;cut[to]) idx[to]=col,cnt++; if (!idx[to]&amp;&amp;!cut[to]) dfs(to); &#125;&#125;int main()&#123; while (m=read()) &#123; ans=1,cost=num=col=n=0; for(int i=1;i&lt;N;i++) e[i].clear(); for(int i=1;i&lt;N;i++) dfn[i]=low[i]=0; for(int i=1;i&lt;N;i++) cut[i]=idx[i]=0; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); n=max(n,max(u,v)); &#125; for(int i=1;i&lt;=n;i++) if (!dfn[i]) tarjan(i,i); for(int i=1;i&lt;=n;i++) if (!idx[i]&amp;&amp;!cut[i]) &#123; cnt=sz=0; col++,dfs(i); if (cnt==0) cost+=2,ans*=sz*(sz-1)/2; if (cnt==1) cost+=1,ans*=sz; &#125; printf("Case %d: %lld %lld\n",++T,cost,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AHOI2009]中国象棋]]></title>
    <url>%2F2018%2F07%2F19%2FAHOI2009-%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[每行每列最多放两个dp 数组记录第i 行，有j 列放了1个，k 列放了2个的方案数不放 dp\left [i \right ]\left [ j \right ]\left [k \right ]+=dp\left [i-1 \right ]\left [ j \right ]\left [k \right ]放一个 dp\left [i\right ]\left [ j+1 \right ]\left [k \right ]+=dp\left [i-1 \right ]\left [ j \right ]\left [k \right ]*(m-j-k)(m-j-k>0) dp\left [i \right ]\left [ j \right ]\left [k +1 \right ]+=dp\left [i -1\right ]\left [ j \right ]\left [k \right ]*j(j>0)放两个 dp\left [i \right ]\left [ j -2\right ]\left [k +2 \right ]+=dp\left [i-1 \right ]\left [ j \right ]\left [k \right ]*C_{j}^{2}(j\geq 2) dp\left [i \right ]\left [ j +2\right ]\left [k \right ]+=dp\left [i-1 \right ]\left [ j \right ]\left [k \right ]*C_{m-j-k}^{2}(m-j-k\geq 2) dp\left [i \right ]\left [ j \right ]\left [k +1\right ]+=dp\left [i-1 \right ]\left [ j \right ]\left [k \right ]*(m-j-k)*j(j>0,m-j-k>0) 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#define LL long longconst int N=105,mod=9999973;int n,m;LL dp[N][N][N]; //row,1,2int main()&#123; scanf("%d%d",&amp;n,&amp;m); dp[0][0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) for(int k=0;j+k&lt;=m;k++) &#123; dp[i][j][k]=(dp[i][j][k]+dp[i-1][j][k])%mod; if (m-j-k&gt;0) dp[i][j+1][k]=(dp[i][j+1][k]+dp[i-1][j][k]*(m-j-k))%mod; if (j&gt;0) dp[i][j-1][k+1]=(dp[i][j-1][k+1]+dp[i-1][j][k]*j)%mod; if (j&gt;=2) dp[i][j-2][k+2]=(dp[i][j-2][k+2]+dp[i-1][j][k]*j*(j-1)/2)%mod; if (m-j-k&gt;=2) dp[i][j+2][k]=(dp[i][j+2][k]+dp[i-1][j][k]*(m-j-k)*(m-j-k-1)/2)%mod; if (j&gt;0&amp;&amp;m-j-k&gt;0) dp[i][j][k+1]=(dp[i][j][k+1]+dp[i-1][j][k]*(m-j-k)*j)%mod; &#125; int ans=0; for(int i=0;i&lt;=m;i++) for(int j=0;i+j&lt;=m;j++) ans=(ans+dp[n][i][j])%mod; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1262 间谍网络]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%B4%9B%E8%B0%B7P1262-%E9%97%B4%E8%B0%8D%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[缩点时在新节点中保存最小花费和最小编号即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;const int N=3050,INF=1&lt;&lt;25;int n,m,w[N];int sz[N],val[N],idx[N],cnt=0,d[N];int dfn[N],low[N],num=0,inq[N];int ans=0,id=INF;vector&lt;int&gt; e[N];stack&lt;int&gt; S;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void tarjan(int o)&#123; dfn[o]=low[o]=++num; inq[o]=1,S.push(o); for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dfn[to]) &#123; tarjan(to); low[o]=min(low[o],low[to]); &#125; else if (inq[to]) low[o]=min(low[o],dfn[to]); &#125; if (dfn[o]==low[o]) &#123; int x;++cnt; do&#123; x=S.top(); inq[x]=0,S.pop(); idx[x]=cnt; val[cnt]=min(val[cnt],w[x]); sz[cnt]=min(sz[cnt],x); &#125; while (x!=o); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=sz[i]=val[i]=INF; int T=read(); while (T--) &#123; int x=read(); w[x]=read(); &#125; m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); e[u].push_back(v); &#125; for(int i=1;i&lt;=n;i++) if (!dfn[i]) tarjan(i); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;e[i].size();j++) &#123; int u=i,v=e[i][j]; if (idx[u]!=idx[v]) d[idx[v]]++; &#125; for(int i=1;i&lt;=cnt;i++) if (!d[i]) &#123; if (val[i]==INF) id=min(id,sz[i]); else ans+=val[i]; &#125; if (id==INF) printf("YES\n%d",ans); else printf("NO\n%d",id); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>缩点</tag>
        <tag>强联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO06NOV]路障Roadblocks]]></title>
    <url>%2F2018%2F07%2F19%2FUSACO06NOV-%E8%B7%AF%E9%9A%9CRoadblocks%2F</url>
    <content type="text"><![CDATA[和次小生成树相似的套路记f 为S 到所有点的最短路，g 为T 到所有点的最短路枚举所有边edge\left \{ u,v,val \right \} ans=min\left \{ f\left [ u \right ]+val+ g\left [ v \right ]\right \}\left ( f\left [ u \right ]+val+ g\left [ v \right ]>f\left [ T \right ] \right ) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=5050,INF=1&lt;&lt;30;int n,m,d[2][N],inq[N],mins=INF,ans=INF;vector&lt;int&gt; e[N],g[N];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int val)&#123; e[u].push_back(v); g[u].push_back(val);&#125;void SPFA(int s,int k)&#123; for(int i=1;i&lt;=n;i++) d[k][i]=INF; d[k][s]=0,inq[s]=1,Q.push(s); while (!Q.empty()) &#123; int x=Q.front(); inq[x]=0,Q.pop(); for(int i=0;i&lt;e[x].size();i++) &#123; int to=e[x][i]; if (d[k][x]+g[x][i]&lt;d[k][to]) &#123; d[k][to]=d[k][x]+g[x][i]; if (!inq[to]) inq[to]=1,Q.push(to); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); int val=read(); add(u,v,val); add(v,u,val); &#125; SPFA(1,0),SPFA(n,1); mins=d[0][n]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;e[i].size();j++) &#123; int u=i,v=e[i][j]; if (d[0][u]+g[i][j]+d[1][v]&gt;mins) ans=min(ans,d[0][u]+g[i][j]+d[1][v]); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2002 消息扩散]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%B4%9B%E8%B0%B7P2002-%E6%B6%88%E6%81%AF%E6%89%A9%E6%95%A3%2F</url>
    <content type="text"><![CDATA[缩完点之后求有多少入度为0的点即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;const int N=100050;int n,m,d[N],idx[N],cnt=0,ans=0;int inq[N],dfn[N],low[N],num=0;vector&lt;int&gt; e[N],g[N];stack&lt;int&gt; S;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void tarjan(int o)&#123; dfn[o]=low[o]=++num; inq[o]=1,S.push(o); for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dfn[to]) &#123; tarjan(to); low[o]=min(low[o],low[to]); &#125; else if (inq[to]) low[o]=min(low[o],dfn[to]); &#125; if (low[o]==dfn[o]) &#123; int x;cnt++; do&#123; x=S.top(); inq[x]=0,S.pop(); idx[x]=cnt; &#125; while(x!=o); &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); if (u==v) continue; e[u].push_back(v); &#125; for(int i=1;i&lt;=n;i++) if (!dfn[i]) tarjan(i); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;e[i].size();j++) &#123; int u=i,v=e[i][j]; if (idx[u]!=idx[v]) &#123; g[idx[u]].push_back(idx[v]); d[idx[v]]++; &#125; &#125; for(int i=1;i&lt;=cnt;i++) if (!d[i]) ans++; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>缩点</tag>
        <tag>强联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2009]猜数字]]></title>
    <url>%2F2018%2F07%2F19%2FTJOI2009-%E7%8C%9C%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[\left\{\begin{matrix} x\equiv a_{1}\left ( mod \ b_{1} \right ) \\ x\equiv a_{2}\left ( mod \ b_{2} \right )\\ \cdots \\ x\equiv a_{n}\left ( mod \ b_{n} \right )\\ \end{matrix}\right.其中gcd\left ( b_{i} ,b_{j}\right )=1\left ( i\neq j,i\in n,j\in n \right )设 M=\prod_{i=1}^{n}b_{i} M_{i}=\frac{M}{b_{i}} r_{i}\equiv M_{i}^{-1}\left ( mod \ b_{i} \right )则 x=\sum_{i=1}^{n}M_{i}a_{i}r_{i}且在M 以内有唯一解123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#define LL long longconst int N=15;LL a[N],b[N],M[N]=&#123;1&#125;,r[N],n,x,ans=0;void exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if (!b) &#123; x=1,y=0; return; &#125; exgcd(b,a%b,y,x); y-=a/b*x;&#125;LL mul(LL a,LL b,LL mod)&#123; LL ret=0; for(;b;b&gt;&gt;=1) &#123; if (b&amp;1) ret=(ret+a)%mod; a=(a&lt;&lt;1)%mod; &#125; return ret;&#125;int main()&#123; scanf("%lld",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;b[i]); for(int i=1;i&lt;=n;i++) a[i]=(a[i]%b[i]+b[i])%b[i]; for(int i=1;i&lt;=n;i++) M[0]*=b[i]; for(int i=1;i&lt;=n;i++) M[i]=M[0]/b[i]; for(int i=1;i&lt;=n;i++) exgcd(M[i],b[i],r[i],x); for(int i=1;i&lt;=n;i++) r[i]=(r[i]%b[i]+b[i])%b[i]; for(int i=1;i&lt;=n;i++) ans=(ans+mul(mul(a[i],M[i],M[0]),r[i],M[0]))%M[0]; printf("%lld\n",(ans%M[0]+M[0])%M[0]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1273 有线电视网]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%B4%9B%E8%B0%B7P1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%2F</url>
    <content type="text"><![CDATA[记dp\left [ i\right ]\left [ j \right ]为i 节点，取j 个能获得的最大收入叶节点dp\left [ i\right ]\left [ 1 \right ]=w\left [ i \right ]转移方程 dp\left [ x\right ]\left [ i \right ]=max\left \{ dp\left [ to \right ]\left [ j \right ]+dp\left [ x \right ]\left [ i-j \right ]-cost\left [ x \right ]\left [ to \right ] \right \}\left ( to\in x_{son} \right ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=3050,rt=1,INF=1&lt;&lt;20;int dp[N][N],n,m,sz[N];vector&lt;int&gt; e[N],g[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int val)&#123; e[u].push_back(v); g[u].push_back(val);&#125;void dfs(int o)&#123; if (o&gt;n-m) sz[o]=1; for(int k=0;k&lt;e[o].size();k++) &#123; int to=e[o][k]; dfs(to); for(int i=m;i&gt;=0;i--) for(int j=0;j&lt;=min(i,sz[to]);j++) dp[o][i]=max(dp[o][i],dp[o][i-j]+dp[to][j]-g[o][k]); sz[o]+=sz[to]; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n-m;i++) &#123; int T=read(); while (T--) &#123; int u=i,v=read(); add(u,v,read()); &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) dp[i][j]=-INF; for(int i=n-m+1;i&lt;=n;i++) dp[i][1]=read(); dfs(rt); for(int i=m;i&gt;=0;i--) if (dp[rt][i]&gt;=0) &#123; printf("%d\n",i); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形结构</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2010]中位数]]></title>
    <url>%2F2018%2F07%2F19%2FTJOI2010-%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[对顶堆的模板题对顶堆为一个大根堆A ,和一个小根堆B ,分别维护一个序列的前一段和后一段要求中位数，只需要将序列均分入两个堆中即可1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct cmp&#123;bool operator ()(int a,int b)&#123;return a&gt;b;&#125;&#125;;priority_queue&lt;int&gt; A;priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; B;int n,m;int main()&#123; scanf("%d",&amp;n); for(int i=1,x;i&lt;=n;i++) &#123; scanf("%d",&amp;x); B.push(x); &#125; while (B.size()&gt;A.size()) &#123; A.push(B.top()); B.pop(); &#125; scanf("%d",&amp;m); for(int i=1,x;i&lt;=m;i++) &#123; char str[10]; scanf("%s",str); if (str[0]=='a') &#123; scanf("%d",&amp;x),n++; x&gt;A.top()?B.push(x):A.push(x); while (A.size()&gt;n/2) &#123; B.push(A.top()); A.pop(); &#125; while (B.size()&gt;A.size()) &#123; A.push(B.top()); B.pop(); &#125; &#125; else printf("%d\n",A.top()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[严格次小生成树[BJWC2010]]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-BJWC2010%2F</url>
    <content type="text"><![CDATA[首先要知道怎么求非严格次小生成树记max\left \{ u,v \right \}为u，v 路径上的最大边权先求一遍最小生成树，记权值为mins然后枚举所有不在树中的边edge\left \{ u,v,val \right \}非严格次小生成树的权值为min\left \{ mins-max\left \{ u,v \right \} +val\right \}用倍增或树剖都可以求 现在要求严格次小的于是记录\left \{ u,v \right \}的次大边权，保证其严格小于最大值，记为nxt\left \{ u,v \right \}然后依旧是枚举所有不在树中的边edge\left \{ u,v,val \right \}若val>max\left \{ u,v \right \}，则为mins-max\left \{ u,v \right \} +val，否则为mins-nxt\left \{ u,v \right \} +val123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=100050,rt=1;const LL INF=1LL&lt;&lt;60;LL mins=0,ans=INF;int fa[N][25],w[N][25],c[N][25],log[N];int dep[N],n,m,f[N],used[N&lt;&lt;2];struct edge&#123;int u,v,val;&#125;t[N&lt;&lt;2];vector&lt;int&gt; e[N],g[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;bool cmp(edge a,edge b)&#123;return a.val&lt;b.val;&#125;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;void unite(int u,int v)&#123;f[find(u)]=find(v);&#125;void add(int u,int v,int val)&#123; e[u].push_back(v); g[u].push_back(val);&#125;void dfs(int o)&#123; for(int i=1;i&lt;=log[dep[o]];i++) &#123; fa[o][i]=fa[fa[o][i-1]][i-1]; w[o][i]=max(w[o][i-1],w[fa[o][i-1]][i-1]); c[o][i]=max(c[o][i-1],c[fa[o][i-1]][i-1]); if (w[o][i-1]&lt;w[fa[o][i-1]][i-1]) c[o][i]=max(c[o][i],w[o][i-1]); if (w[o][i-1]&gt;w[fa[o][i-1]][i-1]) c[o][i]=max(c[o][i],w[fa[o][i-1]][i-1]); &#125; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (!dep[to]) &#123; dep[to]=dep[o]+1; fa[to][0]=o; w[to][0]=g[o][i]; dfs(to); &#125; &#125;&#125;int calc(int u,int v,int val)&#123; int ret=0; if (dep[u]&lt;dep[v]) swap(u,v); for(int i=0;i&lt;=log[dep[u]];i++) if (((dep[u]-dep[v])&gt;&gt;i)&amp;1) &#123; ret=max(ret,val!=w[u][i]?w[u][i]:c[u][i]); u=fa[u][i]; &#125; if (u==v) return ret; for(int i=log[dep[u]];i&gt;=0;i--) if (fa[u][i]!=fa[v][i]) &#123; ret=max(ret,val!=w[u][i]?w[u][i]:c[u][i]); ret=max(ret,val!=w[v][i]?w[v][i]:c[v][i]); u=fa[u][i],v=fa[v][i]; &#125; ret=max(ret,val!=w[u][0]?w[u][0]:c[u][0]); ret=max(ret,val!=w[v][0]?w[v][0]:c[v][0]); return ret;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) log[i]=log[i-1]+(1&lt;&lt;log[i-1]==i); for(int i=1;i&lt;=m;i++) &#123; t[i].u=read(); t[i].v=read(); t[i].val=read(); &#125; sort(t+1,t+m+1,cmp); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=m;i++) &#123; int u=t[i].u,v=t[i].v; if (find(u)!=find(v)) &#123; used[i]=1; add(u,v,t[i].val); add(v,u,t[i].val); unite(u,v); mins+=t[i].val; &#125; &#125; dep[rt]=1,dfs(rt); for(int i=1;i&lt;=m;i++) if (!used[i]) &#123; int u=t[i].u,v=t[i].v; int val=calc(u,v,t[i].val); ans=min(ans,mins-val+t[i].val); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO07NOV]奶牛接力Cow Relays]]></title>
    <url>%2F2018%2F07%2F19%2FUSACO07NOV-%E5%A5%B6%E7%89%9B%E6%8E%A5%E5%8A%9BCow-Relays%2F</url>
    <content type="text"><![CDATA[记dp\left [ t \right ]\left [ i \right ]\left [ j\right ]为i 到j 经过t 条边的最短路转移方程为 dp\left [ t+1 \right ]\left [ i \right ]\left [ j\right ]=min\left \{ dp\left [ t \right ]\left [ i \right ]\left [ k \right ]+ d\left [ k \right ]\left [ j \right ]\right \}\left ( 1\leq k\leq n \right )通过观察，发现很像矩阵乘法，然后还满足交换律因此 dp\left [ t \right ]=dp\left [ 0 \right ]*D^{t}dp\left [ 0 \right ]矩阵中除dp\left [ 0 \right ]\left [ st \right ]\left [ st \right ]= 0，其它为INF123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=205;const LL INF=1LL&lt;&lt;60;int pos[N&lt;&lt;10],cnt=0,n,m,st,ed;;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;namespace Matrix&#123; struct mtrx&#123;LL w[N][N];&#125; d; void fill(mtrx &amp;M,LL x) &#123; for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) M.w[i][j]=x; &#125; void cpy(mtrx &amp;M,mtrx &amp;C) &#123; for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) M.w[i][j]=C.w[i][j]; &#125; void mul(mtrx &amp;M,mtrx C) &#123; mtrx ret; fill(ret,INF); for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) for(int k=1;k&lt;=cnt;k++) ret.w[i][j]=min(ret.w[i][j],M.w[i][k]+C.w[k][j]); cpy(M,ret); &#125; void pow(mtrx &amp;M,int x) &#123; mtrx ret; fill(ret,INF); ret.w[pos[st]][pos[st]]=0; for(;x;x&gt;&gt;=1) &#123; if (x&amp;1) mul(ret,M); mul(M,M); &#125; cpy(M,ret); &#125;&#125;;using namespace Matrix;int main()&#123; n=read(),m=read(),st=read(),ed=read(); for(int i=1;i&lt;N;i++) for(int j=1;j&lt;N;j++) d.w[i][j]=INF; for(int i=1;i&lt;=m;i++) &#123; LL val=read(); int u=read(),v=read(); if (!pos[u]) pos[u]=++cnt; if (!pos[v]) pos[v]=++cnt; u=pos[u],v=pos[v]; d.w[u][v]=d.w[v][u]=min(d.w[u][v],val); &#125; pow(d,n); printf("%lld\n",d.w[pos[st]][pos[ed]]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>图论</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2398 GCD SUM]]></title>
    <url>%2F2018%2F07%2F15%2F%E6%B4%9B%E8%B0%B7P2398-GCD-SUM%2F</url>
    <content type="text"><![CDATA[直接计算复杂度过高无法接受考虑枚举所有gcd值计算若gcd=k对于所有gcd\left ( x,y \right )=1，有gcd\left ( xk,yk \right )=k\left ( xk\leq n,yk\leq n \right )所以gcd=k的个数为 2\sum_{i=1}^{\left \lfloor \frac{n}{k} \right \rfloor}\varphi \left ( i \right )-1复杂度O\left (N \right ) 还有一种更妙的做法设f\left [ k \right ]为gcd=k的个数设g\left [ k \right ]为k|gcd的个数 g\left [ k \right ]=\sum_{i=1}^{\left \lfloor \frac{n}{k} \right \rfloor}f\left [ ik \right ]=\left [ \frac{n}{k} \right ]^{2} f\left [ k \right ]=g\left [ k \right ]-\sum_{i=2}^{\left \lfloor \frac{n}{k} \right \rfloor}f\left [ ik \right ]倒序计算即可复杂度O\left ( NlogN \right )123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define LL long longconst int N=100050;int prime[N],cnt=0,phi[N];LL n,sum[N],ans=0;void init()&#123; phi[1]=1; for(int i=2;i&lt;=n;i++) &#123; if (!phi[i]) prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt;j++) &#123; if (prime[j]*i&gt;n) break; if (i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125; for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+phi[i];&#125;int main()&#123; scanf("%lld",&amp;n); init(); for(LL i=1;i&lt;=n;i++) ans+=(sum[n/i]*2-1)*i; printf("%lld",ans); return 0;&#125; 1234567891011121314151617#include&lt;cstdio&gt;#define LL long longconst int N=100050;LL n,f[N],g[N],ans=0;int main()&#123; scanf("%lld",&amp;n); for(LL i=1;i&lt;=n;i++) g[i]=(n/i)*(n/i); for(LL i=n;i&gt;0;i--) &#123; f[i]=g[i]; for(LL j=2;i*j&lt;=n;j++) f[i]-=f[i*j]; ans+=f[i]*i; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2801 教主的魔法]]></title>
    <url>%2F2018%2F07%2F15%2F%E6%B4%9B%E8%B0%B7P2801-%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95%2F</url>
    <content type="text"><![CDATA[想了好久发现套不了数据结构。然后看了看数据范围用了分块。分成\sqrt{n }个块，块内保持有序对于M 操作，覆盖整块就打标记，否则暴力更新并重新排序对于A 操作，覆盖整块就二分查找，否则暴力查找复杂度O\left ( QlogN \sqrt{N} \right )12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int N=1050;int n,m,num,c[N][N],id[N][N],w[N],st[N],ed[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (!(('a'&lt;=ch&amp;&amp;ch&lt;='z')||('A'&lt;=ch&amp;&amp;ch&lt;='Z'))) ch=getchar(); return ch;&#125;void qsort(int k,int l,int r)&#123; int i=l,j=r,mid=c[k][id[k][(l+r)&gt;&gt;1]]; do &#123; while (c[k][id[k][i]]&lt;mid) i++; while (c[k][id[k][j]]&gt;mid) j--; if (i&lt;=j) swap(id[k][i],id[k][j]),i++,j--; &#125; while (i&lt;=j); if (i&lt;r) qsort(k,i,r); if (l&lt;j) qsort(k,l,j); &#125;int find(int k,int x)&#123; int L=1,R=ed[k]-st[k]+1; while (L&lt;R) &#123; int mid=(L+R)&gt;&gt;1; if (c[k][id[k][mid]]+w[k]&lt;x) L=mid+1; else R=mid; &#125; return (L+R)&gt;&gt;1;&#125;int main()&#123; n=read(),m=read(); num=sqrt(n)+1; for(int i=0;i&lt;=num;i++) st[i]=n; for(int i=1,cnt=0;i&lt;=n;i++) &#123; st[i/num]=min(st[i/num],i); ed[i/num]=max(ed[i/num],i); &#125; for(int i=1;i&lt;=n;i++) &#123; c[i/num][i-st[i/num]+1]=read(); id[i/num][i-st[i/num]+1]=i-st[i/num]+1; &#125; for(int i=1;i&lt;=num;i++) qsort(i,1,ed[i]-st[i]+1); for(int i=1;i&lt;=m;i++) &#123; char opt=get(); int ql=read(),qr=read(),x=read(); if (opt=='M') &#123; for(int i=ql;i&lt;=min(qr,ed[ql/num]);i++) c[i/num][i-st[i/num]+1]+=x; for(int i=ql/num+1;i&lt;qr/num;i++) w[i]+=x; if (ql/num!=qr/num) for(int i=st[qr/num];i&lt;=qr;i++) c[i/num][i-st[i/num]+1]+=x; qsort(ql/num,1,ed[ql/num]-st[ql/num]+1); if (ql/num!=qr/num) qsort(qr/num,1,ed[qr/num]-st[qr/num]+1); &#125; else &#123; int ans=0; for(int i=ql;i&lt;=min(qr,ed[ql/num]);i++) if (c[i/num][i-st[i/num]+1]+w[i/num]&gt;=x) ans++; for(int i=ql/num+1;i&lt;qr/num;i++) &#123; if (c[i][id[i][ed[i]-st[i]+1]]+w[i]&lt;x) continue; ans+=(ed[i]-st[i]+1)-find(i,x)+1; &#125; if (ql/num!=qr/num) for(int i=st[qr/num];i&lt;=qr;i++) if (c[i/num][i-st[i/num]+1]+w[i/num]&gt;=x) ans++; printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CQOI2007]余数求和]]></title>
    <url>%2F2018%2F07%2F15%2FCQOI2007-%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[k\ mod \ i=k-\left \lfloor \frac{k}{i} \right \rfloor*i \sum_{i=1}^{n}k \ mod \ i=\sum_{i=1}^{n}\left ( k-\left \lfloor \frac{k}{i} \right \rfloor*i \right )=nk-\sum_{i=1}^{n}\left ( \left \lfloor \frac{k}{i} \right \rfloor*i \right )分块求解即可12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;LL n,k,ans=0;int main()&#123; scanf("%lld%lld",&amp;n,&amp;k); LL sz=sqrt(k); for(LL i=1;k/i&gt;sz;i++) ans-=i*(k/i); for(LL i=sz;i&gt;=1;i--) &#123; LL L=k/(i+1)+1,R=min(n,k/i); ans-=(L+R)*(R-L+1)/2*i; &#125; printf("%lld",ans+n*k); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流模板集合]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A8%A1%E6%9D%BF%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[EK 动能算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int M=100050,N=10050,INF=1&lt;&lt;25;int n,m,st,ed,head[N],cnt=0,pre[N],d[N];struct edge&#123;int to,next,flow,cap;&#125; e[M&lt;&lt;1];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int cap)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt++].cap=cap; &#125;void update(int x,int to,int flow)&#123; for(int i=x;i!=to;i=e[pre[i]^1].to) &#123; e[pre[i]].flow+=flow; e[pre[i]^1].flow-=flow; &#125; &#125;int bfs(int s,int t)&#123; while (!Q.empty()) Q.pop(); for(int i=1;i&lt;=n;i++) d[i]=0; d[s]=INF,Q.push(s); while (!Q.empty()&amp;&amp;!d[t]) &#123; int x=Q.front();Q.pop(); for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (!d[to]&amp;&amp;e[i].flow&lt;e[i].cap) &#123; pre[to]=i; d[to]=min(d[x],e[i].cap-e[i].flow); Q.push(to); &#125; &#125; &#125; return d[t];&#125;int EK(int s,int t)&#123; int ret=0,new_flow; while (new_flow=bfs(s,t)) &#123; ret+=new_flow; update(t,s,new_flow); &#125; return ret;&#125;int main()&#123; n=read(),m=read(); st=read(),ed=read(); for(int i=1;i&lt;=n;i++) head[i]=-1; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); add(u,v,read()); add(v,u,0); &#125; printf("%d",EK(st,ed)); return 0; &#125; Dinic 比EK快很多的Dinic12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int M=120050,N=10050,INF=1&lt;&lt;25;int n,m,st,ed,head[N],cnt=0,d[N],cur[N];struct edge&#123;int to,next,flow,cap;&#125; e[M&lt;&lt;1];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int cap)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt++].cap=cap; &#125;int bfs(int s,int t)&#123; while (!Q.empty()) Q.pop(); for(int i=1;i&lt;=n;i++) d[i]=0; d[s]=1,Q.push(s); while (!Q.empty()&amp;&amp;!d[t]) &#123; int x=Q.front();Q.pop(); for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (e[i].flow&lt;e[i].cap&amp;&amp;!d[to]) &#123; d[to]=d[x]+1; Q.push(to); &#125; &#125; &#125; return d[t];&#125;int dfs(int x,int t,int flow)&#123; if (!flow||x==t) return flow; int ret=0,new_flow; for(int &amp;i=cur[x];~i&amp;&amp;flow;i=e[i].next) &#123; int to=e[i].to; if (d[x]+1==d[to]) &#123; new_flow=dfs(to,t,min(flow,e[i].cap-e[i].flow)); e[i].flow+=new_flow; e[i^1].flow-=new_flow; ret+=new_flow; flow-=new_flow; &#125; &#125; return ret; &#125;int Dinic(int s,int t)&#123; int ret=0; while (bfs(s,t)) &#123; for(int i=1;i&lt;=n;i++) cur[i]=head[i]; ret+=dfs(s,t,INF); &#125; return ret;&#125;int main()&#123; n=read(),m=read(); st=read(),ed=read(); for(int i=1;i&lt;=n;i++) head[i]=-1; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); add(u,v,read()); add(v,u,0); &#125; printf("%d",Dinic(st,ed)); return 0; &#125; ISAP ISAP+GAP优化+当前弧优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int M=100050,N=10050,INF=1&lt;&lt;25;int n,m,st,ed,head[N],cnt=0,d[N],num[N],pre[N],cur[N];struct edge&#123;int to,next,flow,cap;&#125; e[M&lt;&lt;1];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int cap)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt++].cap=cap; &#125;void bfs(int s)&#123; for(int i=1;i&lt;=n;i++) d[i]=n; d[s]=0,Q.push(s); while (!Q.empty()) &#123; int x=Q.front();Q.pop(); for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (d[x]+1&lt;d[to]&amp;&amp;e[i^1].cap) &#123; d[to]=d[x]+1; Q.push(to); &#125; &#125; &#125;&#125;int update(int x,int to)&#123; int ret=INF; for(int i=x;i!=to;i=e[pre[i]^1].to) ret=min(ret,e[pre[i]].cap-e[pre[i]].flow); for(int i=x;i!=to;i=e[pre[i]^1].to) &#123; e[pre[i]].flow+=ret; e[pre[i]^1].flow-=ret; &#125; return ret;&#125;int ISAP(int s,int t)&#123; bfs(t); for(int i=1;i&lt;=n;i++) num[d[i]]++; for(int i=1;i&lt;=n;i++) cur[i]=head[i]; int ret=0,x=s; while (d[s]&lt;=n) &#123; if (x==t) ret+=update(t,s),x=s; int flag=0; for(int i=cur[x];~i;i=e[i].next) &#123; int to=e[i].to; if (d[x]==d[to]+1&amp;&amp;e[i].flow&lt;e[i].cap) &#123; flag=1,cur[x]=i; pre[x=to]=i; break; &#125; &#125; if (!flag) &#123; int idx=n-1; for(int i=head[x];~i;i=e[i].next) if (e[i].flow&lt;e[i].cap) idx=min(idx,d[e[i].to]); if (--num[d[x]]==0) break; num[d[x]=idx+1]++; cur[x]=head[x]; if (x!=s) x=e[pre[x]^1].to; &#125; &#125; return ret;&#125;int main()&#123; n=read(),m=read(); st=read(),ed=read(); for(int i=1;i&lt;=n;i++) head[i]=-1; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); add(u,v,read()); add(v,u,0); &#125; printf("%d",ISAP(st,ed)); return 0; &#125; 最小费用最大流 Min_Cost_Max_Flow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int M=50050,N=5050,INF=1&lt;&lt;25;int n,m,st,ed,head[N],cnt=0,pre[N],d[N],c[N],cost=0,inq[N];struct edge&#123;int to,next,flow,cap,cost;&#125; e[M&lt;&lt;1];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int cap,int cost)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].cost=cost; e[cnt++].cap=cap; &#125;void update(int x,int to,int flow)&#123; for(int i=x;i!=to;i=e[pre[i]^1].to) &#123; e[pre[i]].flow+=flow; e[pre[i]^1].flow-=flow; &#125; &#125;int SPFA(int s,int t)&#123; for(int i=1;i&lt;=n;i++) d[i]=INF,c[i]=0; d[s]=0,c[s]=INF,Q.push(s); while (!Q.empty()) &#123; int x=Q.front(); Q.pop(),inq[x]=0; for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to,cost=e[i].cost; if (e[i].flow&lt;e[i].cap&amp;&amp;d[x]+cost&lt;d[to]) &#123; d[to]=d[x]+cost; pre[to]=i; c[to]=min(c[x],e[i].cap-e[i].flow); if (!inq[to]) Q.push(to),inq[to]=1; &#125; &#125; &#125; return c[t];&#125;int MCMF(int s,int t)&#123; int ret=0,new_flow; while (new_flow=SPFA(s,t)) &#123; ret+=new_flow; cost+=new_flow*d[t]; update(t,s,new_flow); &#125; return ret;&#125;int main()&#123; n=read(),m=read(); st=read(),ed=read(); for(int i=1;i&lt;=n;i++) head[i]=-1; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); int cap=read(),cost=read(); add(u,v,cap,cost); add(v,u,0,-cost); &#125; int max_flow=MCMF(st,ed); printf("%d %d",max_flow,cost); return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1108 低价购买]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%B4%9B%E8%B0%B7P1108-%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[dp 数组记录方案数，f 数组记录购买次数 dp\left [ i \right ]=\sum_{j=1}^{i-1}dp\left [ j \right ] \ \ \ \left ( f\left [ j \right ]+1=f\left [ i \right ] ,w\left [ j \right ]]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2015]线性代数]]></title>
    <url>%2F2018%2F07%2F13%2FTJOI2015-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[首先要看得懂题目同时取A 中的i,j 两点可获得b\left [ i \right ]\left [j \right ]+b\left [ j \right ]\left [i \right ]，但要减去c\left [ i \right ]+c\left [ j \right ]记edge\left \{ u,v,capacity,cost \right \}为一条从u 到v 的，流量为cap 的，费用为cost 的弧与反弧转化成最小割对于B 中每个二元组\left ( i,j \right )，连边edge\left \{ S,\left ( i,j \right ), b\left [ i \right ]\left [j \right ]+b\left [ j \right ]\left [i \right ]\right \}，edge\left \{ \left ( i,j \right ),i, INF\right \}和edge\left \{ \left ( i,j \right ),j, INF\right \}i= j 的情况需要特殊处理对于C 中的第k 个元素，连边edge\left \{ k,T, c\left [ k \right ]\right \} 关于网络流，应该在这里就要暂告一段落了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int M=500050,N=1005,INF=1&lt;&lt;25;int n,sum=0,st,ed,w[N][N],c[N];int head[N*N],cnt=0,d[N*N],cur[N*N];struct edge&#123;int to,next,flow,cap;&#125; e[M&lt;&lt;1];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int F(int x,int y)&#123;return (x-1)*n+y;&#125;void add(int u,int v,int cap)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt++].cap=cap; &#125;int bfs(int s,int t)&#123; while (!Q.empty()) Q.pop(); for(int i=1;i&lt;=n*n+n+2;i++) d[i]=0; d[s]=1,Q.push(s); while (!Q.empty()&amp;&amp;!d[t]) &#123; int x=Q.front();Q.pop(); for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (e[i].flow&lt;e[i].cap&amp;&amp;!d[to]) &#123; d[to]=d[x]+1; Q.push(to); &#125; &#125; &#125; return d[t];&#125;int dfs(int x,int t,int flow)&#123; if (!flow||x==t) return flow; int ret=0,new_flow; for(int &amp;i=cur[x];~i&amp;&amp;flow;i=e[i].next) &#123; int to=e[i].to; if (d[x]+1==d[to]) &#123; new_flow=dfs(to,t,min(flow,e[i].cap-e[i].flow)); e[i].flow+=new_flow; e[i^1].flow-=new_flow; ret+=new_flow; flow-=new_flow; &#125; &#125; return ret;&#125;int Dinic(int s,int t)&#123; int ret=0; while (bfs(s,t)) &#123; for(int i=1;i&lt;=n*n+n+2;i++) cur[i]=head[i]; ret+=dfs(s,t,INF); &#125; return ret;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) sum+=w[i][j]=read(); for(int i=1;i&lt;=n;i++) c[i]=read(); st=n*n+n+1,ed=st+1; for(int i=1;i&lt;=n*n+n+2;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) &#123; add(st,F(i,j),w[i][j]+w[j][i]); add(F(i,j),st,0); add(F(i,j),n*n+i,INF); add(n*n+i,F(i,j),0); add(F(i,j),n*n+j,INF); add(n*n+j,F(i,j),0); &#125; for(int i=1;i&lt;=n;i++) &#123; add(st,F(i,i),w[i][i]); add(F(i,i),st,0); add(F(i,i),n*n+i,INF); add(n*n+i,F(i,i),0); &#125; for(int i=1;i&lt;=n;i++) &#123; add(n*n+i,ed,c[i]); add(ed,n*n+i,0); &#125; printf("%d\n",sum-Dinic(st,ed)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3355 骑士共存问题]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%B4%9B%E8%B0%B7P3355-%E9%AA%91%E5%A3%AB%E5%85%B1%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[和上一题一样的套路最多骑士数=总骑士数-最少拿走的骑士数二染色之后构图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=205,M=800000,INF=1&lt;&lt;25;const int dx[]=&#123;-2,-2,-1,-1,1,1,2,2&#125;;const int dy[]=&#123;1,-1,2,-2,2,-2,1,-1&#125;;int n,m,st,ed,used[N][N],head[N*N],cnt=0,cur[N*N],d[N*N];struct edge&#123;int to,next,cap,flow;&#125; e[M];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int F(int x,int y) &#123;return n*(x-1)+y;&#125;void add(int u,int v,int cap)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt++].cap=cap;&#125;int bfs(int s,int t)&#123; while (!Q.empty()) Q.pop(); for(int i=1;i&lt;=n*n+2;i++) d[i]=0; d[s]=1,Q.push(s); while (!Q.empty()&amp;&amp;!d[t]) &#123; int x=Q.front();Q.pop(); for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (e[i].flow&lt;e[i].cap&amp;&amp;!d[to]) &#123; d[to]=d[x]+1; Q.push(to); &#125; &#125; &#125; return d[t];&#125;int dfs(int x,int t,int flow)&#123; if (!flow||x==t) return flow; int ret=0,new_flow; for(int&amp; i=cur[x];~i&amp;&amp;flow;i=e[i].next) &#123; int to=e[i].to; if (d[x]+1==d[to]) &#123; new_flow=dfs(to,t,min(flow,e[i].cap-e[i].flow)); e[i].flow+=new_flow; e[i^1].flow-=new_flow; ret+=new_flow; flow-=new_flow; &#125; &#125; return ret;&#125;int Dinic(int s,int t)&#123; int ret=0; while (bfs(s,t)) &#123; for(int i=1;i&lt;=n*n+2;i++) cur[i]=head[i]; ret+=dfs(s,t,INF); &#125; return ret;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int x=read(),y=read(); used[x][y]=1; &#125; st=n*n+1,ed=n*n+2; for(int i=1;i&lt;=n*n+2;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if (!used[i][j]) &#123; int idx=F(i,j); if ((i+j)&amp;1) &#123; add(st,idx,1),add(idx,st,0); for(int k=0;k&lt;8;k++) &#123; int x=i+dx[k],y=j+dy[k]; if (0&lt;x&amp;&amp;x&lt;=n&amp;&amp;0&lt;y&amp;&amp;y&lt;=n) if (!used[x][y]) &#123; add(idx,F(x,y),INF); add(F(x,y),idx,0); &#125; &#125; &#125; else add(idx,ed,1),add(ed,idx,0); &#125; printf("%d",n*n-m-Dinic(st,ed)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2774 方格取数问题]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%B4%9B%E8%B0%B7P2774-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最大和=全局和-舍弃和，而舍弃和=最小割=最大流记edge\left \{ u,v,capacity,cost \right \}​为一条从u 到v 的，流量为cap 的，费用为cost 的弧与反弧将图二染色对于每个黑点u ，连边 edge\left \{ S,u,w\left [ u \right ] \right \}对于每个白点v ，连边edge\left \{ v,T,w\left [ v \right ] \right \}对于每个黑点u ，像周围白点v 连边edge\left \{ u,v,INF \right \}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=105,M=100000,INF=1&lt;&lt;30;const int dx[]=&#123;0,0,1,-1&#125;;const int dy[]=&#123;1,-1,0,0&#125;;int n,m,st,ed,sum=0,w[N][N];int cnt=0,head[N*N],d[N*N],cur[N*N];struct edge&#123;int to,next,flow,cap;&#125; e[M&lt;&lt;1];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int F(int x,int y)&#123;return m*(x-1)+y;&#125;void add(int u,int v,int cap)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt++].cap=cap; &#125;int bfs(int s,int t)&#123; while (!Q.empty()) Q.pop(); for(int i=1;i&lt;=n*m+2;i++) d[i]=0; d[s]=1,Q.push(s); while (!Q.empty()) &#123; int x=Q.front();Q.pop(); for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (e[i].flow&lt;e[i].cap&amp;&amp;!d[to]) &#123; d[to]=d[x]+1; Q.push(to); &#125; &#125; &#125; return d[t];&#125;int dfs(int x,int t,int flow)&#123; if (!flow||x==t) return flow; int ret=0,new_flow; for(int &amp;i=cur[x];~i&amp;&amp;flow;i=e[i].next) &#123; int to=e[i].to; if (d[x]+1==d[to]) &#123; new_flow=dfs(to,t,min(flow,e[i].cap-e[i].flow)); e[i].flow+=new_flow; e[i^1].flow-=new_flow; ret+=new_flow; flow-=new_flow; &#125; &#125; return ret;&#125;int Dinic(int s,int t)&#123; int ret=0; while (bfs(s,t)) &#123; for(int i=1;i&lt;=n*m+2;i++) cur[i]=head[i]; ret+=dfs(s,t,INF); &#125; return ret;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum+=w[i][j]=read(); st=n*m+1,ed=st+1; for(int i=1;i&lt;=n*m+2;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if ((i+j)&amp;1) &#123; add(st,F(i,j),w[i][j]); add(F(i,j),st,0); for(int k=0;k&lt;4;k++) &#123; int x=i+dx[k],y=j+dy[k]; if (0&lt;x&amp;&amp;x&lt;=n&amp;&amp;0&lt;y&amp;&amp;y&lt;=m) &#123; add(F(i,j),F(x,y),INF); add(F(x,y),F(i,j),0); &#125; &#125; &#125; else &#123; add(F(i,j),ed,w[i][j]); add(ed,F(i,j),0); &#125; printf("%d\n",sum-Dinic(st,ed)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4014 分配问题]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%B4%9B%E8%B0%B7P4014-%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记edge\left \{ u,v,capacity,cost \right \}为一条从u 到v 的，流量为cap 的，费用为cost 的弧与反弧源点向每件工作连边edge\left \{ S,x,1,0 \right \}按惯例人当做两个用，第k 个人连边edge\left \{ k,k+n,1,0 \right \}，edge\left \{ k+n,T,INF,0 \right \}每件工作x 向第k 个人连边edge\left \{ x,k,1,c\left [ x \right ]\left [ k \right ] \right \}跑一遍MCMF，边权取反再跑一遍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=505,M=100000,INF=1&lt;&lt;30;int n,st,ed,w[N][N],cost;int head[N],pre[N],c[N],cnt=0,d[N],inq[N];struct edge&#123;int to,next,cap,flow,cost;&#125; e[M&lt;&lt;1];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int cap,int cost)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].cost=cost; e[cnt++].cap=cap; &#125;int SPFA(int s,int t)&#123; for(int i=1;i&lt;=n*3+2;i++) d[i]=INF,c[i]=0; d[s]=0,c[s]=INF,Q.push(s); while (!Q.empty()) &#123; int x=Q.front(); Q.pop(),inq[x]=0; for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to,cost=e[i].cost; if (e[i].flow&lt;e[i].cap&amp;&amp;d[x]+cost&lt;d[to]) &#123; d[to]=d[x]+cost; c[to]=min(c[x],e[i].cap-e[i].flow); pre[to]=i; if (!inq[to]) Q.push(to),inq[to]=1; &#125; &#125; &#125; return c[t];&#125;void update(int x,int to,int flow)&#123; for(int i=x;i!=to;i=e[pre[i]^1].to) &#123; e[pre[i]].flow+=flow; e[pre[i]^1].flow-=flow; &#125;&#125;int MCMF(int s,int t)&#123; cost=0; int ret=0,new_flow; while (new_flow=SPFA(s,t)) &#123; ret+=new_flow; cost+=new_flow*d[t]; update(t,s,new_flow); &#125; return ret;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) w[i][j]=read(); st=n*3+1,ed=st+1; for(int i=1;i&lt;=n*3+2;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) add(st,i,1,0),add(i,st,0,0); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; add(j,i+n,1,w[i][j]); add(i+n,j,0,-w[i][j]); &#125; for(int i=n+1;i&lt;=n*2;i++) add(i,i+n,1,0),add(i+n,i,0,0); for(int i=n*2+1;i&lt;=n*3;i++) add(i,ed,INF,0),add(ed,i,0,0); MCMF(st,ed); printf("%d\n",cost); for(int i=1;i&lt;=n*3+2;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) add(st,i,1,0),add(i,st,0,0); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; add(j,i+n,1,-w[i][j]); add(i+n,j,0,w[i][j]); &#125; for(int i=n+1;i&lt;=n*2;i++) add(i,i+n,1,0),add(i+n,i,0,0); for(int i=n*2+1;i&lt;=n*3;i++) add(i,ed,INF,0),add(ed,i,0,0); MCMF(st,ed); printf("%d\n",-cost); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1175 表达式的转换]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%B4%9B%E8%B0%B7P1175-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[优化了一下之前的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N=200;char str[N],expr[N];int n,len,idx[N],cnt=0;stack&lt;char&gt; opt;deque&lt;int&gt; num;deque&lt;int&gt;::iterator it;void init()&#123; idx['+']=idx['-']=1; idx['*']=idx['/']=2; idx['^']=3;&#125;void trans()&#123; for(int i=1;i&lt;=len;i++) &#123; if ('0'&lt;=str[i]&amp;&amp;str[i]&lt;='9') expr[++cnt]=str[i]; else &#123; if (!idx[str[i]]) &#123; if (str[i]=='(') opt.push(str[i]); if (str[i]==')') &#123; while (opt.top()!='(') expr[++cnt]=opt.top(),opt.pop(); opt.pop(); &#125; &#125; else &#123; while (!opt.empty()&amp;&amp;idx[opt.top()]&gt;=idx[str[i]]) expr[++cnt]=opt.top(),opt.pop(); opt.push(str[i]); &#125; &#125; &#125; while (!opt.empty()) expr[++cnt]=opt.top(),opt.pop();&#125;void print(int k)&#123; for(it=num.begin();it!=num.end();it++) printf("%d%c",*it,k&gt;cnt?'\n':' '); for(int i=k;i&lt;=cnt;i++) printf("%c%c",expr[i],i==cnt?'\n':' ');&#125;int pow(int a,int b)&#123; int ret=1; while (b) &#123; if (b&amp;1) ret*=a; a*=a,b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; init(); scanf("%s",str+1); len=strlen(str+1); trans(); print(1); for(int i=1;i&lt;=cnt;i++) &#123; if ('0'&lt;=expr[i]&amp;&amp;expr[i]&lt;='9') num.push_back(expr[i]-'0'); else &#123; int b=num.back();num.pop_back(); int a=num.back();num.pop_back(); switch (expr[i]) &#123; case '+':num.push_back(a+b);break; case '-':num.push_back(a-b);break; case '*':num.push_back(a*b);break; case '/':num.push_back(a/b);break; default:num.push_back(pow(a,b)); &#125; print(i+1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4015 运输问题]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B4%9B%E8%B0%B7P4015-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记edge\left \{ u,v,capacity,cost \right \}为一条从u 到v 的，流量为cap 的，费用为cost 的弧与反弧对于每个仓库连边edge\left \{ S,x,u\left [ x \right ],0 \right \}对于每个零售店连边edge\left \{ x+n,T,v\left [ x \right ],0 \right \}仓库i 向零售店j 连边edge\left \{ i,j+n,INF,c\left [ i \right ]\left [ j \right ] \right \}跑一边S 到T 的MCMF，cost为最小运输费用边权取负，再跑一边S 到T 的MCMF，-cost为最大运输费用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int M=10000,N=205,INF=1&lt;&lt;30;int n,m,st,ed,u[N],v[N],val[N][N];int head[N],cnt=0,pre[N],d[N],c[N],cost=0,inq[N];struct edge&#123;int to,next,flow,cap,cost;&#125; e[M&lt;&lt;2];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int cap,int cost)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].cost=cost; e[cnt++].cap=cap; &#125;void update(int x,int to,int flow)&#123; for(int i=x;i!=to;i=e[pre[i]^1].to) &#123; e[pre[i]].flow+=flow; e[pre[i]^1].flow-=flow; &#125; &#125;int SPFA(int s,int t)&#123; for(int i=1;i&lt;=n+m+2;i++) d[i]=INF,c[i]=0; d[s]=0,c[s]=INF,Q.push(s); while (!Q.empty()) &#123; int x=Q.front(); Q.pop(),inq[x]=0; for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to,cost=e[i].cost; if (e[i].flow&lt;e[i].cap&amp;&amp;d[x]+cost&lt;d[to]) &#123; d[to]=d[x]+cost; pre[to]=i; c[to]=min(c[x],e[i].cap-e[i].flow); if (!inq[to]) Q.push(to),inq[to]=1; &#125; &#125; &#125; return c[t];&#125;int MCMF(int s,int t)&#123; cost=0; int ret=0,new_flow; while (new_flow=SPFA(s,t)) &#123; ret+=new_flow; cost+=new_flow*d[t]; update(t,s,new_flow); &#125; return ret;&#125;int main()&#123; n=read(),m=read(); st=n+m+1,ed=st+1; for(int i=1;i&lt;=n+m+2;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) &#123; u[i]=read(); add(st,i,u[i],0); add(i,st,0,0); &#125; for(int i=1;i&lt;=m;i++) &#123; v[i]=read(); add(i+n,ed,v[i],0); add(ed,i+n,0,0); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; val[i][j]=read(); add(i,j+n,INF,val[i][j]); add(j+n,i,0,-val[i][j]); &#125; MCMF(st,ed); printf("%d\n",cost); for(int i=1;i&lt;=n+m+2;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) &#123; add(st,i,u[i],0); add(i,st,0,0); &#125; for(int i=1;i&lt;=m;i++) &#123; add(i+n,ed,v[i],0); add(ed,i+n,0,0); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; add(i,j+n,INF,-val[i][j]); add(j+n,i,0,val[i][j]); &#125; MCMF(st,ed); printf("%d",-cost); return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4016 负载平衡问题]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B4%9B%E8%B0%B7P4016-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这题的另一种做法（传送门）记edge\left \{ u,v,capacity,cost \right \}为一条从u 到v 的，流量为cap 的，费用为cost 的弧与反弧记ave 为平均值对于每个点x若w\left [ x \right ]-ave>0，则连边edge\left \{ S,x,w\left [ x \right ]-ave,0 \right \}若w\left [ x \right ]-ave]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2008]糖果传递]]></title>
    <url>%2F2018%2F07%2F10%2FHAOI2008-%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[环形均分纸牌对于非环形均分纸牌，记s\left [ i \right ]为前i项的和，ave 为平均数可得交换数量为 \sum_{i=1}^{n}\left | \left ( i*ave-s\left [ i \right ] \right ) \right |记S\left [ i \right ]为前i项，每项减去ave 的和则交换数量为 \sum_{i=1}^{n}\left | \left ( S\left [ i \right ] \right ) \right |对于环形均分纸牌，设在第k 个人处断开则S\left [ \right ]为 S\left [ k +1\right ]-S\left [ k \right ],S\left [ k +2\right ]-S\left [ k+1 \right ]...S\left [ n\right ]-S\left [ k \right ],S\left [ 1 \right ]+S\left [ n\right ]-S\left [ k \right ]...S\left [ k \right ]+S\left [ n\right ]-S\left [ k \right ]根据定义可得S\left [ n \right ]=0总交换数量为 \sum_{i=1}^{n}\left | S\left [ i \right ] -S\left [ k \right ]\right |取中位数即可12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=1000050;int n,w[N];LL sum=0,s[N],ans=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),sum+=w[i]; int ave=sum/n; for(int i=1;i&lt;=n;i++) w[i]-=ave; for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+w[i]; sort(s+1,s+n+1); for(int i=1;i&lt;=n;i++) ans+=abs(s[i]-s[(n+1)/2]); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1402 酒店之王]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B4%9B%E8%B0%B7P1402-%E9%85%92%E5%BA%97%E4%B9%8B%E7%8E%8B%2F</url>
    <content type="text"><![CDATA[记edge\left \{ u,v,capacity,cost \right \}为一条从u 到v 的，流量为cap 的，费用为cost 的弧与反弧源点向每个房间连边edge\left \{ S,x,1 \right \}每道菜向汇点连边edge\left \{ x+n*2+p,T,1 \right \}每个人拆成两个用，x+p 与房间连边，x+p+n 与菜连边当第k 个人喜欢第x 个房间，连边edge\left \{ x,k+p,1 \right \}当第k 个人喜欢第x 道菜，连边edge\left \{ k+n+p,x+n*2+p,1 \right \}跑一边S 到T 的最大流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=405,M=50050,INF=1&lt;&lt;25;int n,p,q,st,ed,head[N],d[N],cnt=0;struct edge&#123;int to,next,flow,cap;&#125; e[M];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int cap)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt++].cap=cap; &#125;int bfs(int s,int t)&#123; while (!Q.empty()) Q.pop(); for(int i=1;i&lt;=n*2+p+q+2;i++) d[i]=0; d[s]=1,Q.push(s); while (!Q.empty()&amp;&amp;!d[t]) &#123; int x=Q.front();Q.pop(); for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (e[i].flow&lt;e[i].cap&amp;&amp;!d[to]) &#123; d[to]=d[x]+1; Q.push(to); &#125; &#125; &#125; return d[t];&#125;int dfs(int x,int t,int flow)&#123; if (!flow||x==t) return flow; int ret=0,new_flow; for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (d[x]+1==d[to]) &#123; new_flow=dfs(to,t,min(flow,e[i].cap-e[i].flow)); e[i].flow+=new_flow; e[i^1].flow-=new_flow; ret+=new_flow; flow-=new_flow; &#125; &#125; return ret;&#125;int Dinic(int s,int t)&#123; int ret=0; while (bfs(s,t)) ret+=dfs(s,t,INF); return ret;&#125;int main()&#123; n=read(),p=read(),q=read(); st=n*2+p+q+1,ed=st+1; for(int i=1;i&lt;=2*n+p+q+2;i++) head[i]=-1; for(int i=1;i&lt;=p;i++) add(st,i,1),add(i,st,0); for(int i=n*2+p+1;i&lt;=n*2+p+q;i++) add(i,ed,1),add(ed,i,0); for(int i=p+1;i&lt;=p+n;i++) add(i,i+n,1),add(i+n,i,0); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) &#123; int x=read(); if (!x) continue; add(j,p+i,1); add(p+i,j,0); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=q;j++) &#123; int x=read(); if (!x) continue; add(p+n+i,n*2+p+j,1); add(n*2+p+j,p+n+i,0); &#125; printf("%d",Dinic(st,ed)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO5.4]奶牛的电信Telecowmunication]]></title>
    <url>%2F2018%2F07%2F10%2FUSACO5-4-%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication%2F</url>
    <content type="text"><![CDATA[记edge\left \{ u,v,capacity,cost \right \}为一条从u 到v 的，流量为cap 的，费用为cost 的弧与反弧拆点，对于点x，分为x 和x+n 两点，x 负责流入，x+n 负责流出对于每个点连边edge\left \{ x,x+n,1 \right \}对于原图每条连接u,v 的边，连边edge\left \{ u+n,v,INF \right \}，edge\left \{ v+n,u,INF \right \}跑一边s+n 到t 的最大流最大流最小割1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int M=10000,N=500,INF=1&lt;&lt;25;int n,m,st,ed,head[N],cnt=0,d[N];struct edge&#123;int to,next,flow,cap;&#125; e[M];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void add(int u,int v,int cap)&#123; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt++].cap=cap; &#125;int bfs(int s,int t)&#123; while (!Q.empty()) Q.pop(); for(int i=1;i&lt;=(n&lt;&lt;1);i++) d[i]=0; d[s]=1,Q.push(s); while (!Q.empty()&amp;&amp;!d[t]) &#123; int x=Q.front();Q.pop(); for(int i=head[x];~i;i=e[i].next) &#123; int to=e[i].to; if (!d[to]&amp;&amp;e[i].flow&lt;e[i].cap) &#123; d[to]=d[x]+1; Q.push(to); &#125; &#125; &#125; return d[t];&#125;int dfs(int x,int t,int flow)&#123; if (!flow||x==t) return flow; int ret=0,new_flow; for(int i=head[x];~i&amp;&amp;flow;i=e[i].next) &#123; int to=e[i].to; if (d[x]+1==d[to]) &#123; new_flow=dfs(to,t,min(flow,e[i].cap-e[i].flow)); e[i].flow+=new_flow; e[i^1].flow-=new_flow; ret+=new_flow; flow-=new_flow; &#125; &#125; return ret; &#125;int Dinic(int s,int t)&#123; int ret=0; while (bfs(s,t)) ret+=dfs(s,t,INF); return ret;&#125;int main()&#123; n=read(),m=read(); st=read(),ed=read(); for(int i=1;i&lt;=n;i++) head[i]=-1; for(int i=1;i&lt;=n;i++) &#123; add(i,i+n,1); add(i+n,i,0); &#125; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); add(u+n,v,INF); add(v,u+n,0); add(v+n,u,INF); add(u,v+n,0); &#125; printf("%d",Dinic(st+n,ed)); return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2009]Elaxia的路线]]></title>
    <url>%2F2018%2F07%2F10%2FSDOI2009-Elaxia%E7%9A%84%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[记E 为Elaxia 的最短路DAG，W 为w 的最短路DAG根据W 重构E 每条边的权值对于连接u，v，权值为val的边当且仅当在W 中d\left [ u \right ]+val= d\left [ v \right ]或d\left [ v \right ]+val= d\left [ u\right ]时，边权为val，否则为0在E 上跑一边最长路得出答案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int N=2000,INF=1&lt;&lt;25;int n,m,st[2],ed[2],d[2][N],inq[N],used[N],dp[N];vector&lt;int&gt; f[N],g[N],w[2][N],e[2][N],c[N];queue&lt;int&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;void SPFA(int s,int k)&#123; for(int i=1;i&lt;=n;i++) d[k][i]=INF,inq[i]=0; d[k][s]=0,inq[s]=1,Q.push(s); while (!Q.empty()) &#123; int x=Q.front(); Q.pop(),inq[x]=0; for(int i=0;i&lt;f[x].size();i++) &#123; int to=f[x][i],val=g[x][i]; if (d[k][x]+val==d[k][to]) e[k][to].push_back(x),w[k][to].push_back(val); if (d[k][x]+val&lt;d[k][to]) &#123; e[k][to].clear(); e[k][to].push_back(x); w[k][to].clear(); w[k][to].push_back(val); d[k][to]=d[k][x]+val; if (!inq[to]) Q.push(to),inq[to]=1; &#125; &#125; &#125;&#125;void add(int u,int v,int val)&#123; g[u].push_back(val); f[u].push_back(v);&#125;void dfs(int o,int x)&#123; if (used[o]) return; used[o]=1; if (o==x) return; for(int i=0;i&lt;e[1][o].size();i++) dfs(e[1][o][i],x); &#125;int calc(int o,int x)&#123; if (dp[o]!=-1) return dp[o]; if (o==x) return dp[o]=0; for(int i=0;i&lt;e[0][o].size();i++) dp[o]=max(dp[o],calc(e[0][o][i],x)+c[o][i]); return dp[o]; &#125;int main()&#123; n=read(),m=read(); for(int i=0;i&lt;2;i++) st[i]=read(),ed[i]=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(),val=read(); add(u,v,val),add(v,u,val); &#125; for(int i=0;i&lt;2;i++) SPFA(st[i],i); dfs(ed[1],st[1]); for(int i=1;i&lt;=n;i++) if (!used[i]) d[1][i]=INF; for(int u=1;u&lt;=n;u++) for(int i=0;i&lt;e[0][u].size();i++) &#123; int v=e[0][u][i],f=0; if (d[1][u]+w[0][u][i]==d[1][v]) f++; if (d[1][v]+w[0][u][i]==d[1][u]) f++; c[u].push_back(f*w[0][u][i]); &#125; for(int i=1;i&lt;=n;i++) dp[i]=-1; printf("%d",calc(ed[0],st[0])); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1384 幸运数与排列]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B4%9B%E8%B0%B7P1384-%E5%B9%B8%E8%BF%90%E6%95%B0%E4%B8%8E%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[观察到k\leq 10^{9}< 13!对于过大的n，至多只有最后13位会变对于会变得位置求Cantor展开，然后直接计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#define LL long longusing namespace std;const int N=15;int n,m,w[N],used[N],ans=0,tot;LL fact[N]=&#123;1&#125;;int get(int k)&#123; for(int i=1,num=0;i&lt;=tot;i++) &#123; if (!used[i]) num++; if (num==k) return i; &#125; &#125;int work(int x)&#123; if (!x) return 0; for(;x;x/=10) if (x%10!=7&amp;&amp;x%10!=4) return 0; return 1;&#125;void check()&#123; LL num=1; for(int i=1;i&lt;=n;i++) &#123; num*=i; if (num&gt;=m) return; &#125; puts("-1"),exit(0);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); check(); for(int i=1;i&lt;N;i++) fact[i]=fact[i-1]*i; for(int i=0;i&lt;N;i++) if (fact[i]&gt;=m) &#123;tot=i;break;&#125; m--; for(int i=tot;i&gt;0;i--) &#123; w[tot-i+1]=get(m/fact[i-1]+1)+n-tot; used[w[tot-i+1]-n+tot]=1,m%=fact[i-1]; &#125; for(int len=1;len&lt;N;len++) for(int i=0;i&lt;(1&lt;&lt;len);i++) &#123; LL num=0; for(int j=1;j&lt;=len;j++) num=num*10+((i&gt;&gt;(j-1))&amp;1?7:4); if (num&gt;n) continue; ans+=work(num+tot&lt;=n?num:w[num-n+tot]); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元]]></title>
    <url>%2F2018%2F07%2F10%2F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[若ax\equiv 1\left ( mod \ p \right )，则称x，a 互为mod p 意义下的逆元 扩展欧几里得算法ax\equiv 1\left ( mod \ p \right )\Leftrightarrow ax+py=1若gcd\left ( a,p \right )\neq 1则无解 123456void exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if (!b) &#123;x=1,y=0;return;&#125; exgcd(b,a%b,y,x); y-=a/b*x; &#125; 费马小定理若p 为质数，则a^{p}\equiv a\left ( mod \ p \right ) x\equiv a^{p-2}\left ( mod \ p \right ) 欧拉定理若gcd\left ( a,p \right )=1，则a^{\varphi\left ( p \right )}\equiv 1\left ( mod \ p \right ) x\equiv a^{\varphi\left ( p \right )-1}\left ( mod \ p \right ) 线性递推设p=k*i+r，其中\left ( r]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2709 小B的询问]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B4%9B%E8%B0%B7P2709-%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE%2F</url>
    <content type="text"><![CDATA[数据不大直接上莫队123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int N=50050;struct query&#123; int ql,qr,id;&#125; q[N];int cnt[N],w[N],num,n,m,k;LL ans[N],sum=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;void add(int k)&#123; sum-=cnt[w[k]]*cnt[w[k]]; cnt[w[k]]++; sum+=cnt[w[k]]*cnt[w[k]];&#125;void del(int k)&#123; sum-=cnt[w[k]]*cnt[w[k]]; cnt[w[k]]--; sum+=cnt[w[k]]*cnt[w[k]];&#125;bool cmp(query a, query b)&#123; return a.ql/num==b.ql/num? a.qr&lt;b.qr:a.ql&lt;b.ql;&#125;int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); num=sqrt(n); for(int i=1;i&lt;=m;i++) q[i].ql=read(),q[i].qr=read(),q[i].id=i; sort(q+1,q+m+1,cmp); int L=0,R=0; for(int i=1;i&lt;=m;i++) &#123; int ql=q[i].ql,qr=q[i].qr; while (L&lt;ql) del(L++); while (R&gt;qr) del(R--); while (L&gt;ql) add(--L); while (R&lt;qr) add(++R); ans[q[i].id]=sum; &#125; for(int i=1;i&lt;=m;i++) printf("%d\n",ans[i]-1); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]沙僧]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E6%B2%99%E5%83%A7%2F</url>
    <content type="text"><![CDATA[题目描述给出一个n个点的树，其中1为根节点有m次操作，每次给以a为节点的子树中深度为d的节点+v 用一个桶cnt\left [ d \right ]记录深度为d 的节点要加的值，一遍dfs即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=100050,rt=1;int n,m,dep[N];vector&lt;int&gt; e[N],f[N],g[N];LL w[N],cnt[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void dfs(int o)&#123; w[o]+=cnt[dep[o]]; for(int i=0;i&lt;f[o].size();i++) if (f[o][i]==0) w[o]+=g[o][i]; for(int i=0;i&lt;f[o].size();i++) cnt[f[o][i]+dep[o]]+=g[o][i]; for(int i=0;i&lt;e[o].size();i++) if (!dep[e[o][i]]) dep[e[o][i]]=dep[o]+1,dfs(e[o][i]); for(int i=0;i&lt;f[o].size();i++) cnt[f[o][i]+dep[o]]-=g[o][i];&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; for(int i=1;i&lt;=m;i++) &#123; int x=read(),d=read(),val=read(); f[x].push_back(d); g[x].push_back(val); &#125; dep[rt]=1,dfs(rt); for(int i=1;i&lt;=n;i++) printf("%lld ",w[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>桶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]八戒]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E5%85%AB%E6%88%92%2F</url>
    <content type="text"><![CDATA[题目描述给出n个点，m条边每个点有一个权值w，和衰减速度v，每走1单位的路衰减v保证最优取法所有点权值均大于0 用dp\left [i \right ]\left [ s \right ]记录最小衰减值，其中i 为当前点位置，s 为当前状态 dp\left [ j\right ]\left [{s}' \right ] =min\left \{ dp\left [ i\right ]\left [ s\right ] +d\left [ i,j \right ]*\omega \left [ \sim s \right ]\right \}\left ( i\in s,j\notin s \right )其中d\left [ i \right ]\left [ j\right ]为i 到j 的距离，可以用Floyd 处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=22,INF=1&lt;&lt;20;int d[N][N],dp[N][1&lt;&lt;N],w[N],rec[1&lt;&lt;N],c[N],n,m,sum;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) if (i!=k) for(int j=1;j&lt;=n;j++) if (k!=j&amp;&amp;i!=j) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125;int main()&#123; int T=read(); while (T--) &#123; n=read(),m=read(),sum=0; for(int i=1;i&lt;=n;i++) w[i]=read(),c[i]=read(); for(int i=1;i&lt;=n;i++) sum+=w[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if (i!=j) d[i][j]=INF; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); d[u][v]=d[v][u]=min(d[u][v],read()); &#125; for(int i=1;i&lt;=n;i++) for(int s=0;s&lt;(1&lt;&lt;n);s++) dp[i][s]=INF; for(int s=0;s&lt;(1&lt;&lt;n);s++) rec[s]=0; for(int s=0;s&lt;(1&lt;&lt;n);s++) for(int i=1;i&lt;=n;i++) if ((s&gt;&gt;(i-1))&amp;1) rec[s]+=c[i]; floyd(),dp[1][1]=0; for(int s=0;s&lt;(1&lt;&lt;n);s++) for(int i=1;i&lt;=n;i++) if ((s&gt;&gt;(i-1))&amp;1&amp;&amp;dp[i][s]&lt;sum) for(int j=1;j&lt;=n;j++) if (!((s&gt;&gt;(j-1))&amp;1)) dp[j][s|(1&lt;&lt;(j-1))]=min(dp[j][s|(1&lt;&lt;(j-1))],dp[i][s]+rec[(1&lt;&lt;n)-1-s]*d[i][j]); int ans=-INF; for(int i=1;i&lt;=n;i++) ans=max(ans,sum-dp[i][(1&lt;&lt;n)-1]); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]悟空]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E6%82%9F%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[题目描述给出一个n*m的矩阵，矩阵中有A和Q两种字符求有多少个子矩阵，矩阵的四个角选出三个能构成QAQ 记A为1，Q为0，当且仅当矩阵四个角和为1或2满足条件剩下的做法和之前的洛谷P3941 入阵曲（传送门）差不多1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#define LL long longconst int N=505;int w[N][N],c[N],cnt[N],n,m;LL ans=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (!(('a'&lt;=ch&amp;&amp;ch&lt;='z')||('A'&lt;=ch&amp;&amp;ch&lt;='Z'))) ch=getchar(); return ch;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; char opt=get(); w[i][j]=opt=='A'?1:0; &#125; for(int i=1;i&lt;=m;++i) for(int j=i+1;j&lt;=m;++j) &#123; for(int k=0;k&lt;=4;k++) cnt[k]=0; for(int k=1;k&lt;=n;++k) &#123; c[k]=w[k][i]+w[k][j]; ans+=cnt[2-c[k]]; if (c[k]&lt;=1) ans+=cnt[1-c[k]]; cnt[c[k]]++; &#125; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]奇怪的队列]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E5%A5%87%E6%80%AA%E7%9A%84%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述nodgd的粉丝太多了，每天都会有很多人排队要签名。今天有n个人排队，每个人的身高都是一个整数，且互不相同。很不巧，nodgd今天去忙别的事情去了，就只好让这些粉丝们明天再来。同时nodgd提出了一个要求，每个人都要记住自己前面与多少个比自己高的人，以便于明天恢复到今天的顺序。但是，粉丝们或多或少都是有些失望的，失望使她们晕头转向、神魂颠倒，已经分不清楚哪一边是“前面”了，于是她们可能是记住了前面比自己高的人的个数，也可能是记住了后面比自己高的人的个数，而且他们不知道自己记住的是哪一个方向。nodgd觉得，即使这样明天也能恢复出一个排队顺序，使得任意一个人的两个方向中至少有一个方向上的比他高的人数和他记住的数字相同。可惜n比较大，显然需要写个程序来解决，nodgd很忙，写程序这种事情就交给你了。 从小到大考虑每个人，对于每个人贪心地考虑位置用线段树维护，支持求排名和单点修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=100050,INF=N&lt;&lt;2;struct node &#123;int val,w;&#125; t[N];int n,c[N],sz[N&lt;&lt;2];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void build (int o,int l,int r)&#123; if (l==r) &#123;sz[o]=1;return;&#125; int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); sz[o]=sz[o&lt;&lt;1]+sz[o&lt;&lt;1|1];&#125;void add(int o,int l,int r,int k,int x)&#123; if (l==r) &#123;sz[o]+=x;return;&#125; int mid=(l+r)&gt;&gt;1; if (k&lt;=mid) add(o&lt;&lt;1,l,mid,k,x); else add(o&lt;&lt;1|1,mid+1,r,k,x); sz[o]=sz[o&lt;&lt;1]+sz[o&lt;&lt;1|1];&#125;int ask_pre(int o,int l,int r,int k)&#123; if (l==r) return r; int mid=(l+r)&gt;&gt;1; if (sz[o&lt;&lt;1]&gt;=k) return ask_pre(o&lt;&lt;1,l,mid,k); else return ask_pre(o&lt;&lt;1|1,mid+1,r,k-sz[o&lt;&lt;1]);&#125;int ask_nxt(int o,int l,int r,int k)&#123; if (l==r) return r; int mid=(l+r)&gt;&gt;1; if (sz[o&lt;&lt;1|1]&gt;=k) return ask_nxt(o&lt;&lt;1|1,mid+1,r,k); else return ask_nxt(o&lt;&lt;1,l,mid,k-sz[o&lt;&lt;1|1]);&#125;bool cmp(node a,node b) &#123;return a.val&lt;b.val;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) t[i].val=read(),t[i].w=read(); sort(t+1,t+n+1,cmp); build(1,1,n); for(int i=1;i&lt;=n;i++) &#123; int pos=INF; if (sz[1]&lt;=t[i].w) &#123;puts("impossible");return 0;&#125; pos=min(pos,ask_pre(1,1,n,t[i].w+1)); pos=min(pos,ask_nxt(1,1,n,t[i].w+1)); c[pos]=t[i].val; add(1,1,n,pos,-1); &#125; for(int i=1;i&lt;=n;i++) printf("%d ",c[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]拆网线]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E6%8B%86%E7%BD%91%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题目描述企鹅国的网吧们之间由网线互相连接，形成一棵树的结构。现在由于冬天到了，供暖部门缺少燃料，于是他们决定去拆一些网线来做燃料。但是现在有 K 只企鹅要上网和别人联机游戏，所以他们需要把这 K 只企鹅安排到不同的机房（两只企鹅在同一个机房会吵架），然后拆掉一些网线，但是需要保证每只企鹅至少还能通过留下来的网线和至少另一只企鹅联机游戏。所以他们想知道，最少需要保留多少根网线？ 从叶子节点往上贪心1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int N=100050;vector&lt;int&gt; e[N];queue&lt;int&gt; Q;int used[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void dfs(int o,int fa)&#123; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (to==fa) continue; dfs(to,o); &#125; Q.push(o);&#125;int main()&#123; int T=read(); while (T--) &#123; int n=read(),k=read(),ans=0; for(int i=1;i&lt;=n;i++) e[i].clear(),used[i]=0; for(int i=1;i&lt;n;i++) &#123; int u=read(),v=i+1; e[u].push_back(v); e[v].push_back(u); &#125; while (!Q.empty()) Q.pop(); dfs(1,0); while (!Q.empty()&amp;&amp;k&gt;1) &#123; int x=Q.front();Q.pop(); if (used[x]) continue; for(int i=0;i&lt;e[x].size();i++) &#123; int to=e[x][i]; if (used[to]) continue; used[x]=used[to]=1; ans++,k-=2; break; &#125; &#125; printf("%d\n",ans+k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3941 入阵曲]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%B4%9B%E8%B0%B7P3941-%E5%85%A5%E9%98%B5%E6%9B%B2%2F</url>
    <content type="text"><![CDATA[用sum\left [ i \right ]\left [ j \right ]，记录第i 行，前j 个的和枚举i ,j 两列\left ( i]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2568 GCD]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%B4%9B%E8%B0%B7P2568-GCD%2F</url>
    <content type="text"><![CDATA[对于一组gcd(x,y)=1，若有一个质数p，则gcd(xp,yp)=p枚举所有的p，求所有xp]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2005]九数码游戏]]></title>
    <url>%2F2018%2F07%2F06%2FZJOI2005-%E4%B9%9D%E6%95%B0%E7%A0%81%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[直接搜索加剪枝剪枝可以考虑Cantor 展开，也可以直接用map12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;queue&gt;#define LL long longusing namespace std;const int N=5,ed=12345678;struct node &#123;LL s;int k;&#125;;map&lt;LL,LL&gt; M;int ans=-1,w[N&lt;&lt;2];queue&lt;node&gt; Q;LL modify(LL s,int f)&#123; for(int i=9;i&gt;0;i--) w[i]=s%10,s/=10; if (f) &#123; int num=w[6];LL ret=0; w[6]=w[5],w[5]=w[4],w[4]=num; for(int i=1;i&lt;=9;i++) ret=ret*10+w[i]; return ret; &#125; else &#123; int num=w[1];LL ret=0; w[1]=w[4],w[4]=w[7],w[7]=w[8]; w[8]=w[9],w[9]=w[6],w[6]=w[3]; w[3]=w[2],w[2]=num; for(int i=1;i&lt;=9;i++) ret=ret*10+w[i]; return ret; &#125; &#125;void bfs(LL st)&#123; M[st]=0,Q.push((node)&#123;st,0&#125;); while (!Q.empty()) &#123; node x=Q.front();Q.pop(); if (x.s==ed) &#123;ans=x.k;return;&#125; LL nxt=modify(x.s,0); if (M.find(nxt)==M.end()) &#123; M[nxt]=x.s; Q.push((node)&#123;nxt,x.k+1&#125;); &#125; nxt=modify(x.s,1); if (M.find(nxt)==M.end()) &#123; M[nxt]=x.s; Q.push((node)&#123;nxt,x.k+1&#125;); &#125; &#125;&#125;void dfs(LL s)&#123; if (!s) return; dfs(M[s]); for(int i=9;i&gt;0;i--) w[i]=s%10,s/=10; for(int i=1;i&lt;=9;i++) printf("%d%c",w[i],i%3?' ':'\n'); printf("\n");&#125;int main()&#123; LL num=0; for(int i=1;i&lt;=9;i++) &#123; int x; scanf("%d",&amp;x); num=num*10+x; &#125; bfs(num); if (ans==-1) &#123;puts("UNSOLVABLE");return 0;&#125; printf("%d\n",ans),dfs(ed); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1484 种树]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%B4%9B%E8%B0%B7P1484-%E7%A7%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[神奇的贪心 从大到小取$a_{i}$因此对于每个a_{i}，若最终答案不包含a_{i}，则一定包含a_{i-1}+a_{i+1}于是每次取a_{i}时，加入a_{i-1}+a_{i+1}-a_{i}，允许撤销操作123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=500050;int n,m,w[N],L[N],R[N],used[N];struct node &#123;LL val;int id;&#125;;struct cmp &#123;bool operator ()(node a,node b) &#123;return a.val&lt;b.val;&#125;&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),Q.push((node)&#123;w[i],i&#125;); for(int i=1;i&lt;=n;i++) L[i]=i-1,R[i]=i+1; R[0]=1,L[n+1]=n;LL ans=0; while (m--) &#123; while (used[Q.top().id]) Q.pop(); int k=Q.top().id; used[L[k]]=used[R[k]]=1; if (Q.top().val&lt;=0) break; ans=ans+Q.top().val,Q.pop(); Q.push((node)&#123;w[k]=w[L[k]]+w[R[k]]-w[k],k&#125;); L[k]=L[L[k]],R[L[k]]=k; R[k]=R[R[k]],L[R[k]]=k; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim游戏]]></title>
    <url>%2F2018%2F07%2F06%2FNIM%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[当且仅当\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=0为一个P 最终状态为0 对于一个\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=k\left ( k>0 \right ) 的状态，必存在一个a_{i}>k，使得下一步\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=0 对于一个\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=0，不存在一种方案使得下一步\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=k\left ( k>0 \right )]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2719]银河之星]]></title>
    <url>%2F2018%2F07%2F05%2FBZOJ2719-%E9%93%B6%E6%B2%B3%E4%B9%8B%E6%98%9F%2F</url>
    <content type="text"><![CDATA[通过观察可以发现点在%3意义下相同直接暴力搜索加剪枝但是要注意棋盘大小，棋盘小有些点跳不过去。代码没有考虑棋盘大小，有部分点会WA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=15;int K,n,m,xx,yy,x[N],y[N],used[N],f,w[N],cnt=0;set&lt;LL&gt; S;int F(int x,int y) &#123;return x*3+y+1;&#125;void dfs(int k)&#123; if (f) return; if (k==1) &#123; for(int i=1;i&lt;=K;i++) if (!used[i]) f=xx==x[i]&amp;&amp;yy==y[i]; return; &#125; cnt=0;LL num=0; for(int i=1;i&lt;=K;i++) if (!used[i]) w[++cnt]=F(x[i],y[i]); sort(w+1,w+cnt+1); for(int i=1;i&lt;=cnt;i++) num=num*10+w[i]; if (!S.empty()&amp;&amp;S.find(num)!=S.end()) return; S.insert(num); for(int i=1;i&lt;=K;i++) if (!used[i]) for(int j=1;j&lt;=K;j++) if (!used[j]&amp;&amp;i!=j) if (!(xx==x[i]&amp;&amp;yy==y[i])) &#123; int u=x[i],v=y[i]; used[j]=1; x[i]=x[i]==x[j]?x[i]:3-x[i]-x[j]; y[i]=y[i]==y[j]?y[i]:3-y[i]-y[j]; dfs(k-1); used[j]=0; x[i]=u,y[i]=v; &#125;&#125;int main()&#123; while (scanf("%d%d%d%d%d",&amp;K,&amp;n,&amp;m,&amp;xx,&amp;yy)!=EOF) &#123; xx%=3,yy%=3;S.clear(); for(int i=1;i&lt;=K;i++) scanf("%d%d",&amp;x[i],&amp;y[i]); for(int i=1;i&lt;=K;i++) x[i]%=3,y[i]%=3; for(int i=1;i&lt;=K;i++) used[i]=0; f=0,dfs(K); printf("%s\n",f?"Yes":"No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[藏妹子之处]]></title>
    <url>%2F2018%2F07%2F05%2F%E8%97%8F%E5%A6%B9%E5%AD%90%E4%B9%8B%E5%A4%84%2F</url>
    <content type="text"><![CDATA[首先要有个妹子 问题描述：今天CZY又找到了三个妹子，有着收藏爱好的他想要找三个地方将妹子们藏起来，将一片空地抽象成一个R行C列的表格，CZY要选出3个单元格。但要满足如下的两个条件：（1）任意两个单元格都不在同一行。（2）任意两个单元格都不在同一列。选取格子存在一个花费，而这个花费是三个格子两两之间曼哈顿距离的和（如$\left ( x_{1},y_{1} \right )$和$\left ( x_{2},y_{2} \right )$的曼哈顿距离为$\left | x_{1}-x_{2} \right |+\left | y_{1}-y_{2} \right |$）。狗狗想知道的是，花费在minT 到maxT 之间的方案数有多少。答案模1000000007。所谓的两种不同方案是指：只要它选中的单元格有一个不同，就认为是不同的方案。 通过观察，不难发现在一个R*C的矩阵中，所有最大的三个单元格曼哈顿距离相等，均为2(R+C)-4通过简单地分析可以得出，在R*C的矩阵中，共有6（R-2)(C-2)组最大的三个单元格代码就很简单了123456789101112131415#include&lt;cstdio&gt;#define LL long longconst int mod=1000000007;int r,c,mins,maxs;LL ans=0;int main()&#123; scanf("%d%d%d%d",&amp;r,&amp;c,&amp;mins,&amp;maxs); for(int i=2;i&lt;r;i++) for(int j=2;j&lt;c;j++) if (i*2+j*2&lt;=maxs&amp;&amp;i*2+j*2&gt;=mins) ans=(ans+6LL*(r-i)*(c-j)*(i-1)*(j-1))%mod; printf("%d",ans); return 0;&#125; 依水临山 景看旧 而你美胜 山水万筹]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2005]互不侵犯]]></title>
    <url>%2F2018%2F07%2F05%2FSCOI2005-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF%2F</url>
    <content type="text"><![CDATA[预处理一行所有可能的情况用dp\left [d \right ]\left [ i\right ]\left [ k \right ]数组记录第d行，当前状态为s\left [ i \right ]，总共放置k个的方案数复杂度O\left ( nk4^{n} \right )1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#define LL long longconst int N=10;int n,m,s[1&lt;&lt;N],w[1&lt;&lt;N],c[1&lt;&lt;N][1&lt;&lt;N],cnt=0;LL dp[N][N&lt;&lt;2][1&lt;&lt;N],ans=0;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;(1&lt;&lt;n);i++) if (!(i&amp;(i&lt;&lt;1))&amp;&amp;!(i&amp;(i&gt;&gt;1))) s[++cnt]=i; for(int i=1;i&lt;=cnt;i++) for(int k=1;k&lt;=n;k++) if (s[i]&amp;(1&lt;&lt;(k-1))) w[i]++; for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) if (!(s[i]&amp;s[j])) if (!(s[i]&amp;(s[j]&lt;&lt;1))&amp;&amp;!(s[i]&amp;(s[j]&gt;&gt;1))) c[i][j]=1; for(int i=1;i&lt;=cnt;i++) dp[1][w[i]][i]=1; for(int d=2;d&lt;=n;d++) for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) if (c[i][j]) for(int k=w[i];k&lt;=m-w[j];k++) dp[d][k+w[j]][j]+=dp[d-1][k][i]; for(int i=1;i&lt;=cnt;i++) ans+=dp[n][m][i]; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1429 平面最近点对]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%B4%9B%E8%B0%B7P1429-%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[裸的二分，复杂度O\left ( nlog^{2}n \right )1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=200050,INF=1&lt;&lt;30;struct dot &#123;double x,y;&#125; t[N];vector&lt;int&gt; w;bool cmp(dot a,dot b) &#123;return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;bool check(int a,int b) &#123;return t[a].y&lt;t[b].y;&#125;double sqr(double x) &#123;return x*x;&#125;double dist(dot a,dot b) &#123;return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));&#125;double calc(int l,int r)&#123; double ret=INF; if (l==r) return ret; int mid=(l+r)&gt;&gt;1; ret=min(ret,min(calc(l,mid),calc(mid+1,r))); w.clear(); for(int i=l;i&lt;=r;i++) if (fabs(t[i].x-t[mid].x)&lt;ret) w.push_back(i); sort(w.begin(),w.end(),check); for(int i=0;i&lt;w.size();i++) for(int j=i+1;j&lt;w.size()&amp;&amp;fabs(t[w[i]].y-t[w[j]].y)&lt;ret;j++) ret=min(ret,dist(t[w[i]],t[w[j]])); return ret; &#125;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;t[i].x,&amp;t[i].y); sort(t+1,t+n+1,cmp); printf("%.4lf",calc(1,n)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3933 Chtholly Nota Seniorious]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%B4%9B%E8%B0%B7P3933-Chtholly-Nota-Seniorious%2F</url>
    <content type="text"><![CDATA[神奇的二分答案题 根据题目奇奇怪怪的限制，不难发现选择的行和列要连续为了方便计算，将矩阵转置四次，每次只需考虑行要连续二分一下ans 进行检验对于矩阵中的mins 和maxs ，显然二者不能分在一起根据mins ，maxs 和二分出来的ans ，贪心地确定每个值所在的分组，若不连续则不合法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=2050,INF=1&lt;&lt;30;int n,m,now,w[2][N][N],ans,mins=INF,maxs=-INF;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void rotate()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[now^1][j][n-i+1]=w[now][i][j]; swap(n,m),now^=1;&#125;bool check(int k)&#123; int num=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) if (maxs-w[now][i][j]&gt;k) num=max(num,j); for(int j=1;j&lt;=num;j++) if (w[now][i][j]-mins&gt;k) return 0; &#125; return 1;&#125;void solve()&#123; int L=0,R=ans; while (L&lt;R) &#123; int mid=(L+R)&gt;&gt;1; if (check(mid)) R=mid; else L=mid+1; &#125; ans=R;&#125;int main()&#123; n=read(),m=read(),now=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; w[0][i][j]=read(); maxs=max(maxs,w[0][i][j]); mins=min(mins,w[0][i][j]); &#125; ans=maxs-mins; rotate(),solve(); rotate(),solve(); rotate(),solve(); rotate(),solve(); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大化平均值]]></title>
    <url>%2F2018%2F07%2F05%2Fmax-ave%2F</url>
    <content type="text"><![CDATA[问题描述：有n个物品的重量和价值分别是 wi 和 vi。从中选出k个物品使得单位重量的价值最大。 根据定义 \sum_{i=1}^{k}v_{i}=x\sum_{i=1}^{k}w_{i}即 \sum_{i=1}^{k}\left (v _{i}-xw_{i} \right )=0二分一下x，每次在\left (v _{i}-xw_{i} \right )贪心地找前k大的复杂度O\left ( nlog^{2}n \right )123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=10050;const double eps=1e-5;int n,m,w[N],v[N];double c[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;bool check(double k)&#123; for(int i=1;i&lt;=n;i++) c[i]=v[i]-k*w[i]; sort(c+1,c+n+1); double ret=0; for(int i=n;i&gt;n-m;i--) ret+=c[i]; return ret&gt;-eps;&#125;int main()&#123; n=read(),m=read(); double L=0,R; for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;=n;i++) v[i]=read(),R=max((double)v[i],R); while (R-L&gt;eps) &#123; double mid=(L+R)/2; if (check(mid)) L=mid; else R=mid; &#125; printf("%.2lf",R); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017]列队]]></title>
    <url>%2F2018%2F06%2F28%2FNOIP2017-%E5%88%97%E9%98%9F%2F</url>
    <content type="text"><![CDATA[感觉是至今为止做到的最难的数据结构题什么分块，嵌套，可持久化都没有这题给人的第一感觉难这题每个数据开一个点都开不下。考场上见到这题基本上一脸懵逼，想了很久写了个O\left ( q^{2}\right )但是不能优化的算法，结果没开LL只有30分用线段树维护每一行和最后一列，支持单点rank 和insert 两种操作最大长度为max\left ( n,m \right )+q动态开点减少内存，空间复杂度O\left ( 4qlog\left ( max\left ( n,m \right )+q\right ) \right )12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=300050;struct node &#123;int l,r,sz,id;bool f;&#125; t[N*60];int n,m,T,cnt=0,idx=0,rt[N],sz[N],pos,u,v;LL w[N&lt;&lt;2];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void build(int &amp;o,int l,int r,int f)&#123; o=++cnt; if (l==r) &#123; t[o].sz=(!f&amp;&amp;r&lt;m)||(f&amp;&amp;r&lt;=n); return; &#125; int mid=(l+r)&gt;&gt;1; build(t[o].l,l,mid,f); build(t[o].r,mid+1,r,f); t[o].sz=t[t[o].l].sz+t[t[o].r].sz;&#125;LL ask(int &amp;o,int pre,int l,int r,int f)&#123; if (!t[o].f) o=++cnt,t[o]=t[pre],t[o].f=1; if (l==r) &#123; t[o].sz=0; if (!f&amp;&amp;r&lt;m) return (LL)(u-1)*m+l; if (f&amp;&amp;r&lt;=n) return (LL)r*m; return w[t[o].id]; &#125; int num=t[t[o].l].sz,mid=(l+r)&gt;&gt;1;LL ret; if (pos&lt;=num) ret=ask(t[o].l,t[pre].l,l,mid,f); else pos-=num,ret=ask(t[o].r,t[pre].r,mid+1,r,f); t[o].sz=t[t[o].l].sz+t[t[o].r].sz; return ret;&#125;void insert(int &amp;o,int pre,int l,int r,LL x)&#123; if (!t[o].f) o=++cnt,t[o]=t[pre],t[o].f=1; if (l==r) &#123; w[++idx]=x; t[o].id=idx,t[o].sz=1; return; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) insert(t[o].l,t[pre].l,l,mid,x); else insert(t[o].r,t[pre].r,mid+1,r,x); t[o].sz=t[t[o].l].sz+t[t[o].r].sz;&#125;int main()&#123; n=read(),m=read(),T=read(); int maxs=max(n,m)+T; build(rt[0],1,maxs,0); for(int i=1;i&lt;=n;i++) rt[i]=++cnt,t[cnt]=t[rt[0]],t[cnt].f=1; for(int i=1;i&lt;=n;i++) sz[i]=m-1;sz[n+1]=n; build(rt[n+1],1,maxs,1); while (T--) &#123; u=read(),v=read(); if (v==m) &#123; LL x; pos=u,x=ask(rt[n+1],rt[n+1],1,maxs,1); printf("%lld\n",x); pos=++sz[n+1],insert(rt[n+1],rt[n+1],1,maxs,x); &#125; else &#123; LL x,w; pos=v,x=ask(rt[u],rt[u],1,maxs,0); printf("%lld\n",x); pos=u,w=ask(rt[n+1],rt[n+1],1,maxs,1); pos=++sz[u],insert(rt[u],rt[u],1,maxs,w); pos=++sz[n+1],insert(rt[n+1],rt[n+1],1,maxs,x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017]宝藏]]></title>
    <url>%2F2018%2F06%2F22%2FNOIP2017-%E5%AE%9D%E8%97%8F%2F</url>
    <content type="text"><![CDATA[当初考场上没有想到如何保存状态，写了个O\left ( 2^{n} n!\right )的，拿了70分dp 数组记录最大深度d ，和已选点状态s对于每个s ，枚举补集进行更新枚举补集复杂度为O\left ( 3^{n}\right )，总复杂度O\left ( n3^{n} \right )12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=14,INF=1&lt;&lt;30;int n,m,dp[N][1&lt;&lt;N],w[1&lt;&lt;N],idx[1&lt;&lt;N],pos[1&lt;&lt;N],c[N],f[N][N],val[N];vector&lt;int&gt; e[N];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) f[i][j]=INF; for(int d=0;d&lt;=n;d++) for(int i=0;i&lt;(1&lt;&lt;n);i++) dp[d][i]=INF; for(int i=1;i&lt;=m;i++) &#123; int u,v,val; scanf("%d%d%d",&amp;u,&amp;v,&amp;val); f[u][v]=f[v][u]=min(val,f[u][v]); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if (f[i][j]!=INF) e[i].push_back(j); for(int i=1;i&lt;=n;i++) dp[0][1&lt;&lt;(i-1)]=0; for(int d=0;d&lt;=n;d++) for(int s=0,cnt=0;s&lt;(1&lt;&lt;n);s++,cnt=0) if (dp[d][s]!=INF) &#123; for(int i=1;i&lt;=n;i++) if (!(s&gt;&gt;(i-1)&amp;1)) pos[1&lt;&lt;cnt]=i,val[i]=INF,c[cnt++]=i; for(int k=1;k&lt;(1&lt;&lt;cnt);k++) &#123; int x=0; for(int i=0;i&lt;cnt;i++) if ((k&gt;&gt;i)&amp;1) x|=1&lt;&lt;(c[i]-1); idx[k]=x,w[x]=INF; &#125; for(int i=1;i&lt;=n;i++) if ((s&gt;&gt;(i-1))&amp;1) for(int j=0;j&lt;e[i].size();j++) &#123; int to=e[i][j]; if (!((s&gt;&gt;(to-1))&amp;1)) val[to]=min(f[i][to],val[to]); &#125; for(int k=1;k&lt;(1&lt;&lt;cnt);k++) if (w[idx[k-(k&amp;-k)]]!=INF&amp;&amp;val[pos[k&amp;-k]]!=INF) w[idx[k]]=w[idx[k-(k&amp;-k)]]+(d+1)*val[pos[k&amp;-k]]; for(int k=0;k&lt;(1&lt;&lt;cnt);k++) if (!(s&amp;idx[k])&amp;&amp;w[idx[k]]!=INF) dp[d+1][s|idx[k]]=min(dp[d+1][s|idx[k]],dp[d][s]+w[idx[k]]); &#125; int ans=INF; for(int i=1;i&lt;=n;i++) ans=min(ans,dp[i][(1&lt;&lt;n)-1]); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2009]梦幻布丁]]></title>
    <url>%2F2018%2F06%2F20%2FHNOI2009-%E6%A2%A6%E5%B9%BB%E5%B8%83%E4%B8%81%2F</url>
    <content type="text"><![CDATA[用并查集维护在代表元素中保存当前段的颜色（w），和左右端点（s，t）再用一个桶维护每种颜色的所有段当且仅当要合并两段颜色相同时进行合并，并更新左右端点对于每个桶用list 维护，再进行启发式合并，这里偷懒直接用了vector123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=100050;int fa[N],w[N],cnt,s[N],t[N],n,m;vector&lt;int&gt; f[N*10];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;int find(int x) &#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void unite(int u,int v)&#123; if (!u||!v) return; u=find(u),v=find(v); if (w[u]!=w[v]) return;else cnt--; fa[v]=u,s[u]=min(s[u],s[v]),t[u]=max(t[u],t[v]);&#125;void update()&#123; int u=read(),v=read(); if (u==v) return; while (!f[u].empty()) &#123; int x=f[u].back();f[u].pop_back(); if (find(x)!=x) continue;else w[x]=v; int st=s[x],ed=t[x]; if (st&gt;1) unite(st-1,st); if (ed&lt;n) unite(ed,ed+1); if (find(x)==x) f[v].push_back(x); &#125; &#125;int main()&#123; n=cnt=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),fa[i]=i; for(int i=1;i&lt;=n;i++) s[i]=t[i]=i; for(int i=1;i&lt;n;i++) unite(i,i+1); for(int i=1;i&lt;=n;i++) if (i==find(i)) f[w[i]].push_back(i); for(int i=1;i&lt;=m;i++) &#123; int opt=read(); if (opt==1) update(); if (opt==2) printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1471 方差]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%B4%9B%E8%B0%B7P1471-%E6%96%B9%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[区间修改，区间查询，基本可以用线段树维护，主要是方差比较难维护将方差的计算展开 \frac{\sum_{i=1}^{n} \left ( a_{i}-\bar{a} \right )^{2}}{n}= \frac{\sum_{i=1}^{n} a_{i}^{2}-2\bar{a}\sum_{i=1}^{n}a_{i}+n\bar{a}^{2}}{n}= -\bar{a}^{2}+\frac{\sum_{i=1}^{n}a_{i}^{2}}{n}对于区间加法 \sum_{i=l}^{r}\left ( a_{i}+x \right )^{2}= \sum_{i=l}^{r}a_{i}^{2}+2x\sum_{i=l}^{r}a_{i}+\left ( r-l+1 \right )*x^{2} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N=100050;const double eps=1e-8;int n,m,ql,qr;struct node &#123;double val,sum,c;&#125; t[N&lt;&lt;2]; double sqr(double x) &#123;return x*x;&#125;void build(int o,int l,int r)&#123; if (l==r) &#123; scanf("%lf",&amp;t[o].val); t[o].sum=sqr(t[o].val); return; &#125; int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); t[o].val=t[o&lt;&lt;1].val+t[o&lt;&lt;1|1].val; t[o].sum=t[o&lt;&lt;1].sum+t[o&lt;&lt;1|1].sum;&#125;void pushdown(int o,int l,int r)&#123; double x=t[o].c;t[o].c=0; int mid=(l+r)&gt;&gt;1; t[o&lt;&lt;1].sum+=(mid-l+1)*sqr(x)+2*x*t[o&lt;&lt;1].val; t[o&lt;&lt;1|1].sum+=(r-mid)*sqr(x)+2*x*t[o&lt;&lt;1|1].val; t[o&lt;&lt;1].val+=(mid-l+1)*x; t[o&lt;&lt;1|1].val+=(r-mid)*x; t[o&lt;&lt;1].c+=x,t[o&lt;&lt;1|1].c+=x; &#125;void update(int o,int l,int r,double x)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123; t[o].sum+=sqr(x)*(r-l+1)+2*x*t[o].val; t[o].val+=(r-l+1)*x;t[o].c+=x; return; &#125; int mid=(l+r)&gt;&gt;1; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) update(o&lt;&lt;1,l,mid,x); if (qr&gt;mid) update(o&lt;&lt;1|1,mid+1,r,x); t[o].val=t[o&lt;&lt;1].val+t[o&lt;&lt;1|1].val; t[o].sum=t[o&lt;&lt;1].sum+t[o&lt;&lt;1|1].sum;&#125;double ask(int o,int l,int r)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return t[o].val; int mid=(l+r)&gt;&gt;1;double ret=0; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) ret+=ask(o&lt;&lt;1,l,mid); if (qr&gt;mid) ret+=ask(o&lt;&lt;1|1,mid+1,r); return ret;&#125;double query(int o,int l,int r)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return t[o].sum; int mid=(l+r)&gt;&gt;1;double ret=0; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) ret+=query(o&lt;&lt;1,l,mid); if (qr&gt;mid) ret+=query(o&lt;&lt;1|1,mid+1,r); return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; int opt; scanf("%d%d%d",&amp;opt,&amp;ql,&amp;qr); if (opt==1) &#123; double x;scanf("%lf",&amp;x); update(1,1,n,x); &#125; if (opt==2) printf("%.4lf\n",ask(1,1,n)/(qr-ql+1)); if (opt==3) &#123; double x=ask(1,1,n)/(qr-ql+1); printf("%.4lf\n",-sqr(x)+query(1,1,n)/(qr-ql+1)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]书架]]></title>
    <url>%2F2018%2F06%2F13%2FZJOI2006-%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一看题目就有一种平衡树的气息。给每本书一个val 来维护相对位置再用一个pos 数组记录下编号为x的位置pos[x]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=1&lt;&lt;30,N=200050;int rt=0,cnt=0,n,m,pos[N],w[N],L,R;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;struct node &#123;int ch[2],fa,rec,val,sz;&#125;t[N];namespace Splay&#123; void calc(int o) &#123;t[o].sz=t[t[o].ch[0]].sz+t[t[o].ch[1]].sz+1;&#125; void maintain(int o) &#123;pos[t[o].rec]=o;&#125; void rotate(int x) &#123; int y=t[x].fa,z=t[y].fa,k=t[y].ch[1]==x; t[z].ch[t[z].ch[1]==y]=x,t[x].fa=z; t[y].ch[k]=t[x].ch[k^1],t[t[x].ch[k^1]].fa=y; t[x].ch[k^1]=y,t[y].fa=x; calc(y),calc(x); &#125; void splay(int x,int to) &#123; while (t[x].fa!=to) &#123; int y=t[x].fa,z=t[y].fa; if (z!=to) (t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; if (!to) rt=x; &#125; void ins(int &amp;o,int fa,int x,int idx) &#123; if (!o) &#123; o=++cnt; t[o].val=x,t[o].fa=fa; t[o].sz=1; t[o].rec=idx; pos[idx]=o; splay(o,0); return; &#125; t[o].sz++; ins(t[o].ch[x&gt;t[o].val],o,x,idx); &#125; void find(int x) &#123; int o=rt; while (t[o].ch[x&gt;t[o].val]&amp;&amp;x!=t[o].val) o=t[o].ch[x&gt;t[o].val]; splay(o,0); &#125; int next(int x,int opt) &#123; find(x); if ((t[rt].val&gt;x&amp;&amp;opt)||(t[rt].val&lt;x&amp;&amp;!opt)) return rt; int o=t[rt].ch[opt]; while (t[o].ch[opt^1]) o=t[o].ch[opt^1]; return o; &#125; void del(int x) &#123; int pre=next(x,0),nxt=next(x,1); splay(pre,0),splay(nxt,pre); int o=t[nxt].ch[0]; t[nxt].ch[0]=0; calc(nxt);calc(pre); &#125; int K_th(int o,int k) &#123; if (!o) return 0; if (k&lt;=t[t[o].ch[0]].sz) return K_th(t[o].ch[0],k); else if (k&gt;t[t[o].ch[0]].sz+1) return K_th(t[o].ch[1],k-t[t[o].ch[0]].sz-1); splay(o,0); return t[o].rec; &#125;&#125;;using namespace Splay;void insert(int x,int f)&#123; if (!f) return; if (f&lt;0) f++; int nxt=next(t[pos[x]].val,f); swap(t[nxt].rec,t[pos[x]].rec); maintain(pos[x]),maintain(nxt);&#125;int main()&#123; L=1,R=n=read(),m=read(); ins(rt,0,INF,0),ins(rt,0,-INF,0); for(int i=1;i&lt;=n;i++) ins(rt,0,i,read()); for(int i=1;i&lt;=m;i++) &#123; char str[20]; scanf("%s",str); int x=read(); if (str[0]=='T') del(t[pos[x]].val),ins(rt,0,--L,x); if (str[0]=='B') del(t[pos[x]].val),ins(rt,0,++R,x); if (str[0]=='I') insert(x,read()); if (str[0]=='A') find(t[pos[x]].val),printf("%d\n",t[t[rt].ch[0]].sz-1); if (str[0]=='Q') printf("%d\n",K_th(rt,x+1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2011]ROT-Tree Rotations]]></title>
    <url>%2F2018%2F06%2F13%2FPOI2011-ROT-Tree-Rotations%2F</url>
    <content type="text"><![CDATA[对于每个节点分别求左-右，右-左的逆序对，将较小的加入答案原来思路：枚举个数较少的节点的每个数，二分求答案看完题解发现可以用线段树合并。新技能get123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=400050;int cnt,st,ch[N][2],w[N],rt[N],n;int idx,ls[N*20],rs[N*20],sum[N*20];LL ans,f,g;void dfs(int &amp;o)&#123; o=++cnt; scanf("%d",&amp;w[o]); if (!w[o]) dfs(ch[o][0]),dfs(ch[o][1]);&#125;void build(int &amp;o,int l,int r,int k)&#123; o=++idx; if (l==r) &#123;sum[o]=1;return;&#125; int mid=(l+r)&gt;&gt;1; k&lt;=mid?build(ls[o],l,mid,k):build(rs[o],mid+1,r,k); sum[o]=sum[ls[o]]+sum[rs[o]];&#125;int merge(int u,int v)&#123; if (!u||!v) return v+u; f+=(LL)sum[rs[u]]*sum[ls[v]]; g+=(LL)sum[ls[u]]*sum[rs[v]]; int o=++idx; ls[o]=merge(ls[u],ls[v]); rs[o]=merge(rs[u],rs[v]); sum[o]=sum[ls[o]]+sum[rs[o]]; return o;&#125;void calc(int o)&#123; if (!o) return; calc(ch[o][0]),calc(ch[o][1]); if (!w[o]) &#123; f=g=0; rt[o]=merge(rt[ch[o][0]],rt[ch[o][1]]); ans+=min(f,g); &#125;&#125;int main()&#123; scanf("%d",&amp;n); dfs(st); for(int i=1;i&lt;=cnt;i++) if (w[i]) build(rt[i],1,n,w[i]); calc(st); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]皇帝的烦恼]]></title>
    <url>%2F2018%2F06%2F13%2FZJOI2006-%E7%9A%87%E5%B8%9D%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[二分答案，dp 检验dp 不是很好想f 记录与第一个位置相同个数的最大值g 记录与第一个位置相同个数的最小值12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=20050;int n,maxs,sum=0,w[N],f[N],g[N];//f&gt;&gt;max g&gt;&gt;minbool check(int k)&#123; f[1]=g[1]=w[1]; for(int i=2;i&lt;=n;i++) &#123; f[i]=min(w[1]-g[i-1],w[i]); g[i]=max(0,w[i]-(k-w[i-1]-w[1]+f[i-1])); &#125; return !g[n];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]),sum+=w[i]; maxs=w[1]+w[n]; for(int i=1;i&lt;n;i++) maxs=max(maxs,w[i]+w[i+1]); if (!(n&amp;1)) &#123;printf("%d",maxs);return 0;&#125; int L=maxs,R=sum; while (L&lt;R) &#123; int mid=(L+R)&gt;&gt;1; if (check(mid)) R=mid; else L=mid+1; &#125; printf("%d",L); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay]]></title>
    <url>%2F2018%2F06%2F12%2FSplay%2F</url>
    <content type="text"><![CDATA[优化了一下之前Splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;const int INF=1&lt;&lt;30,N=100050;int n;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;namespace Splay&#123; int rt=0,cnt=0; struct node &#123;int ch[2],fa,rec,val,sz;&#125;t[N]; void calc(int o) &#123;t[o].sz=t[t[o].ch[0]].sz+t[t[o].ch[1]].sz+t[o].rec;&#125; void rotate(int x) &#123; int y=t[x].fa,z=t[y].fa,k=t[y].ch[1]==x; t[z].ch[t[z].ch[1]==y]=x,t[x].fa=z; t[y].ch[k]=t[x].ch[k^1],t[t[x].ch[k^1]].fa=y; t[x].ch[k^1]=y,t[y].fa=x; calc(y),calc(x); &#125; void splay(int x,int to) &#123; while (t[x].fa!=to) &#123; int y=t[x].fa,z=t[y].fa; if (z!=to) (t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; if (!to) rt=x; &#125; void ins(int &amp;o,int fa,int x) &#123; if (!o) &#123; o=++cnt; t[o].val=x,t[o].fa=fa; t[o].sz=t[o].rec=1; splay(o,0); return; &#125; t[o].sz++; if (x==t[o].val) &#123;t[o].rec++;return;&#125; ins(t[o].ch[x&gt;t[o].val],o,x); &#125; void find(int x) &#123; int o=rt; while (t[o].ch[x&gt;t[o].val]&amp;&amp;x!=t[o].val) o=t[o].ch[x&gt;t[o].val]; splay(o,0); &#125; int next(int x,int opt) &#123; find(x); if ((t[rt].val&gt;x&amp;&amp;opt)||(t[rt].val&lt;x&amp;&amp;!opt)) return rt; int o=t[rt].ch[opt]; while (t[o].ch[opt^1]) o=t[o].ch[opt^1]; return o; &#125; void del(int x) &#123; int pre=next(x,0),nxt=next(x,1); splay(pre,0),splay(nxt,pre); int o=t[nxt].ch[0]; if (t[o].rec&gt;1) &#123; t[o].rec--; splay(o,0); &#125; else t[nxt].ch[0]=0; &#125; int K_th(int o,int k) &#123; if (!o) return 0; if (k&lt;=t[t[o].ch[0]].sz) return K_th(t[o].ch[0],k); else if (k&gt;t[t[o].ch[0]].sz+t[o].rec) return K_th(t[o].ch[1],k-t[t[o].ch[0]].sz-t[o].rec); splay(o,0); return t[o].val; &#125;&#125;;using namespace Splay;int main()&#123; n=read(); ins(rt,0,INF),ins(rt,0,-INF); for(int i=1;i&lt;=n;i++) &#123; int opt=read(),x=read(); if (opt==1) ins(rt,0,x); if (opt==2) del(x); if (opt==3) find(x),printf("%d\n",t[t[rt].ch[0]].sz); if (opt==4) printf("%d\n",K_th(rt,x+1)); if (opt==5) printf("%d\n",t[next(x,0)].val); if (opt==6) printf("%d\n",t[next(x,1)].val); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
</search>
