<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[NOIP模拟]沙僧]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E6%B2%99%E5%83%A7%2F</url>
    <content type="text"><![CDATA[题目描述给出一个n个点的树，其中1为根节点有m次操作，每次给以a为节点的子树中深度为d的节点+v 用一个桶cnt\left [ d \right ]记录深度为d的节点要加的值，一遍dfs即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=100050,rt=1;int n,m,dep[N];vector&lt;int&gt; e[N],f[N],g[N];LL w[N],cnt[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void dfs(int o)&#123; w[o]+=cnt[dep[o]]; for(int i=0;i&lt;f[o].size();i++) if (f[o][i]==0) w[o]+=g[o][i]; for(int i=0;i&lt;f[o].size();i++) cnt[f[o][i]+dep[o]]+=g[o][i]; for(int i=0;i&lt;e[o].size();i++) if (!dep[e[o][i]]) dep[e[o][i]]=dep[o]+1,dfs(e[o][i]); for(int i=0;i&lt;f[o].size();i++) cnt[f[o][i]+dep[o]]-=g[o][i];&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;i++) &#123; int u=read(),v=read(); e[u].push_back(v); e[v].push_back(u); &#125; for(int i=1;i&lt;=m;i++) &#123; int x=read(),d=read(),val=read(); f[x].push_back(d); g[x].push_back(val); &#125; dep[rt]=1,dfs(rt); for(int i=1;i&lt;=n;i++) printf("%lld ",w[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>桶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]八戒]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E5%85%AB%E6%88%92%2F</url>
    <content type="text"><![CDATA[题目描述给出n个点，m条边每个点有一个权值w，和衰减速度v，每走1单位的路衰减v保证最优取法所有点权值均大于0 用dp\left [i \right ]\left [ s \right ]记录最小衰减值，其中i为当前点位置，s为当前状态 dp\left [ j\right ]\left [{s}' \right ] =min\left \{ dp\left [ i\right ]\left [ s\right ] +d\left [ i,j \right ]*\omega \left [ \sim s \right ]\right \}\left ( i\in s,j\notin s \right )其中d\left [ i \right ]\left [ j\right ]为i到j的距离，可以用Floyd处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=22,INF=1&lt;&lt;20;int d[N][N],dp[N][1&lt;&lt;N],w[N],rec[1&lt;&lt;N],c[N],n,m,sum;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) if (i!=k) for(int j=1;j&lt;=n;j++) if (k!=j&amp;&amp;i!=j) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125;int main()&#123; int T=read(); while (T--) &#123; n=read(),m=read(),sum=0; for(int i=1;i&lt;=n;i++) w[i]=read(),c[i]=read(); for(int i=1;i&lt;=n;i++) sum+=w[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if (i!=j) d[i][j]=INF; for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(); d[u][v]=d[v][u]=min(d[u][v],read()); &#125; for(int i=1;i&lt;=n;i++) for(int s=0;s&lt;(1&lt;&lt;n);s++) dp[i][s]=INF; for(int s=0;s&lt;(1&lt;&lt;n);s++) rec[s]=0; for(int s=0;s&lt;(1&lt;&lt;n);s++) for(int i=1;i&lt;=n;i++) if ((s&gt;&gt;(i-1))&amp;1) rec[s]+=c[i]; floyd(),dp[1][1]=0; for(int s=0;s&lt;(1&lt;&lt;n);s++) for(int i=1;i&lt;=n;i++) if ((s&gt;&gt;(i-1))&amp;1&amp;&amp;dp[i][s]&lt;sum) for(int j=1;j&lt;=n;j++) if (!((s&gt;&gt;(j-1))&amp;1)) dp[j][s|(1&lt;&lt;(j-1))]=min(dp[j][s|(1&lt;&lt;(j-1))],dp[i][s]+rec[(1&lt;&lt;n)-1-s]*d[i][j]); int ans=-INF; for(int i=1;i&lt;=n;i++) ans=max(ans,sum-dp[i][(1&lt;&lt;n)-1]); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]悟空]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E6%82%9F%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[题目描述给出一个n*m的矩阵，矩阵中有A和Q两种字符求有多少个子矩阵，矩阵的四个角选出三个能构成QAQ 记A为1，Q为0，当且仅当矩阵四个角和为1或2满足条件剩下的做法和之前的洛谷P3941 入阵曲差不多1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#define LL long longconst int N=505;int w[N][N],c[N],cnt[N],n,m;LL ans=0;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;inline char get()&#123; register char ch=getchar(); while (!(('a'&lt;=ch&amp;&amp;ch&lt;='z')||('A'&lt;=ch&amp;&amp;ch&lt;='Z'))) ch=getchar(); return ch;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; char opt=get(); w[i][j]=opt=='A'?1:0; &#125; for(int i=1;i&lt;=m;++i) for(int j=i+1;j&lt;=m;++j) &#123; for(int k=0;k&lt;=4;k++) cnt[k]=0; for(int k=1;k&lt;=n;++k) &#123; c[k]=w[k][i]+w[k][j]; ans+=cnt[2-c[k]]; if (c[k]&lt;=1) ans+=cnt[1-c[k]]; cnt[c[k]]++; &#125; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]奇怪的队列]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP%E6%A8%A1%E6%8B%9F-%E5%A5%87%E6%80%AA%E7%9A%84%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述nodgd的粉丝太多了，每天都会有很多人排队要签名。今天有n个人排队，每个人的身高都是一个整数，且互不相同。很不巧，nodgd今天去忙别的事情去了，就只好让这些粉丝们明天再来。同时nodgd提出了一个要求，每个人都要记住自己前面与多少个比自己高的人，以便于明天恢复到今天的顺序。但是，粉丝们或多或少都是有些失望的，失望使她们晕头转向、神魂颠倒，已经分不清楚哪一边是“前面”了，于是她们可能是记住了前面比自己高的人的个数，也可能是记住了后面比自己高的人的个数，而且他们不知道自己记住的是哪一个方向。nodgd觉得，即使这样明天也能恢复出一个排队顺序，使得任意一个人的两个方向中至少有一个方向上的比他高的人数和他记住的数字相同。可惜n比较大，显然需要写个程序来解决，nodgd很忙，写程序这种事情就交给你了。 从小到大考虑每个人，对于每个人贪心地考虑位置用线段树维护，支持求排名和单点修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=100050,INF=N&lt;&lt;2;struct node &#123;int val,w;&#125; t[N];int n,c[N],sz[N&lt;&lt;2];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void build (int o,int l,int r)&#123; if (l==r) &#123;sz[o]=1;return;&#125; int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); sz[o]=sz[o&lt;&lt;1]+sz[o&lt;&lt;1|1];&#125;void add(int o,int l,int r,int k,int x)&#123; if (l==r) &#123;sz[o]+=x;return;&#125; int mid=(l+r)&gt;&gt;1; if (k&lt;=mid) add(o&lt;&lt;1,l,mid,k,x); else add(o&lt;&lt;1|1,mid+1,r,k,x); sz[o]=sz[o&lt;&lt;1]+sz[o&lt;&lt;1|1];&#125;int ask_pre(int o,int l,int r,int k)&#123; if (l==r) return r; int mid=(l+r)&gt;&gt;1; if (sz[o&lt;&lt;1]&gt;=k) return ask_pre(o&lt;&lt;1,l,mid,k); else return ask_pre(o&lt;&lt;1|1,mid+1,r,k-sz[o&lt;&lt;1]);&#125;int ask_nxt(int o,int l,int r,int k)&#123; if (l==r) return r; int mid=(l+r)&gt;&gt;1; if (sz[o&lt;&lt;1|1]&gt;=k) return ask_nxt(o&lt;&lt;1|1,mid+1,r,k); else return ask_nxt(o&lt;&lt;1,l,mid,k-sz[o&lt;&lt;1|1]);&#125;bool cmp(node a,node b) &#123;return a.val&lt;b.val;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) t[i].val=read(),t[i].w=read(); sort(t+1,t+n+1,cmp); build(1,1,n); for(int i=1;i&lt;=n;i++) &#123; int pos=INF; if (sz[1]&lt;=t[i].w) &#123;puts("impossible");return 0;&#125; pos=min(pos,ask_pre(1,1,n,t[i].w+1)); pos=min(pos,ask_nxt(1,1,n,t[i].w+1)); c[pos]=t[i].val; add(1,1,n,pos,-1); &#125; for(int i=1;i&lt;=n;i++) printf("%d ",c[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟]拆网线]]></title>
    <url>%2F2018%2F07%2F06%2FNOIP2017%E6%A8%A1%E6%8B%9F-%E6%8B%86%E7%BD%91%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题目描述企鹅国的网吧们之间由网线互相连接，形成一棵树的结构。现在由于冬天到了，供暖部门缺少燃料，于是他们决定去拆一些网线来做燃料。但是现在有 K 只企鹅要上网和别人联机游戏，所以他们需要把这 K 只企鹅安排到不同的机房（两只企鹅在同一个机房会吵架），然后拆掉一些网线，但是需要保证每只企鹅至少还能通过留下来的网线和至少另一只企鹅联机游戏。所以他们想知道，最少需要保留多少根网线？ 从叶子节点往上贪心1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int N=100050;vector&lt;int&gt; e[N];queue&lt;int&gt; Q;int used[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void dfs(int o,int fa)&#123; for(int i=0;i&lt;e[o].size();i++) &#123; int to=e[o][i]; if (to==fa) continue; dfs(to,o); &#125; Q.push(o);&#125;int main()&#123; int T=read(); while (T--) &#123; int n=read(),k=read(),ans=0; for(int i=1;i&lt;=n;i++) e[i].clear(),used[i]=0; for(int i=1;i&lt;n;i++) &#123; int u=read(),v=i+1; e[u].push_back(v); e[v].push_back(u); &#125; while (!Q.empty()) Q.pop(); dfs(1,0); while (!Q.empty()&amp;&amp;k&gt;1) &#123; int x=Q.front();Q.pop(); if (used[x]) continue; for(int i=0;i&lt;e[x].size();i++) &#123; int to=e[x][i]; if (used[to]) continue; used[x]=used[to]=1; ans++,k-=2; break; &#125; &#125; printf("%d\n",ans+k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3941 入阵曲]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%B4%9B%E8%B0%B7P3941-%E5%85%A5%E9%98%B5%E6%9B%B2%2F</url>
    <content type="text"><![CDATA[用sum\left [ i \right ]\left [ j \right ]，记录第i行，前j个的和枚举i,j两列\left ( i]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2568 GCD]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%B4%9B%E8%B0%B7P2568-GCD%2F</url>
    <content type="text"><![CDATA[对于一组gcd(x,y)=1，若有一个质数p，则gcd(xp,yp)=p枚举所有的p，求所有xp]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2005]九数码游戏]]></title>
    <url>%2F2018%2F07%2F06%2FZJOI2005-%E4%B9%9D%E6%95%B0%E7%A0%81%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[直接搜索加剪枝剪枝可以考虑Cantor展开，也可以直接用map12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;queue&gt;#define LL long longusing namespace std;const int N=5,ed=12345678;struct node &#123;LL s;int k;&#125;;map&lt;LL,LL&gt; M;int ans=-1,w[N&lt;&lt;2];queue&lt;node&gt; Q;LL modify(LL s,int f)&#123; for(int i=9;i&gt;0;i--) w[i]=s%10,s/=10; if (f) &#123; int num=w[6];LL ret=0; w[6]=w[5],w[5]=w[4],w[4]=num; for(int i=1;i&lt;=9;i++) ret=ret*10+w[i]; return ret; &#125; else &#123; int num=w[1];LL ret=0; w[1]=w[4],w[4]=w[7],w[7]=w[8]; w[8]=w[9],w[9]=w[6],w[6]=w[3]; w[3]=w[2],w[2]=num; for(int i=1;i&lt;=9;i++) ret=ret*10+w[i]; return ret; &#125; &#125;void bfs(LL st)&#123; M[st]=0,Q.push((node)&#123;st,0&#125;); while (!Q.empty()) &#123; node x=Q.front();Q.pop(); if (x.s==ed) &#123;ans=x.k;return;&#125; LL nxt=modify(x.s,0); if (M.find(nxt)==M.end()) &#123; M[nxt]=x.s; Q.push((node)&#123;nxt,x.k+1&#125;); &#125; nxt=modify(x.s,1); if (M.find(nxt)==M.end()) &#123; M[nxt]=x.s; Q.push((node)&#123;nxt,x.k+1&#125;); &#125; &#125;&#125;void dfs(LL s)&#123; if (!s) return; dfs(M[s]); for(int i=9;i&gt;0;i--) w[i]=s%10,s/=10; for(int i=1;i&lt;=9;i++) printf("%d%c",w[i],i%3?' ':'\n'); printf("\n");&#125;int main()&#123; LL num=0; for(int i=1;i&lt;=9;i++) &#123; int x; scanf("%d",&amp;x); num=num*10+x; &#125; bfs(num); if (ans==-1) &#123;puts("UNSOLVABLE");return 0;&#125; printf("%d\n",ans),dfs(ed); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1484 种树]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%B4%9B%E8%B0%B7P1484-%E7%A7%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[神奇的贪心 对于a_{i}，若最终答案不包含a_{i}，则一定包含a_{i-1}+a_{i+1}因此每次取a_{i}时，加入a_{i-1}+a_{i+1}-a_{i}，允许撤销操作123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=500050;int n,m,w[N],L[N],R[N],used[N];struct node &#123;LL val;int id;&#125;;struct cmp &#123;bool operator ()(node a,node b) &#123;return a.val&lt;b.val;&#125;&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; Q;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),Q.push((node)&#123;w[i],i&#125;); for(int i=1;i&lt;=n;i++) L[i]=i-1,R[i]=i+1; R[0]=1,L[n+1]=n;LL ans=0; while (m--) &#123; while (used[Q.top().id]) Q.pop(); int k=Q.top().id; used[L[k]]=used[R[k]]=1; if (Q.top().val&lt;=0) break; ans=ans+Q.top().val,Q.pop(); Q.push((node)&#123;w[k]=w[L[k]]+w[R[k]]-w[k],k&#125;); L[k]=L[L[k]],R[L[k]]=k; R[k]=R[R[k]],L[R[k]]=k; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim游戏]]></title>
    <url>%2F2018%2F07%2F06%2FNIM%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[当且仅当\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=0为一个P 最终状态为0 对于一个\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=k\left ( k>0 \right ) 的状态，必存在一个a_{i}>k，使得下一步\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=0 对于一个\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=0，不存在一种方案使得下一步\left ( a_{1} \right ) xor\left ( a_{2}\right ) ...\left ( a_{n} \right )=k\left ( k>0 \right )]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2719]银河之星]]></title>
    <url>%2F2018%2F07%2F05%2FBZOJ2719-%E9%93%B6%E6%B2%B3%E4%B9%8B%E6%98%9F%2F</url>
    <content type="text"><![CDATA[通过观察可以发现点在%3意义下相同直接暴力搜索加剪枝但是要注意棋盘大小，棋盘小有些点跳不过去。代码没有考虑棋盘大小，有部分点会WA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=15;int K,n,m,xx,yy,x[N],y[N],used[N],f,w[N],cnt=0;set&lt;LL&gt; S;int F(int x,int y) &#123;return x*3+y+1;&#125;void dfs(int k)&#123; if (f) return; if (k==1) &#123; for(int i=1;i&lt;=K;i++) if (!used[i]) f=xx==x[i]&amp;&amp;yy==y[i]; return; &#125; cnt=0;LL num=0; for(int i=1;i&lt;=K;i++) if (!used[i]) w[++cnt]=F(x[i],y[i]); sort(w+1,w+cnt+1); for(int i=1;i&lt;=cnt;i++) num=num*10+w[i]; if (!S.empty()&amp;&amp;S.find(num)!=S.end()) return; S.insert(num); for(int i=1;i&lt;=K;i++) if (!used[i]) for(int j=1;j&lt;=K;j++) if (!used[j]&amp;&amp;i!=j) if (!(xx==x[i]&amp;&amp;yy==y[i])) &#123; int u=x[i],v=y[i]; used[j]=1; x[i]=x[i]==x[j]?x[i]:3-x[i]-x[j]; y[i]=y[i]==y[j]?y[i]:3-y[i]-y[j]; dfs(k-1); used[j]=0; x[i]=u,y[i]=v; &#125;&#125;int main()&#123; while (scanf("%d%d%d%d%d",&amp;K,&amp;n,&amp;m,&amp;xx,&amp;yy)!=EOF) &#123; xx%=3,yy%=3;S.clear(); for(int i=1;i&lt;=K;i++) scanf("%d%d",&amp;x[i],&amp;y[i]); for(int i=1;i&lt;=K;i++) x[i]%=3,y[i]%=3; for(int i=1;i&lt;=K;i++) used[i]=0; f=0,dfs(K); printf("%s\n",f?"Yes":"No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[藏妹子之处]]></title>
    <url>%2F2018%2F07%2F05%2F%E8%97%8F%E5%A6%B9%E5%AD%90%E4%B9%8B%E5%A4%84%2F</url>
    <content type="text"><![CDATA[首先要有个妹子 问题描述：今天CZY又找到了三个妹子，有着收藏爱好的他想要找三个地方将妹子们藏起来，将一片空地抽象成一个R行C列的表格，CZY要选出3个单元格。但要满足如下的两个条件：（1）任意两个单元格都不在同一行。（2）任意两个单元格都不在同一列。选取格子存在一个花费，而这个花费是三个格子两两之间曼哈顿距离的和（如(x1,y1)和(x,y2)的曼哈顿距离为|x1-x2|+|y1-y2|）。狗狗想知道的是，花费在minT到maxT之间的方案数有多少。答案模1000000007。所谓的两种不同方案是指：只要它选中的单元格有一个不同，就认为是不同的方案。 通过观察，不难发现在一个R*C的矩阵中，所有最大的三个单元格曼哈顿距离相等，均为2(R+C)-4通过简单地分析可以得出，在R*C的矩阵中，共有6（R-2)(C-2)组最大的三个单元格代码就很简单了123456789101112131415#include&lt;cstdio&gt;#define LL long longconst int mod=1000000007;int r,c,mins,maxs;LL ans=0;int main()&#123; scanf("%d%d%d%d",&amp;r,&amp;c,&amp;mins,&amp;maxs); for(int i=2;i&lt;r;i++) for(int j=2;j&lt;c;j++) if (i*2+j*2&lt;=maxs&amp;&amp;i*2+j*2&gt;=mins) ans=(ans+6LL*(r-i)*(c-j)*(i-1)*(j-1))%mod; printf("%d",ans); return 0;&#125; 临山依水 景看旧 而你美胜 山水万筹]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2005]互不侵犯]]></title>
    <url>%2F2018%2F07%2F05%2FSCOI2005-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF%2F</url>
    <content type="text"><![CDATA[预处理一行所有可能的情况用dp\left [d \right ]\left [ i\right ]\left [ k \right ]数组记录第d行，当前状态为s\left [ i \right ]，总共放置k个的方案数复杂度O\left ( nk4^{n} \right )1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#define LL long longconst int N=10;int n,m,s[1&lt;&lt;N],w[1&lt;&lt;N],c[1&lt;&lt;N][1&lt;&lt;N],cnt=0;LL dp[N][N&lt;&lt;2][1&lt;&lt;N],ans=0;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;(1&lt;&lt;n);i++) if (!(i&amp;(i&lt;&lt;1))&amp;&amp;!(i&amp;(i&gt;&gt;1))) s[++cnt]=i; for(int i=1;i&lt;=cnt;i++) for(int k=1;k&lt;=n;k++) if (s[i]&amp;(1&lt;&lt;(k-1))) w[i]++; for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) if (!(s[i]&amp;s[j])) if (!(s[i]&amp;(s[j]&lt;&lt;1))&amp;&amp;!(s[i]&amp;(s[j]&gt;&gt;1))) c[i][j]=1; for(int i=1;i&lt;=cnt;i++) dp[1][w[i]][i]=1; for(int d=2;d&lt;=n;d++) for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) if (c[i][j]) for(int k=w[i];k&lt;=m-w[j];k++) dp[d][k+w[j]][j]+=dp[d-1][k][i]; for(int i=1;i&lt;=cnt;i++) ans+=dp[n][m][i]; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1429 平面最近点对]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%B4%9B%E8%B0%B7P1429-%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[裸的二分，复杂度O\left ( nlog^{2}n \right )1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=200050,INF=1&lt;&lt;30;struct dot &#123;double x,y;&#125; t[N];vector&lt;int&gt; w;bool cmp(dot a,dot b) &#123;return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;bool check(int a,int b) &#123;return t[a].y&lt;t[b].y;&#125;double sqr(double x) &#123;return x*x;&#125;double dist(dot a,dot b) &#123;return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));&#125;double calc(int l,int r)&#123; double ret=INF; if (l==r) return ret; int mid=(l+r)&gt;&gt;1; ret=min(ret,min(calc(l,mid),calc(mid+1,r))); w.clear(); for(int i=l;i&lt;=r;i++) if (fabs(t[i].x-t[mid].x)&lt;ret) w.push_back(i); sort(w.begin(),w.end(),check); for(int i=0;i&lt;w.size();i++) for(int j=i+1;j&lt;w.size()&amp;&amp;fabs(t[w[i]].y-t[w[j]].y)&lt;ret;j++) ret=min(ret,dist(t[w[i]],t[w[j]])); return ret; &#125;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;t[i].x,&amp;t[i].y); sort(t+1,t+n+1,cmp); printf("%.4lf",calc(1,n)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3933 Chtholly Nota Seniorious]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%B4%9B%E8%B0%B7P3933-Chtholly-Nota-Seniorious%2F</url>
    <content type="text"><![CDATA[神奇的二分答案题 根据题目奇奇怪怪的限制，不难发现选择的行和列要连续为了方便计算，将矩阵转置四次，每次只需考虑行要连续二分一下ans进行检验对于矩阵中的mins和maxs，显然二者不能分在一起根据mins，maxs和二分出来的ans，贪心地确定每个值所在的分组，若不连续则不合法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=2050,INF=1&lt;&lt;30;int n,m,now,w[2][N][N],ans,mins=INF,maxs=-INF;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void rotate()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[now^1][j][n-i+1]=w[now][i][j]; swap(n,m),now^=1;&#125;bool check(int k)&#123; int num=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) if (maxs-w[now][i][j]&gt;k) num=max(num,j); for(int j=1;j&lt;=num;j++) if (w[now][i][j]-mins&gt;k) return 0; &#125; return 1;&#125;void solve()&#123; int L=0,R=ans; while (L&lt;R) &#123; int mid=(L+R)&gt;&gt;1; if (check(mid)) R=mid; else L=mid+1; &#125; ans=R;&#125;int main()&#123; n=read(),m=read(),now=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; w[0][i][j]=read(); maxs=max(maxs,w[0][i][j]); mins=min(mins,w[0][i][j]); &#125; ans=maxs-mins; rotate(),solve(); rotate(),solve(); rotate(),solve(); rotate(),solve(); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大化平均值]]></title>
    <url>%2F2018%2F07%2F05%2Fmax-ave%2F</url>
    <content type="text"><![CDATA[问题描述：有n个物品的重量和价值分别是 wi 和 vi。从中选出k个物品使得单位重量的价值最大。 根据定义 \sum_{i=1}^{k}v_{i}=x\sum_{i=1}^{k}w_{i}即 \sum_{i=1}^{k}\left (v _{i}-xw_{i} \right )=0二分一下x，每次在\left (v _{i}-xw_{i} \right )贪心地找前k大的复杂度O\left ( nlog^{2}n \right )123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=10050;const double eps=1e-5;int n,m,w[N],v[N];double c[N];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;bool check(double k)&#123; for(int i=1;i&lt;=n;i++) c[i]=v[i]-k*w[i]; sort(c+1,c+n+1); double ret=0; for(int i=n;i&gt;n-m;i--) ret+=c[i]; return ret&gt;-eps;&#125;int main()&#123; n=read(),m=read(); double L=0,R; for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;=n;i++) v[i]=read(),R=max((double)v[i],R); while (R-L&gt;eps) &#123; double mid=(L+R)/2; if (check(mid)) L=mid; else R=mid; &#125; printf("%.2lf",R); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017]列队]]></title>
    <url>%2F2018%2F06%2F28%2FNOIP2017-%E5%88%97%E9%98%9F%2F</url>
    <content type="text"><![CDATA[感觉是至今为止做到的最难的数据结构题什么分块，嵌套，可持久化都没有这题给人的第一感觉难这题每个数据开一个点都开不下。考场上见到这题基本上一脸懵逼，想了很久写了个O\left ( q^{2}\right )但是不能优化的算法，结果没开LL只有30分用线段树维护每一行和最后一列，支持单点rank和insert两种操作最大长度为max\left ( n,m \right )+q动态开点减少内存，空间复杂度O\left ( 4qlog\left ( max\left ( n,m \right )+q\right ) \right )12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=300050;struct node &#123;int l,r,sz,id;bool f;&#125; t[N*60];int n,m,T,cnt=0,idx=0,rt[N],sz[N],pos,u,v;LL w[N&lt;&lt;2];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar(); if (ch=='-') t=-1,ch=getchar(); while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-48,ch=getchar(); return x*t;&#125;void build(int &amp;o,int l,int r,int f)&#123; o=++cnt; if (l==r) &#123; t[o].sz=(!f&amp;&amp;r&lt;m)||(f&amp;&amp;r&lt;=n); return; &#125; int mid=(l+r)&gt;&gt;1; build(t[o].l,l,mid,f); build(t[o].r,mid+1,r,f); t[o].sz=t[t[o].l].sz+t[t[o].r].sz;&#125;LL ask(int &amp;o,int pre,int l,int r,int f)&#123; if (!t[o].f) o=++cnt,t[o]=t[pre],t[o].f=1; if (l==r) &#123; t[o].sz=0; if (!f&amp;&amp;r&lt;m) return (LL)(u-1)*m+l; if (f&amp;&amp;r&lt;=n) return (LL)r*m; return w[t[o].id]; &#125; int num=t[t[o].l].sz,mid=(l+r)&gt;&gt;1;LL ret; if (pos&lt;=num) ret=ask(t[o].l,t[pre].l,l,mid,f); else pos-=num,ret=ask(t[o].r,t[pre].r,mid+1,r,f); t[o].sz=t[t[o].l].sz+t[t[o].r].sz; return ret;&#125;void insert(int &amp;o,int pre,int l,int r,LL x)&#123; if (!t[o].f) o=++cnt,t[o]=t[pre],t[o].f=1; if (l==r) &#123; w[++idx]=x; t[o].id=idx,t[o].sz=1; return; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) insert(t[o].l,t[pre].l,l,mid,x); else insert(t[o].r,t[pre].r,mid+1,r,x); t[o].sz=t[t[o].l].sz+t[t[o].r].sz;&#125;int main()&#123; n=read(),m=read(),T=read(); int maxs=max(n,m)+T; build(rt[0],1,maxs,0); for(int i=1;i&lt;=n;i++) rt[i]=++cnt,t[cnt]=t[rt[0]],t[cnt].f=1; for(int i=1;i&lt;=n;i++) sz[i]=m-1;sz[n+1]=n; build(rt[n+1],1,maxs,1); while (T--) &#123; u=read(),v=read(); if (v==m) &#123; LL x; pos=u,x=ask(rt[n+1],rt[n+1],1,maxs,1); printf("%lld\n",x); pos=++sz[n+1],insert(rt[n+1],rt[n+1],1,maxs,x); &#125; else &#123; LL x,w; pos=v,x=ask(rt[u],rt[u],1,maxs,0); printf("%lld\n",x); pos=u,w=ask(rt[n+1],rt[n+1],1,maxs,1); pos=++sz[u],insert(rt[u],rt[u],1,maxs,w); pos=++sz[n+1],insert(rt[n+1],rt[n+1],1,maxs,x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017]宝藏]]></title>
    <url>%2F2018%2F06%2F22%2FNOIP2017-%E5%AE%9D%E8%97%8F%2F</url>
    <content type="text"><![CDATA[一道状压dp的题当初考场上没有想到如何保存状态，写了个O\left ( 2^{n} n!\right )的，拿了70分dp数组记录最大深度d，和已选点状态s对于每个s，枚举补集进行更新枚举补集复杂度为O\left ( 3^{n}\right )，总复杂度O\left ( n3^{n} \right )12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=14,INF=1&lt;&lt;30;int n,m,dp[N][1&lt;&lt;N],w[1&lt;&lt;N],idx[1&lt;&lt;N],pos[1&lt;&lt;N],c[N],f[N][N],val[N];vector&lt;int&gt; e[N];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) f[i][j]=INF; for(int d=0;d&lt;=n;d++) for(int i=0;i&lt;(1&lt;&lt;n);i++) dp[d][i]=INF; for(int i=1;i&lt;=m;i++) &#123; int u,v,val; scanf("%d%d%d",&amp;u,&amp;v,&amp;val); f[u][v]=f[v][u]=min(val,f[u][v]); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if (f[i][j]!=INF) e[i].push_back(j); for(int i=1;i&lt;=n;i++) dp[0][1&lt;&lt;(i-1)]=0; for(int d=0;d&lt;=n;d++) for(int s=0,cnt=0;s&lt;(1&lt;&lt;n);s++,cnt=0) if (dp[d][s]!=INF) &#123; for(int i=1;i&lt;=n;i++) if (!(s&gt;&gt;(i-1)&amp;1)) pos[1&lt;&lt;cnt]=i,val[i]=INF,c[cnt++]=i; for(int k=1;k&lt;(1&lt;&lt;cnt);k++) &#123; int x=0; for(int i=0;i&lt;cnt;i++) if ((k&gt;&gt;i)&amp;1) x|=1&lt;&lt;(c[i]-1); idx[k]=x,w[x]=INF; &#125; for(int i=1;i&lt;=n;i++) if ((s&gt;&gt;(i-1))&amp;1) for(int j=0;j&lt;e[i].size();j++) &#123; int to=e[i][j]; if (!((s&gt;&gt;(to-1))&amp;1)) val[to]=min(f[i][to],val[to]); &#125; for(int k=1;k&lt;(1&lt;&lt;cnt);k++) if (w[idx[k-(k&amp;-k)]]!=INF&amp;&amp;val[pos[k&amp;-k]]!=INF) w[idx[k]]=w[idx[k-(k&amp;-k)]]+(d+1)*val[pos[k&amp;-k]]; for(int k=0;k&lt;(1&lt;&lt;cnt);k++) if (!(s&amp;idx[k])&amp;&amp;w[idx[k]]!=INF) dp[d+1][s|idx[k]]=min(dp[d+1][s|idx[k]],dp[d][s]+w[idx[k]]); &#125; int ans=INF; for(int i=1;i&lt;=n;i++) ans=min(ans,dp[i][(1&lt;&lt;n)-1]); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2009]梦幻布丁]]></title>
    <url>%2F2018%2F06%2F20%2FHNOI2009-%E6%A2%A6%E5%B9%BB%E5%B8%83%E4%B8%81%2F</url>
    <content type="text"><![CDATA[用并查集维护在代表元素中保存当前段的颜色（w[]），和左右端点（s[]，t[]）再用一个桶维护每种颜色的所有段当且仅当要合并两段颜色相同时进行合并，并更新左右端点对于每个桶用list维护，再进行启发式合并，这里偷懒直接用了vector123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=100050;int fa[N],w[N],cnt,s[N],t[N],n,m;vector&lt;int&gt; f[N*10];inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;int find(int x) &#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void unite(int u,int v)&#123; if (!u||!v) return; u=find(u),v=find(v); if (w[u]!=w[v]) return;else cnt--; fa[v]=u,s[u]=min(s[u],s[v]),t[u]=max(t[u],t[v]);&#125;void update()&#123; int u=read(),v=read(); if (u==v) return; while (!f[u].empty()) &#123; int x=f[u].back();f[u].pop_back(); if (find(x)!=x) continue;else w[x]=v; int st=s[x],ed=t[x]; if (st&gt;1) unite(st-1,st); if (ed&lt;n) unite(ed,ed+1); if (find(x)==x) f[v].push_back(x); &#125; &#125;int main()&#123; n=cnt=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),fa[i]=i; for(int i=1;i&lt;=n;i++) s[i]=t[i]=i; for(int i=1;i&lt;n;i++) unite(i,i+1); for(int i=1;i&lt;=n;i++) if (i==find(i)) f[w[i]].push_back(i); for(int i=1;i&lt;=m;i++) &#123; int opt=read(); if (opt==1) update(); if (opt==2) printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1471 方差]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%B4%9B%E8%B0%B7P1471-%E6%96%B9%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[区间修改，区间查询，基本可以用线段树维护，主要是方差比较难维护将方差的计算展开 \frac{\sum_{i=1}^{n} \left ( a_{i}-\bar{a} \right )^{2}}{n}= \frac{\sum_{i=1}^{n} a_{i}^{2}-2\bar{a}\sum_{i=1}^{n}a_{i}+n\bar{a}^{2}}{n}= -\bar{a}^{2}+\frac{\sum_{i=1}^{n}a_{i}^{2}}{n}对于区间加法 \sum_{i=l}^{r}\left ( a_{i}+x \right )^{2}= \sum_{i=l}^{r}a_{i}^{2}+2x\sum_{i=l}^{r}a_{i}+\left ( r-l+1 \right )*x^{2} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N=100050;const double eps=1e-8;int n,m,ql,qr;struct node &#123;double val,sum,c;&#125; t[N&lt;&lt;2]; double sqr(double x) &#123;return x*x;&#125;void build(int o,int l,int r)&#123; if (l==r) &#123; scanf("%lf",&amp;t[o].val); t[o].sum=sqr(t[o].val); return; &#125; int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); t[o].val=t[o&lt;&lt;1].val+t[o&lt;&lt;1|1].val; t[o].sum=t[o&lt;&lt;1].sum+t[o&lt;&lt;1|1].sum;&#125;void pushdown(int o,int l,int r)&#123; double x=t[o].c;t[o].c=0; int mid=(l+r)&gt;&gt;1; t[o&lt;&lt;1].sum+=(mid-l+1)*sqr(x)+2*x*t[o&lt;&lt;1].val; t[o&lt;&lt;1|1].sum+=(r-mid)*sqr(x)+2*x*t[o&lt;&lt;1|1].val; t[o&lt;&lt;1].val+=(mid-l+1)*x; t[o&lt;&lt;1|1].val+=(r-mid)*x; t[o&lt;&lt;1].c+=x,t[o&lt;&lt;1|1].c+=x; &#125;void update(int o,int l,int r,double x)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123; t[o].sum+=sqr(x)*(r-l+1)+2*x*t[o].val; t[o].val+=(r-l+1)*x;t[o].c+=x; return; &#125; int mid=(l+r)&gt;&gt;1; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) update(o&lt;&lt;1,l,mid,x); if (qr&gt;mid) update(o&lt;&lt;1|1,mid+1,r,x); t[o].val=t[o&lt;&lt;1].val+t[o&lt;&lt;1|1].val; t[o].sum=t[o&lt;&lt;1].sum+t[o&lt;&lt;1|1].sum;&#125;double ask(int o,int l,int r)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return t[o].val; int mid=(l+r)&gt;&gt;1;double ret=0; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) ret+=ask(o&lt;&lt;1,l,mid); if (qr&gt;mid) ret+=ask(o&lt;&lt;1|1,mid+1,r); return ret;&#125;double query(int o,int l,int r)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return t[o].sum; int mid=(l+r)&gt;&gt;1;double ret=0; if (fabs(t[o].c)&gt;eps) pushdown(o,l,r); if (ql&lt;=mid) ret+=query(o&lt;&lt;1,l,mid); if (qr&gt;mid) ret+=query(o&lt;&lt;1|1,mid+1,r); return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; int opt; scanf("%d%d%d",&amp;opt,&amp;ql,&amp;qr); if (opt==1) &#123; double x;scanf("%lf",&amp;x); update(1,1,n,x); &#125; if (opt==2) printf("%.4lf\n",ask(1,1,n)/(qr-ql+1)); if (opt==3) &#123; double x=ask(1,1,n)/(qr-ql+1); printf("%.4lf\n",-sqr(x)+query(1,1,n)/(qr-ql+1)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]书架]]></title>
    <url>%2F2018%2F06%2F13%2FZJOI2006-%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一看题目就有一种平衡树的气息。给每本书一个val来维护相对位置再用一个pos[]数组记录下编号为x的位置pos[x]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=1&lt;&lt;30,N=200050;int rt=0,cnt=0,n,m,pos[N],w[N],L,R;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;struct node &#123;int ch[2],fa,rec,val,sz;&#125;t[N];namespace Splay&#123; void calc(int o) &#123;t[o].sz=t[t[o].ch[0]].sz+t[t[o].ch[1]].sz+1;&#125; void maintain(int o) &#123;pos[t[o].rec]=o;&#125; void rotate(int x) &#123; int y=t[x].fa,z=t[y].fa,k=t[y].ch[1]==x; t[z].ch[t[z].ch[1]==y]=x,t[x].fa=z; t[y].ch[k]=t[x].ch[k^1],t[t[x].ch[k^1]].fa=y; t[x].ch[k^1]=y,t[y].fa=x; calc(y),calc(x); &#125; void splay(int x,int to) &#123; while (t[x].fa!=to) &#123; int y=t[x].fa,z=t[y].fa; if (z!=to) (t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; if (!to) rt=x; &#125; void ins(int &amp;o,int fa,int x,int idx) &#123; if (!o) &#123; o=++cnt; t[o].val=x,t[o].fa=fa; t[o].sz=1; t[o].rec=idx; pos[idx]=o; splay(o,0); return; &#125; t[o].sz++; ins(t[o].ch[x&gt;t[o].val],o,x,idx); &#125; void find(int x) &#123; int o=rt; while (t[o].ch[x&gt;t[o].val]&amp;&amp;x!=t[o].val) o=t[o].ch[x&gt;t[o].val]; splay(o,0); &#125; int next(int x,int opt) &#123; find(x); if ((t[rt].val&gt;x&amp;&amp;opt)||(t[rt].val&lt;x&amp;&amp;!opt)) return rt; int o=t[rt].ch[opt]; while (t[o].ch[opt^1]) o=t[o].ch[opt^1]; return o; &#125; void del(int x) &#123; int pre=next(x,0),nxt=next(x,1); splay(pre,0),splay(nxt,pre); int o=t[nxt].ch[0]; t[nxt].ch[0]=0; calc(nxt);calc(pre); &#125; int K_th(int o,int k) &#123; if (!o) return 0; if (k&lt;=t[t[o].ch[0]].sz) return K_th(t[o].ch[0],k); else if (k&gt;t[t[o].ch[0]].sz+1) return K_th(t[o].ch[1],k-t[t[o].ch[0]].sz-1); splay(o,0); return t[o].rec; &#125;&#125;;using namespace Splay;void insert(int x,int f)&#123; if (!f) return; if (f&lt;0) f++; int nxt=next(t[pos[x]].val,f); swap(t[nxt].rec,t[pos[x]].rec); maintain(pos[x]),maintain(nxt);&#125;int main()&#123; L=1,R=n=read(),m=read(); ins(rt,0,INF,0),ins(rt,0,-INF,0); for(int i=1;i&lt;=n;i++) ins(rt,0,i,read()); for(int i=1;i&lt;=m;i++) &#123; char str[20]; scanf("%s",str); int x=read(); if (str[0]=='T') del(t[pos[x]].val),ins(rt,0,--L,x); if (str[0]=='B') del(t[pos[x]].val),ins(rt,0,++R,x); if (str[0]=='I') insert(x,read()); if (str[0]=='A') find(t[pos[x]].val),printf("%d\n",t[t[rt].ch[0]].sz-1); if (str[0]=='Q') printf("%d\n",K_th(rt,x+1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2011]ROT-Tree Rotations]]></title>
    <url>%2F2018%2F06%2F13%2FPOI2011-ROT-Tree-Rotations%2F</url>
    <content type="text"><![CDATA[对于每个节点分别求左-右，右-左的逆序对，将较小的加入答案原来思路：枚举个数较少的节点的每个数，二分求答案看完题解发现可以用线段树合并。新技能get123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=400050;int cnt,st,ch[N][2],w[N],rt[N],n;int idx,ls[N*20],rs[N*20],sum[N*20];LL ans,f,g;void dfs(int &amp;o)&#123; o=++cnt; scanf("%d",&amp;w[o]); if (!w[o]) dfs(ch[o][0]),dfs(ch[o][1]);&#125;void build(int &amp;o,int l,int r,int k)&#123; o=++idx; if (l==r) &#123;sum[o]=1;return;&#125; int mid=(l+r)&gt;&gt;1; k&lt;=mid?build(ls[o],l,mid,k):build(rs[o],mid+1,r,k); sum[o]=sum[ls[o]]+sum[rs[o]];&#125;int merge(int u,int v)&#123; if (!u||!v) return v+u; f+=(LL)sum[rs[u]]*sum[ls[v]]; g+=(LL)sum[ls[u]]*sum[rs[v]]; int o=++idx; ls[o]=merge(ls[u],ls[v]); rs[o]=merge(rs[u],rs[v]); sum[o]=sum[ls[o]]+sum[rs[o]]; return o;&#125;void calc(int o)&#123; if (!o) return; calc(ch[o][0]),calc(ch[o][1]); if (!w[o]) &#123; f=g=0; rt[o]=merge(rt[ch[o][0]],rt[ch[o][1]]); ans+=min(f,g); &#125;&#125;int main()&#123; scanf("%d",&amp;n); dfs(st); for(int i=1;i&lt;=cnt;i++) if (w[i]) build(rt[i],1,n,w[i]); calc(st); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]皇帝的烦恼]]></title>
    <url>%2F2018%2F06%2F13%2FZJOI2006-%E7%9A%87%E5%B8%9D%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[二分+dpdp不是很好想f记录与第一个位置相同个数的最大值g记录与第一个位置相同个数的最小值12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=20050;int n,maxs,sum=0,w[N],f[N],g[N];//f&gt;&gt;max g&gt;&gt;minbool check(int k)&#123; f[1]=g[1]=w[1]; for(int i=2;i&lt;=n;i++) &#123; f[i]=min(w[1]-g[i-1],w[i]); g[i]=max(0,w[i]-(k-w[i-1]-w[1]+f[i-1])); &#125; return !g[n];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]),sum+=w[i]; maxs=w[1]+w[n]; for(int i=1;i&lt;n;i++) maxs=max(maxs,w[i]+w[i+1]); if (!(n&amp;1)) &#123;printf("%d",maxs);return 0;&#125; int L=maxs,R=sum; while (L&lt;R) &#123; int mid=(L+R)&gt;&gt;1; if (check(mid)) R=mid; else L=mid+1; &#125; printf("%d",L); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay模板]]></title>
    <url>%2F2018%2F06%2F11%2FSplay%2F</url>
    <content type="text"><![CDATA[优化了一下之前Splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;const int INF=1&lt;&lt;30,N=100050;int rt=0,cnt=0,n;inline int read()&#123; register int x=0,t=1; register char ch=getchar(); while ((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if (ch=='-') &#123;t=-1;ch=getchar();&#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-48;ch=getchar();&#125; return x*t;&#125;struct node &#123;int ch[2],fa,rec,val,sz;&#125;t[N];namespace Splay&#123; void calc(int o) &#123;t[o].sz=t[t[o].ch[0]].sz+t[t[o].ch[1]].sz+t[o].rec;&#125; void rotate(int x) &#123; int y=t[x].fa,z=t[y].fa,k=t[y].ch[1]==x; t[z].ch[t[z].ch[1]==y]=x,t[x].fa=z; t[y].ch[k]=t[x].ch[k^1],t[t[x].ch[k^1]].fa=y; t[x].ch[k^1]=y,t[y].fa=x; calc(y),calc(x); &#125; void splay(int x,int to) &#123; while (t[x].fa!=to) &#123; int y=t[x].fa,z=t[y].fa; if (z!=to) (t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; if (!to) rt=x; &#125; void ins(int &amp;o,int fa,int x) &#123; if (!o) &#123; o=++cnt; t[o].val=x,t[o].fa=fa; t[o].sz=t[o].rec=1; splay(o,0); return; &#125; t[o].sz++; if (x==t[o].val) &#123;t[o].rec++;return;&#125; ins(t[o].ch[x&gt;t[o].val],o,x); &#125; void find(int x) &#123; int o=rt; while (t[o].ch[x&gt;t[o].val]&amp;&amp;x!=t[o].val) o=t[o].ch[x&gt;t[o].val]; splay(o,0); &#125; int next(int x,int opt) &#123; find(x); if ((t[rt].val&gt;x&amp;&amp;opt)||(t[rt].val&lt;x&amp;&amp;!opt)) return rt; int o=t[rt].ch[opt]; while (t[o].ch[opt^1]) o=t[o].ch[opt^1]; return o; &#125; void del(int x) &#123; int pre=next(x,0),nxt=next(x,1); splay(pre,0),splay(nxt,pre); int o=t[nxt].ch[0]; if (t[o].rec&gt;1) &#123; t[o].rec--; splay(o,0); &#125; else t[nxt].ch[0]=0; &#125; int K_th(int o,int k) &#123; if (!o) return 0; if (k&lt;=t[t[o].ch[0]].sz) return K_th(t[o].ch[0],k); else if (k&gt;t[t[o].ch[0]].sz+t[o].rec) return K_th(t[o].ch[1],k-t[t[o].ch[0]].sz-t[o].rec); splay(o,0); return t[o].val; &#125;&#125;;using namespace Splay;int main()&#123; n=read(); ins(rt,0,INF),ins(rt,0,-INF); for(int i=1;i&lt;=n;i++) &#123; int opt=read(),x=read(); if (opt==1) ins(rt,0,x); if (opt==2) del(x); if (opt==3) find(x),printf("%d\n",t[t[rt].ch[0]].sz); if (opt==4) printf("%d\n",K_th(rt,x+1)); if (opt==5) printf("%d\n",t[next(x,0)].val); if (opt==6) printf("%d\n",t[next(x,1)].val); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
